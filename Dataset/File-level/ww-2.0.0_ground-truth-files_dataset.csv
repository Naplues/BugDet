File,Bug,SRC
api/src/main/java/org/apache/struts2/Action.java,false,"package org.apache.struts2;

/**
 * Default action interface. Provided purely for user convenience. Struts does not require actions to implement any
 * interfaces. Actions need only implement a public, no argument method which returns {@code String}. If a user does
 * not specify a method name, Struts defaults to {@code execute()}.
 *
 * <p>For example:
 *
 * <pre>
 *   static import ResultNames.*;
 *
 *   public class MyAction <b>implements Action</b> {
 *
 *     public String execute() {
 *       return SUCCESS;
 *     }
 *   }
 * </pre>
 *
 * <p>is equivalent to:
 *
 * <pre>
 *   static import ResultNames.*;
 *
 *   public class MyAction {
 *
 *     public String execute() {
 *       return SUCCESS;
 *     }
 *   }
 * </pre>
 *
 * @author crazybob@google.com (Bob Lee)
 */
public interface Action {

    /**
     * Executes this action.
     *
     * @return result name which matches a result name from the action mapping in the configuration file. See {@link
     *  ResultNames} for common suggestions.
     */
    String execute();
}
"
api/src/main/java/org/apache/struts2/MessageAware.java,false,"package org.apache.struts2;

/**
 * Implemented by actions which may need to record errors or messages.
 *
 * <pre>
 *   static import ResultNames.*;
 *
 *   public class SetName implements MessageAware {
 *
 *     Messages messages;
 *     String name;
 *
 *     public String execute() {
 *       return SUCCESS;
 *     }
 *
 *     public void setName(String name) {
 *       if ("".equals(name))
 *         messages.forField("name").addError("name.required");
 *
 *       this.name = name;
 *     }
 *
 *     public void setMessages(Messages messages) {
 *       this.messages = messages;
 *     }
 *   }
 * </pre>
 *
 * @author crazybob@google.com (Bob Lee)
 */
public interface MessageAware {

    /**
     * Sets messages.
     *
     * @param messages messages
     */
    void setMessages(Messages messages);
}
"
api/src/main/java/org/apache/struts2/Messages.java,false,"package org.apache.struts2;

import java.util.List;
import java.util.Set;
import java.util.Map;

/**
 * Collection of messages. Supports nesting messages by field name.
 *
 * <p>Uses keys when adding instead of actual messages to decouple code from messages.
 *
 * @author crazybob@google.com (Bob Lee)
 */
public interface Messages {

    // TODO: Use Object[] for args instead of String[].

    /**
     * Message severity.
     */
    public enum Severity {

        /**
         * Informational messages.
         */
        INFO,

        /**
         * Warning messages.
         */
        WARN,

        /**
         * Error messages.
         */
        ERROR,
    }

    /**
     * Gets nested messages for the given field.
     *
     * <p>Supports dot notation to represent nesting. For example:
     *
     * <pre>
     * messages.forField("foo").forField("bar") == messages.forField("foo.bar")
     * </pre>
     *
     * @param fieldName name of the field
     * @return nested {@code Messages} for given field name
     */
    Messages forField(String fieldName);

    /**
     * Gets map of field name to messages for that field.
     *
     * @return map of field name to {@code Messages}
     */
    Map<String, Messages> forFields();

    /**
     * Adds informational message.
     *
     * @param key message key
     * @see Severity.INFO
     */
    void addInformation(String key);

    /**
     * Adds informational message.
     *
     * @param key message key
     * @param arguments message arguments
     * @see Severity.INFO
     */
    void addInformation(String key, String... arguments);

    /**
     * Adds warning message.
     *
     * @param key message key
     * @see Severity.WARN
     */
    void addWarning(String key);

    /**
     * Adds warning message.
     *
     * @param key message key
     * @param arguments message arguments
     * @see Severity.WARN
     */
    void addWarning(String key, String... arguments);

    /**
     * Adds error message.
     *
     * @param key message key
     * @see Severity.ERROR
     */
    void addError(String key);

    /**
     * Adds error message.
     *
     * @param key message key
     * @param arguments message arguments
     * @see Severity.ERROR
     */
    void addError(String key, String... arguments);

    /**
     * Adds message.
     *
     * @param severity message severity
     * @param key message key
     */
    void add(Severity severity, String key);

    /**
     * Adds request-scoped message.
     *
     * @param severity message severity
     * @param key message key
     * @param arguments message arguments
     */
    void add(Severity severity, String key, String... arguments);

    /**
     * Gets set of severities for which this {@code Messages} instance has messages. Not recursive.
     *
     * @return unmodifiable set of {@link Severity} sorted from least to most severe
     */
    Set<Severity> getSeverities();

    /**
     * Gets message strings for the given severity. Not recursive.
     *
     * @param severity message severity
     * @return unmodifiable list of messages
     */
    List<String> forSeverity(Severity severity);

    /**
     * Gets error message strings for this {@code Messages} instance. Not recursive.
     *
     * @return unmodifiable list of messages
     */
    List<String> getErrors();

    /**
     * Gets error message strings for this {@code Messages} instance. Not recursive.
     *
     * @return unmodifiable list of messages
     */
    List<String> getWarnings();

    /**
     * Gets informational message strings for this {@code Messages} instance. Not recursive.
     *
     * @return unmodifiable list of messages
     */
    List<String> getInformation();

    /**
     * Returns true if this or a nested {@code Messages} instance has error messages.
     *
     * @see Severity.ERROR
     */
    boolean hasErrors();

    /**
     * Returns true if this or a nested {@code Messages} instance has warning messages.
     *
     * @see Severity.WARN
     */
    boolean hasWarnings();

    /**
     * Returns true if this or a nested {@code Messages} instance has informational messages.
     *
     * @see Severity.INFO
     */
    boolean hasInformation();

    /**
     * Returns true if this and all nested {@code Messages} instances have no messages.
     */
    boolean isEmpty();

    /**
     * Returns true if this and all nested {@code Messages} instances have no messages for the given severity.
     *
     * @param severity message severity
     */
    boolean isEmpty(Severity severity);
}"
api/src/main/java/org/apache/struts2/ResultNames.java,false,"package org.apache.struts2;

/**
 * Commonly used result names returned by action methods.
 *
 * @author crazybob@google.com (Bob Lee)
 */
public final class ResultNames {

    private ResultNames() {}

    /**
     * The action executed successfully.
     */
    public static final String SUCCESS = "success";

    /**
     * The action requires more input, i.e.&nbsp;a validation error occurred.
     */
    public static final String INPUT = "input";

    /**
     * The action requires the user to log in before executing.
     */
    public static final String LOGIN = "login";

    /**
     * The action execution failed irrecoverably.
     */
    public static final String ERROR = "error";

    /**
     * The action executed successfully, but do not execute a result.
     */
    public static final String NONE = "none";
}
"
api/src/main/java/org/apache/struts2/Validatable.java,false,"package org.apache.struts2;

import org.apache.struts2.MessageAware;

/**
 * Implemented by actions which wish to execute some validation logic before their action method. Useful for
 * cross-field validations.
 *
 * @author crazybob@google.com (Bob Lee)
 */
public interface Validatable extends MessageAware {

    /**
     * Validates input. Executes before action method.
     */
    public void validate();
}
"
api/src/main/java/org/apache/struts2/servlet/ParameterAware.java,false,"package org.apache.struts2.servlet;

import java.util.Map;

/**
 * Implemented by actions which need direct access to the request parameters.
 *
 * @author crazybob@google.com (Bob Lee)
 */
public interface ParameterAware {

    /**
     * Sets parameters.
     *
     * @param parameters map of parameter name to parameter values
     */
    void setParameters(Map<String, String[]> parameters);
}
"
api/src/main/java/org/apache/struts2/servlet/ServletRequestAware.java,false,"package org.apache.struts2.servlet;

import javax.servlet.http.HttpServletRequest;

/**
 * Implemented by actions which need direct access to the servlet request.
 *
 * @author crazybob@google.com (Bob Lee)
 */
public interface ServletRequestAware {

    /**
     * Sets the servlet request.
     *
     * @param request servlet request.
     */
    void setServletRequest(HttpServletRequest request);
}
"
api/src/main/java/org/apache/struts2/servlet/ServletResponseAware.java,false,"package org.apache.struts2.servlet;

import javax.servlet.http.HttpServletResponse;

/**
 * Implemented by actions which need direct access to the servlet response.
 *
 * @author crazybob@google.com (Bob Lee)
 */
public interface ServletResponseAware {

    /**
     * Sets the servlet response.
     *
     * @param response servlet response
     */
    void setServletResponse(HttpServletResponse response);
}
"
api/src/main/java/org/apache/struts2/spi/ActionContext.java,false,"package org.apache.struts2.spi;

import java.lang.reflect.Method;

/**
 * Context of an action execution.
 *
 * @author crazybob@google.com (Bob Lee)
 */
public interface ActionContext {

    /**
     * Gets action instance.
     */
    Object getAction();

    /**
     * Gets action method.
     */
    Method getMethod();

    /**
     * Gets action name.
     */
    String getActionName();

    /**
     * Gets the path for the action's namespace.
     */
    String getNamespacePath();

    /**
     * Gets the {@link Result} instance for the action.
     *
     * @return {@link Result} instance or {@code null} if we don't have a result yet.
     */
    Result getResult();

    /**
     * Adds a result interceptor for the action. Enables executing code before and after a result, executing an
     * alternate result, etc.
     */
    void addResultInterceptor(Result interceptor);

    /**
     * Gets context of action which chained to us.
     *
     * @return context of previous action or {@code null} if this is the first action in the chain
     */
    ActionContext getPrevious();

    /**
     * Gets context of action which this action chained to.
     *
     * @return context of next action or {@code null} if we haven't chained to another action yet or this is the last
     *  action in the chain.
     */
    ActionContext getNext();
}
"
api/src/main/java/org/apache/struts2/spi/Interceptor.java,false,"package org.apache.struts2.spi;

/**
 * Intercepts an action request.
 *
 * @author crazybob@google.com (Bob Lee)
 */
public interface Interceptor {

    /**
     * Intercepts an action request.
     *
     * @param requestContext current request context
     */
    String intercept(RequestContext requestContext) throws Exception;
}
"
api/src/main/java/org/apache/struts2/spi/RequestContext.java,false,"package org.apache.struts2.spi;

import org.apache.struts2.Messages;

import javax.servlet.ServletContext;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.List;
import java.util.Locale;
import java.util.Map;

/**
 * Request context. A single request may span multiple actions with action chaining.
 *
 * @author crazybob@google.com (Bob Lee)
 */
public interface RequestContext {

    /**
     * Gets context of the currently executing action.
     *
     * @return current action context
     */
    ActionContext getActionContext();

    /**
     * Convenience method.&nbsp;Equivalent to {@code getActionContext().getAction()}.
     *
     * @return currently executing action
     */
    Object getAction();

    /**
     * Gets map of request parameters.
     */
    Map<String, String[]> getParameterMap();

    /**
     * Gets map of request attributes.
     */
    Map<String, Object> getAttributeMap();

    /**
     * Gets map of session attributes.
     */
    Map<String, Object> getSessionMap();

    /**
     * Gets map of application (servlet context) attributes.
     */
    Map<String, Object> getApplicationMap();

    /**
     * Finds cookies with the given name,
     */
    List<Cookie> findCookiesForName(String name);

    /**
     * Gets locale.
     */
    Locale getLocale();

    /**
     * Sets locale. Stores the locale in the session for future requests.
     */
    void setLocale(Locale locale);

    /**
     * Gets messages.
     */
    Messages getMessages();

    /**
     * Gets the servlet request.
     */
    HttpServletRequest getServletRequest();

    /**
     * Gets the servlet response.
     */
    HttpServletResponse getServletResponse();

    /**
     * Gets the servlet context.
     */
    ServletContext getServletContext();

    /**
     * Gets the value stack.
     */
    ValueStack getValueStack();

    /**
     * Invokes the next interceptor or the action method if no more interceptors remain.
     *
     * @return result name
     * @throws IllegalStateException if already invoked or called from the action
     */
    String proceed() throws Exception;
}
"
api/src/main/java/org/apache/struts2/spi/RequestContextAware.java,false,"package org.apache.struts2.spi;

import org.apache.struts2.spi.RequestContext;

/**
 * Implemented by actions that need access to the current {@link org.apache.struts2.spi.RequestContext}. Use
 * judiciously.
 *
 * @author crazybob@google.com (Bob Lee)
 */
public interface RequestContextAware {

    /**
     * Sets {@link org.apache.struts2.spi.RequestContext}.
     *
     * @param requestContext
     */
    void setRequestContext(RequestContext requestContext);
}
"
api/src/main/java/org/apache/struts2/spi/Result.java,false,"package org.apache.struts2.spi;

import org.apache.struts2.spi.RequestContext;

/**
 * The result of an action request. Struts creates a new {@code Result} instance for each request.
 *
 * @author crazybob@google.com (Bob Lee)
 */
public interface Result {

    /**
     * Executes result.
     *
     * @param requestContext
     */
    void execute(RequestContext requestContext) throws Exception;
}
"
api/src/main/java/org/apache/struts2/spi/ValueStack.java,false,"package org.apache.struts2.spi;

/**
 * A central fixture of the Struts framework, the {@code ValueStack} is a stack which contains the actions
 * which have executed in addition to other objects. Users can get and set values on the stack using expressions. The
 * {@code ValueStack} will search down the stack starting with the most recent objects until it finds an object to
 * which the expression can apply.
 *
 * @author crazybob@google.com (Bob Lee)
 */
public interface ValueStack extends Iterable<Object> {

    /**
     * Gets the top, most recent object from the stack without changing the stack.
     *
     * @return the top object
     */
    Object peek();

    /**
     * Removes the top, most recent object from the stack.
     *
     * @return the top object
     */
    Object pop();

    /**
     * Pushes an object onto the stack.
     *
     * @param o
     */
    void push(Object o);

    /**
     * Creates a shallow copy of this stack.
     *
     * @return a new stack which contains the same objects as this one
     */
    ValueStack clone();

    /**
     * Queries the stack. Starts with the top, most recent object. If the expression can apply to the object, this
     * method returns the result of evaluating the expression. If the expression does not apply, this method moves
     * down the stack to the next object and repeats. Returns {@code null} if the expression doesn't apply to any
     * objects.
     *
     * @param expression
     * @return the evaluation of the expression against the first applicable object in the stack
     */
    Object get(String expression);

    /**
     * Queries the stack and converts the result to the specified type. Starts with the top, most recent object. If
     * the expression can apply to the object, this method returns the result of evaluating the expression converted
     * to the specified type. If the expression does not apply, this method moves down the stack to the next object
     * and repeats. Returns {@code null} if the expression doesn't apply to any objects.
     *
     * @param expression
     * @param asType the type to convert the result to
     * @return the evaluation of the expression against the first applicable object in the stack converted to the
     *  specified type
     */
    <T> T get(String expression, Class<T> asType);

    /**
     * Queries the stack and converts the result to a {@code String}. Starts with the top, most recent object. If the
     * expression can apply to the object, this method returns the result of evaluating the expression converted to a
     * {@code String}. If the expression does not apply, this method moves down the stack to the next object and
     * repeats. Returns {@code null} if the expression doesn't apply to any objects.
     *
     * @param expression
     * @return the evaluation of the expression against the first applicable object in the stack converted to a {@code
     *  String}
     */
    String getString(String expression);

    /**
     * Sets a value on an object from the stack. This method starts at the top, most recent object. If the expression
     * applies to that object, this methods sets the given value on that object using the expression and converting
     * the type as necessary. If the expression does not apply, this method moves to the next object and repeats.
     *
     * @param expression
     * @param value
     */
    void set(String expression, Object value);

    /**
     * Returns the number of object on the stack.
     *
     * @return size of stack
     */
    int size();
}
"
apps/blank/src/main/java/example/ExampleSupport.java,false,"package example;

import com.opensymphony.xwork2.ActionSupport;

/**
 * Base Action class for the Tutorial package.
 */
public class ExampleSupport extends ActionSupport {
}
"
apps/blank/src/main/java/example/HelloWorld.java,false,"package example;

/**
 * <code>Set welcome message.</code>
 */
public class HelloWorld extends ExampleSupport {

    public String execute() throws Exception {
        setMessage(getText(MESSAGE));
        return SUCCESS;
    }

    /**
     * Provide default valuie for Message property.
     */
    public static final String MESSAGE = "HelloWorld.message";

    /**
     * Field for Message property.
     */
    private String message;

    /**
     * Return Message property.
     *
     * @return Message property
     */
    public String getMessage() {
        return message;
    }

    /**
     * Set Message property.
     *
     * @param message Text to display on HelloWorld page.
     */
    public void setMessage(String message) {
        this.message = message;
    }
}
"
apps/blank/src/main/java/example/Login.java,false,"package example;

public class Login extends ExampleSupport {

    public String execute() throws Exception {

        if (isInvalid(getUsername())) return INPUT;

        if (isInvalid(getPassword())) return INPUT;

        return SUCCESS;
    }

    private boolean isInvalid(String value) {
        return (value == null || value.length() == 0);
    }

    private String username;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    private String password;

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

}"
apps/mailreader/src/main/java/mailreader2/ApplicationListener.java,false,"/*
 * Copyright 1999-2002,2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * $Id$
 */

package mailreader2;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts.apps.mailreader.dao.impl.memory.MemoryUserDatabase;

import javax.servlet.ServletContext;
import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import java.io.*;

/**
 * <p><code>ServletContextListener</code> that initializes and finalizes the
 * persistent storage of User and Subscription information for the Struts
 * Demonstration Application, using an in-memory database backed by an XML
 * file.</p>
 * <p/>
 * <p><strong>IMPLEMENTATION WARNING</strong> - If this web application is run
 * from a WAR file, or in another environment where reading and writing of the
 * web application resource is impossible, the initial contents will be copied
 * to a file in the web application temporary directory provided by the
 * container.  This is for demonstration purposes only - you should
 * <strong>NOT</strong> assume that files written here will survive a restart
 * of your servlet container.</p>
 * <p/>
 * <p>This class was borrowed from the Shale Mailreader. Changes were:</p>
 * <p/>
 * <ul>
 * <p/>
 * <li>Path to database.xml (under classes here). </li>
 * <p/>
 * <li>Class to store protocol list (an array here). </li>
 * <p/>
 * </ul>
 * <p>
 * DEVELOPMENT NOTE - Another approach would be to instantiate the database via Spring.
 * </p>
 */

public final class ApplicationListener implements ServletContextListener {

    // ------------------------------------------------------ Manifest Constants


    /**
     * <p>Appication scope attribute key under which the in-memory version of
     * our database is stored.</p>
     */
    public static final String DATABASE_KEY = "database";


    /**
     * <p>Application scope attribute key under which the valid selection
     * items for the protocol property is stored.</p>
     */
    public static final String PROTOCOLS_KEY = "protocols";

    // ------------------------------------------------------ Instance Variables


    /**
     * <p>The <code>ServletContext</code> for this web application.</p>
     */
    private ServletContext context = null;


    /**
     * The {@link MemoryUserDatabase} object we construct and make available.
     */
    private MemoryUserDatabase database = null;


    /**
     * <p>Logging output for this plug in instance.</p>
     */
    private Log log = LogFactory.getLog(this.getClass());

    // ------------------------------------------------------------- Properties


    /**
     * <p>The web application resource path of our persistent database storage
     * file.</p>
     */
    private String pathname = "/WEB-INF/classes/database.xml";

    /**
     * <p>Return the application resource path to the database.</p>
     *
     * @return application resource path path to the database
     */
    public String getPathname() {
        return (this.pathname);
    }

    /**
     * <p>Set the application resource path to the database.</p>
     *
     * @param pathname to the database
     */
    public void setPathname(String pathname) {
        this.pathname = pathname;
    }

    // ------------------------------------------ ServletContextListener Methods


    /**
     * <p>Gracefully shut down this database, releasing any resources that
     * were allocated at initialization.</p>
     *
     * @param event ServletContextEvent to process
     */
    public void contextDestroyed(ServletContextEvent event) {

        log.info("Finalizing memory database plug in");

        if (database != null) {
            try {
                database.close();
            } catch (Exception e) {
                log.error("Closing memory database", e);
            }
        }

        context.removeAttribute(DATABASE_KEY);
        context.removeAttribute(PROTOCOLS_KEY);
        database = null;
        context = null;

    }


    /**
     * <p>Initialize and load our initial database from persistent
     * storage.</p>
     *
     * @param event The context initialization event
     */
    public void contextInitialized(ServletContextEvent event) {

        log.info("Initializing memory database plug in from '" +
                pathname + "'");

        // Remember our associated ServletContext
        this.context = event.getServletContext();

        // Construct a new database and make it available
        database = new MemoryUserDatabase();
        try {
            String path = calculatePath();
            if (log.isDebugEnabled()) {
                log.debug(" Loading database from '" + path + "'");
            }
            database.setPathname(path);
            database.open();
        } catch (Exception e) {
            log.error("Opening memory database", e);
            throw new IllegalStateException("Cannot load database from '" +
                    pathname + "': " + e);
        }
        context.setAttribute(DATABASE_KEY, database);

    }

    // -------------------------------------------------------- Private Methods


    /**
     * <p>Calculate and return an absolute pathname to the XML file to contain
     * our persistent storage information.</p>
     *
     * @throws Exception if an input/output error occurs
     */
    private String calculatePath() throws Exception {

        // Can we access the database via file I/O?
        String path = context.getRealPath(pathname);
        if (path != null) {
            return (path);
        }

        // Does a copy of this file already exist in our temporary directory
        File dir = (File)
                context.getAttribute("javax.servlet.context.tempdir");
        File file = new File(dir, "struts-example-database.xml");
        if (file.exists()) {
            return (file.getAbsolutePath());
        }

        // Copy the static resource to a temporary file and return its path
        InputStream is =
                context.getResourceAsStream(pathname);
        BufferedInputStream bis = new BufferedInputStream(is, 1024);
        FileOutputStream os =
                new FileOutputStream(file);
        BufferedOutputStream bos = new BufferedOutputStream(os, 1024);
        byte buffer[] = new byte[1024];
        while (true) {
            int n = bis.read(buffer);
            if (n <= 0) {
                break;
            }
            bos.write(buffer, 0, n);
        }
        bos.close();
        bis.close();
        return (file.getAbsolutePath());

    }


}
"
apps/mailreader/src/main/java/mailreader2/AuthenticationInterceptor.java,false,"package mailreader2;

import com.opensymphony.xwork2.interceptor.Interceptor;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.Action;
import java.util.Map;
import org.apache.struts.apps.mailreader.dao.User;

public class AuthenticationInterceptor implements Interceptor  {

    public void destroy () {}

    public void init() {}

    public String intercept(ActionInvocation actionInvocation) throws Exception {

        Map session = actionInvocation.getInvocationContext().getSession();

        User user = (User) session.get(Constants.USER_KEY);

        boolean isAuthenticated = (null!=user) && (null!=user.getDatabase());

        if (!isAuthenticated) {
            return Action.LOGIN;            
        }
        else {
            return actionInvocation.invoke();
        }

    }
}
"
apps/mailreader/src/main/java/mailreader2/Constants.java,false,"/*
 * $Id$
 *
 * Copyright 1999-2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package mailreader2;

/**
 * <p> Manifest constants for the MailReader application. </p>
 */
public final class Constants {

    // --- Tokens ----

    /**
     * <p> The token representing a "cancel" request. </p>
     */
    public static final String CANCEL = "cancel";

    /**
     * <p> The token representing a "create" task. </p>
     */
    public static final String CREATE = "Create";

    /**
     * <p> The application scope attribute under which our user database is
     * stored. </p>
     */
    public static final String DATABASE_KEY = "database";

    /**
     * <p> The token representing a "edit" task. </p>
     */
    public static final String DELETE = "Delete";

    /**
     * <p> The token representing a "edit" task. </p>
     */
    public static final String EDIT = "Edit";

    /**
     * <p> The package name for this application. </p>
     */
    public static final String PACKAGE = "org.apache.struts.apps.mailreader";

    /**
     * <p> The session scope attribute under which the Subscription object
     * currently selected by our logged-in User is stored. </p>
     */
    public static final String SUBSCRIPTION_KEY = "subscription";

    /**
     * <p> The session scope attribute under which the User object for the
     * currently logged in user is stored. </p>
     */
    public static final String USER_KEY = "user";

    /**
     * <p>The token representing the "Host" property.
     */
    public static final String HOST = "host";

    
    // ---- Error Messages ----

    /**
     * <p>
     * A static message in case message resource is not loaded.
     * </p>
     */
    public static final String ERROR_MESSAGES_NOT_LOADED =
            "ERROR:  Message resources not loaded -- check servlet container logs for error messages.";

    /**
     * <p>
     * A static message in case database resource is not loaded.
     * <p>
     */
    public static final String ERROR_DATABASE_NOT_LOADED =
            "ERROR:  User database not loaded -- check servlet container logs for error messages.";

    /**
     * <p>
     * A standard key from the message resources file, to test if it is available.
     * <p>
     */
    public static final String ERROR_DATABASE_MISSING = "error.database.missing";

    /**
     * <P>
     * A "magic" username to trigger an ExpiredPasswordException for testing.
     *</p>
     */
    public static final String EXPIRED_PASSWORD_EXCEPTION = "ExpiredPasswordException";

    /**
     * <p>
     * Name of field to associate with authentification errors.
     * <p>
     */
    public static final String PASSWORD_MISMATCH_FIELD = "password";

    // ---- Log Messages ----

    /**
     * <p> Message to log if saving a user fails. </p>
     */
    public static final String LOG_DATABASE_SAVE_ERROR =
            " Unexpected error when saving User: ";


}
"
apps/mailreader/src/main/java/mailreader2/Login.java,false,"/*
 * $Id$
 *
 * Copyright 2000-2004 Apache Software Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package mailreader2;

import org.apache.struts.apps.mailreader.dao.User;
import org.apache.struts.apps.mailreader.dao.ExpiredPasswordException;

/**
 * <p> Validate a user login. </p>
 */
public final class Login extends MailreaderSupport {

    public String execute() throws ExpiredPasswordException  {

        User user = findUser(getUsername(), getPassword());

        if (user != null) {
            setUser(user);
        }

        if (hasErrors()) {
            return INPUT;
        }

       return SUCCESS;

    }

}
"
apps/mailreader/src/main/java/mailreader2/Logout.java,false,"/*
 * $Id$
 *
 * Copyright 2000-2004 Apache Software Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package mailreader2;

/**
 * <p> Log user out of the current session. </p>
 */
public class Logout extends MailreaderSupport {

    public String execute() {

        setUser(null);

        return SUCCESS;
    }
}
"
apps/mailreader/src/main/java/mailreader2/MailreaderSupport.java,false,"/*
 * $Id$
 *
 * Copyright 1999-2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package mailreader2;

import org.apache.struts2.interceptor.ApplicationAware;
import org.apache.struts2.interceptor.SessionAware;
import com.opensymphony.xwork2.ActionSupport;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts.apps.mailreader.dao.ExpiredPasswordException;
import org.apache.struts.apps.mailreader.dao.Subscription;
import org.apache.struts.apps.mailreader.dao.User;
import org.apache.struts.apps.mailreader.dao.UserDatabase;
import org.apache.struts.apps.mailreader.dao.impl.memory.MemorySubscription;
import org.apache.struts.apps.mailreader.dao.impl.memory.MemoryUser;
import org.springframework.beans.BeanUtils;

import java.util.Map;

/**
 * <p> Base Action for MailreaderSupport application. </p>
 * <p/>
 * <p> Note that this class does NOT implement model driven because of the way
 * the pre-existing model is designed. The MailReader DAO includes immutable
 * fields that can only be set on construction, and some objects do not have a
 * default construction. One approach would be to mirror all the DAO
 * properties on the Actions. As an alternative, this implementations uses the
 * DAO properties where possible, and uses local Action properties only as
 * needed. To create new objects, a blank temporary object is constructed, and
 * the page uses a mix of local Action properties and DAO properties. When the
 * new object is to be saved, the local Action properties are used to create
 * the object using the DAO factory methods, the input values are copied from
 * the temporary object, and the new object is saved. It's kludge, but it
 * avoids creating unnecessary local properties. Pick your poison.</p>
 */
public class MailreaderSupport extends ActionSupport
        implements SessionAware, ApplicationAware {

    /**
     * Return CANCEL so apropriate result can be selected.
     * @return "cancel" so apropriate result can be selected.
     */
    public String cancel() {
        return Constants.CANCEL;
    }


    // ---- ApplicationAware ----

    /**
     * <p>Field to store application context or its proxy.</p>
     * <p/>
     * <p>The application context lasts for the life of the application. A
     * reference to the database is stored in the application context at
     * startup.</p>
     */
    private Map application;

    /**
     * <p>Store a new application context.</p>
     *
     * @param value A Map representing application state
     */
    public void setApplication(Map value) {
        application = value;
    }

    /**
     * <p>Provide application context.</p>
     */
    public Map getApplication() {
        return application;
    }

    // ---- SessionAware ----

    /**
     * <p>Field to store session context, or its proxy.</p>
     */
    private Map session;

    /**
     * <p>Store a new session context.</p>
     *
     * @param value A Map representing session state
     */
    public void setSession(Map value) {
        session = value;
    }

    /**
     * <p>Provide session context.</p>
     *
     * @return session context
     */
    public Map getSession() {
        return session;
    }

    // ---- Task property (utilized by UI) ----

    /**
     * <p>Field to store workflow task.</p>
     * <p/>
     * <p>The Task is used to track the state of the CRUD workflows. It can be
     * set to Constant.CREATE, Constant.EDIT, or Constant.DELETE as
     * needed.</p>
     */
    private String task = null;


    /**
     * <p>Provide worklow task.</p>
     *
     * @return Returns the task.
     */
    public String getTask() {
        return task;
    }

    /**
     * <p>Store new workflow task.</p>
     *
     * @param value The task to set.
     */
    public void setTask(String value) {
        task =  value;
    }

    // ---- Token property (utilized by UI) ----

    /**
     * <p>Field to store double-submit guard.</p>
     */
    private String token = null;


    /**
     * <p>Provide Token.</p>
     *
     * @return Returns the token.
     */
    public String getToken() {
        return token;
    }

    /**
     * <p>Store new Token.</p>
     *
     * @param value The token to set.
     */
    public void setToken(String value) {
        token =  value;
    }


    // ---- Host property ----

    /**
     * <p>Field to store Subscription host.</p>
     * <p/>
     * <p> The host is an immutable property of the Subscrtion DAP object, so
     * we need to store it locally until we are ready to create the
     * Subscription. </p>
     */
    private String host;

    /**
     * <p>Provide tSubscription host.</p>
     *
     * @return host property
     */
    public String getHost() {
        return host;
    }

    /**
     * <p>Store new Subscription host.</p>
     *
     * @param value
     */
    public void setHost(String value) {
        host = value;
    }

    // ---- Password property ----

    /**
     * <p>Field to store User password property.</p>
     * <p/>
     * <p>The User DAO object password proerty is immutable, so we store it
     * locally until we are ready to create the object.</p>
     */
    private String password = null;


    /**
     * <p>Provide User password</p>
     *
     * @return Returns the password.
     */
    public String getPassword() {
        return password;
    }

    /**
     * <p>Store new User Password</p>
     *
     * @param value The password to set.
     */
    public void setPassword(String value) {
        password = value;
    }

    // ---- Password2 property (confirmation) ----

    /**
     * <p>Field to store the User password confirmation.</p>
     * <p/>
     * <p>When a User object is created, we ask the client to enter the
     * password twice, to help ensure the password is being typed
     * correctly.</p>
     */
    private String password2 = null;


    /**
     * <p>Provide the User password confirmation.</p>
     *
     * @return Returns the confirmationpassword.
     */
    public String getPassword2() {
        return password2;
    }

    /**
     * <p>Store a new User password confirmation.</p>
     *
     * @param value The confirmation password to set.
     */
    public void setPassword2(String value) {
        password2 = value;
    }

    // ---- Username property ----

    /**
     * <p>Field to store User username.</p>
     * <p/>
     * <p>The User DAO object password proerty is immutable, so we store it
     * locally until we are ready to create the object.</p>
     */
    private String username = null;


    /**
     * <p>Provide User username.</p>
     *
     * @return Returns the User username.
     */
    public String getUsername() {
        return username;
    }

    /**
     * <p>Store new User username</p>
     *
     * @param value The username to set.
     */
    public void setUsername(String value) {
        username = value;
    }

    // ---- Database property ----

    /**
     * <p>Provide reference to UserDatabase, or null if the database is not
     * available. </p>
     *
     * @return a reference to the UserDatabase or null if the database is not
     *         available
     */
    public UserDatabase getDatabase() {
        Object db = getApplication().get(Constants.DATABASE_KEY);
        if (db == null) {
            this.addActionError(getText("error.database.missing"));
        }
        return (UserDatabase) db;
    }

    /**
     * <p>Store a new reference to UserDatabase</p>
     *
     * @param database
     */
    public void setDatabase(UserDatabase database) {
        getApplication().put(Constants.DATABASE_KEY, database);
    }

    // ---- User property ----

    /**
     * <p>Provide reference to User object for authenticated user.</p>
     *
     * @return User object for authenticated user.
     */
    public User getUser() {
        return (User) getSession().get(Constants.USER_KEY);
    }

    /**
     * <p>Store new reference to User Object.</p>
     *
     * @param user User object for authenticated user
     */
    public void setUser(User user) {
        getSession().put(Constants.USER_KEY, user);
    }

    /**
     * <p>Obtain User object from database, or return null if the credentials
     * are not found or invalid.</p>
     *
     * @param username User username
     * @param password User password
     * @return User object or null if not found
     * @throws ExpiredPasswordException
     */
    public User findUser(String username, String password)
            throws ExpiredPasswordException {
        // FIXME: Stupid testing hack to compensate for inadequate DAO layer
        if (Constants.EXPIRED_PASSWORD_EXCEPTION.equals(username)) {
            throw new ExpiredPasswordException(Constants.EXPIRED_PASSWORD_EXCEPTION);
        }

        User user = getDatabase().findUser(username);
        if ((user != null) && !user.getPassword().equals(password)) {
            user = null;
        }
        if (user == null) {
            this.addFieldError(Constants.PASSWORD_MISMATCH_FIELD,
                    getText("error.password.mismatch"));
        }
        return user;
    }

    /**
     * <p><code>Log</code> instance for this application. </p>
     */
    protected Log log = LogFactory.getLog(Constants.PACKAGE);

    /**
     * <p> Persist the User object, including subscriptions, to the database.
     * </p>
     *
     * @throws java.lang.Exception on database error
     */
    public void saveUser() throws Exception {
        try {
            getDatabase().save();
        } catch (Exception e) {
            String message = Constants.LOG_DATABASE_SAVE_ERROR + getUser()
                    .getUsername();
            log.error(message, e);
            throw new Exception(message, e);
        }
    }

    public void createInputUser() {
        User user = new MemoryUser(null, null);
        setUser(user);
    }

    /**
     * <p> Verify input for creating a new user, create the user, and process
     * the login. </p>
     *
     * @return A new User and empty Errors if create succeeds, or null and
     *         Errors if create fails
     */
    public User createUser(String username, String password) {

        UserDatabase database = getDatabase();
        User user;

        try {
            user = database.findUser(username);
         }

        catch (ExpiredPasswordException e) {
            user = getUser(); // Just so that it is not null
        }

        if (user != null) {
            this.addFieldError("username", "error.username.unique");
            return null;
        }

        return database.createUser(username);
    }

    // Since user.username is immutable, we have to use some local properties

    /**
     * <p>Use the current User object to create a new User object, and make
     * the new User object the authenticated user.</p>
     * <p/>
     * <p>The "current" User object is usually a temporary object being used
     * to capture input.</p>
     *
     * @param _username User username
     * @param _password User password
     */
    public void copyUser(String _username, String _password) {
        User input = getUser();
        input.setPassword(_password);
        User user = createUser(_username, _password);
        if (null != user) {
            BeanUtils.copyProperties(input,user);
            setUser(user);
        }
    }

    // ---- Subscription property ----

    /**
     * <p>Obtain the cached Subscription object, if any. </p>
     *
     * @return Cached Subscription object or null
     */
    public Subscription getSubscription() {
        return (Subscription) getSession().get(Constants.SUBSCRIPTION_KEY);
    }

    /**
     * <p>Store new User Subscription.</p>
     *
     * @param subscription
     */
    public void setSubscription(Subscription subscription) {
        getSession().put(Constants.SUBSCRIPTION_KEY, subscription);
    }

    /**
     * <p> Obtain User Subscription object for the given host, or return null
     * if not found. </p>
     *
     * <p>It would be possible for this code to throw a NullPointerException,
     * but the ExceptionHandler in the xwork.xml will catch that for us.</p>
     *
     * @return The matching Subscription or null
     */
    public Subscription findSubscription(String host) {
        Subscription subscription;
        subscription = getUser().findSubscription(host);
        return subscription;
    }

    /**
     * <p>Obtain uSER Subscription for the local Host property.</p>
     * <p/>
     * <p>Usually, the host property will be set from the client request,
     * because it was embedded in a link to the Subcription action.
     *
     * @return Subscription or null if not found
     */
    public Subscription findSubscription() {
        return findSubscription(getHost());
    }

    /**
     * <p>Provide a "temporary" User Subscription object that can be used to
     * capture input values.</p>
     */
    public void createInputSubscription() {
        Subscription sub = new MemorySubscription(getUser(), null);
        setSubscription(sub);
        setHost(sub.getHost());
    }

    /**
     * <p>Provide new User Subscription object for the given host, or null if
     * the host is not unique.</p>
     *
     * @param host
     * @return New User Subscription object or null
     */
    public Subscription createSubscription(String host) {

        Subscription sub;

        sub = findSubscription(host);

        if (null != sub) {
            // FIXME - localization - "error.host.unique")
            addFieldError(Constants.HOST,"That hostname is already defined");
            return null;
        }

        return getUser().createSubscription(host);
    }

    /**
     * <p>Create a new Subscription from the current Subscription object,
     * making the new Subscription the current Subscription. </p>
     * <p/>
     * <p>Usually, the "current" Subscription is a temporary object being used
     * to capture input values.</p>
     *
     * @param host
     */
    public void copySubscription(String host) {
        Subscription input = getSubscription();
        Subscription sub = createSubscription(host);
        if (null != sub) {
            BeanUtils.copyProperties(input, sub);
            setSubscription(sub);
            setHost(sub.getHost());
        }
    }

    /**
     * <p>Delete the current Subscription object from the database.</p>
     */
    public void removeSubscription()  {
        getUser().removeSubscription(getSubscription());
        getSession().remove(Constants.SUBSCRIPTION_KEY);
    }

    /**
     * <p>Provide MailServer Host for current User Subscription.</p>
     *
     * @return MailServer Host for current User Subscription
     */
    public String getSubscriptionHost() {
        Subscription sub = getSubscription();
        if (null == sub) {
            return null;
        }
        return sub.getHost();
    }

}
"
apps/mailreader/src/main/java/mailreader2/Registration.java,false,"package mailreader2;

import org.apache.struts.apps.mailreader.dao.User;


/**
 * <p>Insert or update a User object to the persistent store. </p>
 */
public class Registration extends MailreaderSupport {

    /**
     * <p>Double check that there is not a valid User login. </p>
     *
     * @return True if there is not a valid User login
     */
    private boolean isCreating() {
        User user = getUser();
        return (null == user) || (null == user.getDatabase());
    }

    /**
     * <p> Retrieve User object to edit or null if User does not exist. </p>
     *
     * @return The "Success" result for this mapping
     * @throws Exception on any error
     */
    public String input() throws Exception {

        if (isCreating()) {
            createInputUser();
            setTask(Constants.CREATE);
        } else {
            setTask(Constants.EDIT);
            setUsername(getUser().getUsername());
            setPassword(getUser().getPassword());
            setPassword2(getUser().getPassword());
        }

        return INPUT;
    }

    /**
     * <p>Insert or update a Registration.</p>
     *
     * @return The "outcome" result code
     * @throws Exception on any error
     */
    public String save() throws Exception {
        return execute();
    }

    /**
     * <p> Insert or update a User object to the persistent store. </p>
     * <p/>
     * <p> If a User is not logged in, then a new User is created and
     * automatically logged in. Otherwise, the existing User is updated. </p>
     *
     * @return The "outcome" result code
     * @throws Exception on any error
     */
    public String execute()
            throws Exception {

        boolean creating = Constants.CREATE.equals(getTask());
        creating = creating && isCreating(); // trust but verify

        if (creating) {

            User user = findUser(getUsername(), getPassword());
            boolean haveUser = (user != null);

            if (haveUser) {
                addActionError(getText("error.username.unique"));
                return INPUT;
            }

            copyUser(getUsername(), getPassword());

        } else {

            // FIXME: Any way to call the RegisrationSave validators from here?
            String newPassword = getPassword();
            if (newPassword != null) {
                String confirmPassword = getPassword2();
                boolean matches = ((null != confirmPassword)
                        && (confirmPassword.equals(newPassword)));
                if (matches) {
                    getUser().setPassword(newPassword);
                } else {
                    addActionError(getText("error.password.match"));
                    return INPUT;
                }
            }
        }

        saveUser();

        return SUCCESS;
    }

}
"
apps/mailreader/src/main/java/mailreader2/Subscription.java,false,"package mailreader2;

import com.opensymphony.xwork2.Preparable;

import java.util.LinkedHashMap;
import java.util.Map;

/**
 * <p> Provide an Edit method for retrieving an existing subscription, and a
 * Save method for updating or inserting a subscription. </p>
 */
public class Subscription extends MailreaderSupport
        implements Preparable {

    /**
     * <p>Field to store list of MailServer types</p>
     */
    private Map types = null;

    /**
     * <p>Provide the list of MailServer types.</p>
     *
     * @return List of MailServer types
     */
    public Map getTypes() {
        return types;
    }

    /**
     * <p>Setup the MailerServer types and set the local Host property from
     * the User Subscription (if any). </p>
     */
    public void prepare() {

        Map m = new LinkedHashMap();
        m.put("imap", "IMAP Protocol");
        m.put("pop3", "POP3 Protocol");
        types = m;

        setHost(getSubscriptionHost());
    }

    /**
     * <p>Setup a temporary User Subscription object to capture input
     * values.</p>
     *
     * @return INPUT
     */
    public String input() {
        createInputSubscription();
        setTask(Constants.CREATE);
        return INPUT;
    }

    /**
     * <p>Load User Subscription for the local Host property.</p>
     * <p/>
     * <p>Usually, the Host is being set from the request by a link to an Edit
     * or Delete task.</p>
     *
     * @return INPUT or Error, if Subscription is not found
     */
    public String find() {

        org.apache.struts.apps.mailreader.dao.Subscription
                sub = findSubscription();

        if (sub == null) {
            return ERROR;
        }

        setSubscription(sub);

        return INPUT;

    }

    /**
     * <p>Prepare to present a confirmation page before removing
     * Subscription.</p>
     *
     * @return INPUT or Error, if Subscription is not found
     */
    public String delete() {

        setTask(Constants.DELETE);
        return find();
    }

    /**
     * <p>Prepare to edit User Subscription.</p>
     *
     * @return INPUT or Error, if Subscription is not found
     */
    public String edit() {

        setTask(Constants.EDIT);
        return find();
    }

    /**
     * <p> Examine the Task property and DELETE, CREATE, or save the User
     * Subscription, as appropriate. </p>
     *
     * @return SUCCESS
     * @throws Exception on a database error
     */
    public String save() throws Exception {

        if (Constants.DELETE.equals(getTask())) {
            removeSubscription();
        }

        if (Constants.CREATE.equals(getTask())) {
            copySubscription(getHost());
        }

        if (hasErrors()) return INPUT;
        
        saveUser();
        return SUCCESS;
    }

}
"
apps/mailreader/src/main/java/mailreader2/Welcome.java,false,"package mailreader2;

/**
 * Verify that essential resources are available.
 */
public class Welcome extends MailreaderSupport {

    public String execute() {

        // Confirm message resources loaded
        String message = getText(Constants.ERROR_DATABASE_MISSING);
        if (Constants.ERROR_DATABASE_MISSING.equals(message)) {
            addActionError(Constants.ERROR_MESSAGES_NOT_LOADED);
        }

        // Confirm database loaded
        if (null==getDatabase()) {
             addActionError(Constants.ERROR_DATABASE_NOT_LOADED);
        }

        if (hasErrors()) {
            return ERROR;
        }
        else {
            return SUCCESS;
        }
    }
}
"
apps/portlet/src/main/java/org/apache/struts2/portlet/example/ExampleAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.portlet.example;

import java.util.Map;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionSupport;

public class ExampleAction extends ActionSupport {
    
    private String name = "PortletWork Example";
    
    public String getName() {
        return name;
    }
    
    public Map getRenderParameters() {
        return ActionContext.getContext().getParameters();
    }
}
"
apps/portlet/src/main/java/org/apache/struts2/portlet/example/FormExample.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.portlet.example;

import com.opensymphony.xwork2.ActionSupport;

/**
 */
public class FormExample extends ActionSupport {
    
    String firstName = null;
    String lastName = null;
    public String execute() throws Exception {
        // TODO Auto-generated method stub
        return super.execute();
    }
    public String getFirstName() {
        return firstName;
    }
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }
    public String getLastName() {
        return lastName;
    }
    public void setLastName(String lastName) {
        this.lastName = lastName;
    }
}
"
apps/portlet/src/main/java/org/apache/struts2/portlet/example/FormExampleWithValidation.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.portlet.example;

import com.opensymphony.xwork2.ActionSupport;

/**
 */
public class FormExampleWithValidation extends ActionSupport {
    private String firstName = null;
    private String lastName = null;
    
    public String input() {
        return SUCCESS;
    }
    
    public String getFirstName() {
        return firstName;
    }
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }
    public String getLastName() {
        return lastName;
    }
    public void setLastName(String lastName) {
        this.lastName = lastName;
    }
}
"
apps/portlet/src/main/java/org/apache/struts2/portlet/example/FormResultAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.portlet.example;

import java.util.Collection;
import java.util.Map;

import javax.portlet.RenderRequest;

import org.apache.struts2.portlet.context.PortletActionContext;
import com.opensymphony.xwork2.ActionSupport;

/**
 */
public class FormResultAction extends ActionSupport {

    private String result = null;
    
    public String getResult() {
        return result;
    }
    public void setResult(String result) {
        this.result = result;
    }
    
    public Collection getRenderParams() {
        RenderRequest req = PortletActionContext.getRenderRequest();
        Map params = req.getParameterMap();
        return params.entrySet();
    }
}
"
apps/portlet/src/main/java/org/apache/struts2/portlet/example/FormTestAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.portlet.example;

import com.opensymphony.xwork2.ActionSupport;

/**
 */
public class FormTestAction extends ActionSupport {

    private String name = null;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}
"
apps/portlet/src/main/java/org/apache/struts2/portlet/example/SavePrefsAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.portlet.example;

import javax.portlet.ActionRequest;
import javax.portlet.PortletPreferences;

import org.apache.struts2.portlet.context.PortletActionContext;
import com.opensymphony.xwork2.ActionSupport;

/**
 */
public class SavePrefsAction extends ActionSupport {
    private String preferenceOne = null;
    private String preferenceTwo = null;
    public String getPreferenceOne() {
        return preferenceOne;
    }
    public void setPreferenceOne(String preferenceOne) {
        this.preferenceOne = preferenceOne;
    }
    public String getPreferenceTwo() {
        return preferenceTwo;
    }
    public void setPreferenceTwo(String preferenceTwo) {
        this.preferenceTwo = preferenceTwo;
    }
    
    public String execute() throws Exception {
        ActionRequest req = PortletActionContext.getActionRequest();
        PortletPreferences prefs = req.getPreferences();
        prefs.setValue("preferenceOne", preferenceOne);
        prefs.setValue("preferenceTwo", preferenceTwo);
        prefs.store();
        return SUCCESS;
    }
    
    public String showForm() throws Exception {
        PortletPreferences prefs = PortletActionContext.getRequest().getPreferences();
        preferenceOne = prefs.getValue("preferenceOne", "not set");
        preferenceTwo = prefs.getValue("preferenceTwo", "not set");
        return SUCCESS;
    }
}
"
apps/portlet/src/main/java/org/apache/struts2/portlet/example/spring/SpringAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.portlet.example.spring;

import java.util.List;

import org.apache.commons.lang.StringUtils;

import com.opensymphony.xwork2.ActionSupport;

/**
 */
public class SpringAction extends ActionSupport {
    
    private ThingManager thingManager = null;
    private String thing = null;
    
    public void setThingManager(ThingManager thingManager) {
        this.thingManager = thingManager;
    }
    
    public List getThings() {
        return thingManager.getThings();
    }
    
    public String getThing() {
        return thing;
    }
    
    public void setThing(String thing) {
        this.thing = thing;
    }
    
    public String execute() {
        if(StringUtils.isNotEmpty(thing)) {
            thingManager.addThing(thing);
        }
        return SUCCESS;
    }
}
"
apps/portlet/src/main/java/org/apache/struts2/portlet/example/spring/ThingManager.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.portlet.example.spring;

import java.util.ArrayList;
import java.util.List;

/**
 */
public class ThingManager {
    private List things = new ArrayList();
    
    public void addThing(String thing) {
        things.add(thing);
    }
    
    public List getThings() {
        return things;
    }
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/DateAction.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase;

import com.opensymphony.xwork2.ActionSupport;

import java.text.DateFormat;
import java.util.Date;
import java.util.Calendar;
import java.util.GregorianCalendar;

/**
 * <code>DateAction</code>
 *
 */
public class DateAction extends ActionSupport {

    private static DateFormat DF = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM);

    private Date now;
    private Date past;
    private Date future;
    private Date after;
    private Date before;


    public String getDate() {
        return DF.format(new Date());
    }


    /**
     * @return Returns the future.
     */
    public Date getFuture() {
        return future;
    }

    /**
     * @return Returns the now.
     */
    public Date getNow() {
        return now;
    }

    /**
     * @return Returns the past.
     */
    public Date getPast() {
        return past;
    }

    /**
     *
     * @return Returns the before date.
     */
    public Date getBefore() {
        return before;
    }

    /**
     *
     * @return Returns the after date.
     */
    public Date getAfter() {
        return after;
    }

    /**
     * @see com.opensymphony.xwork2.ActionSupport#execute()
     */
    public String execute() throws Exception {
        Calendar cal = GregorianCalendar.getInstance();
        now = cal.getTime();
        cal.roll(Calendar.DATE, -1);
        cal.roll(Calendar.HOUR, -3);
        past = cal.getTime();
        cal.roll(Calendar.DATE, 2);
        future = cal.getTime();

        cal.roll(Calendar.YEAR, -1);
        before = cal.getTime();

        cal.roll(Calendar.YEAR, 2);
        after = cal.getTime();
        return SUCCESS;
    }

}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/DynamicTreeSelectAction.java,false,"package org.apache.struts2.showcase;

import org.apache.struts2.showcase.ajax.tree.Category;

import com.opensymphony.xwork2.ActionSupport;

//START SNIPPET: treeExampleDynamicJavaSelected

public class DynamicTreeSelectAction extends ActionSupport {

	private long nodeId;
	private Category currentCategory;
	
	
	public void setNodeId(long nodeId) {
		this.nodeId = nodeId;
	}
	public long getNodeId() {
		return nodeId;
	}
	
	
	public String execute() throws Exception {
		currentCategory = Category.getById(nodeId);
		return SUCCESS;
	}
	
	
	public String getNodeName() {
		return currentCategory.getName();
	}
}

//START SNIPPET: treeExampleDynamicJavaSelected

"
apps/showcase/src/main/java/org/apache/struts2/showcase/Guess.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase;

import com.opensymphony.xwork2.ActionSupport;
import com.opensymphony.xwork2.Action;
import com.opensymphony.xwork2.Preparable;
import com.uwyn.rife.continuations.ContinuableObject;

import java.util.Random;

// START SNIPPET: example
public class Guess extends ActionSupport implements Preparable, ContinuableObject {
    int guess;

    public void prepare() throws Exception {
        // We clear the error message state before the action.
        // That is because with continuations, the original (or cloned) action is being
        //  executed, which will still have the old errors and potentially cause problems,
        //  such as with the workflow interceptor
        clearErrorsAndMessages();
    }

    public String execute() throws Exception {
        int answer = new Random().nextInt(100) + 1;
        int tries = 5;

        while (answer != guess && tries > 0) {
            pause(Action.SUCCESS);

            if (guess > answer) {
                addFieldError("guess", "Too high!");
            } else if (guess < answer) {
                addFieldError("guess", "Too low!");
            }

            tries--;
        }

        if (answer == guess) {
            addActionMessage("You got it!");
        } else {
            addActionMessage("You ran out of tries, the answer was " + answer);
        }

        return Action.SUCCESS;
    }

    public void setGuess(int guess) {
        this.guess = guess;
    }
}
// END SNIPPET: example
"
apps/showcase/src/main/java/org/apache/struts2/showcase/LotsOfOptiontransferselectAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import com.opensymphony.xwork2.ActionSupport;

/**
 */
public class LotsOfOptiontransferselectAction extends ActionSupport {
	
	private List _favouriteCartoonCharactersKeys;
	private List _notFavouriteCartoonCharactersKeys;
	
	private List _favouriteCarsKeys;
	private List _notFavouriteCarsKeys;
	
	private List _favouriteMotorcyclesKeys;
	private List _notFavouriteMotorcyclesKeys;
	
	private List _favouriteCountriesKeys;
	private List _notFavouriteCountriesKeys;
	
	private List _prioritisedFavouriteCartoonCharacters;
	private List _prioritisedFavouriteCars;
	private List _prioritisedFavouriteCountries;
	
	
	
	// Cartoon Characters
	public Map getDefaultFavouriteCartoonCharacters() {
		Map m = new LinkedHashMap();
		m.put("heMan", "He-Man");
		m.put("popeye", "Popeye");
		m.put("mockeyMouse", "Mickey Mouse");
		return m;
	}
	
	public Map getDefaultNotFavouriteCartoonCharacters() {
		Map m = new LinkedHashMap();
		m.put("donaldDuck", "Donald Duck");
		m.put("atomicAnt", "Atomic Ant");
		m.put("pinkPainter", "Pink Painter");
		return m;
	}
	
	public List getFavouriteCartoonCharacters() {
		return _favouriteCartoonCharactersKeys;
	}
	
	public void setFavouriteCartoonCharacters(List favouriteCartoonCharacters) {
		_favouriteCartoonCharactersKeys = favouriteCartoonCharacters;
	}
	
	public List getNotFavouriteCartoonCharacters() {
		return _notFavouriteCartoonCharactersKeys;
	}
	
	public void setNotFavouriteCartoonCharacters(List notFavouriteCartoonCharacters) {
		_notFavouriteCartoonCharactersKeys = notFavouriteCartoonCharacters;
	}
	
	
	
	
	
	// Cars
	public Map getDefaultFavouriteCars() {
		Map m = new LinkedHashMap();
		m.put("alfaRomeo", "Alfa Romeo");
		m.put("Toyota", "Toyota");
		m.put("Mitsubitshi", "Mitsubitshi");
		return m;
	}
	
	public Map getDefaultNotFavouriteCars() {
		Map m = new LinkedHashMap();
		m.put("ford", "Ford");
		m.put("landRover", "Land Rover");
		m.put("mercedes", "Mercedes");
		return m;
	}
	
	public List getFavouriteCars() {
		return _favouriteCarsKeys;
	}
	
	public void setFavouriteCars(List favouriteCars) {
		_favouriteCarsKeys = favouriteCars;
	}
	
	public List getNotFavouriteCars() {
		return _notFavouriteCarsKeys;
	}
	
	public void setNotFavouriteCars(List notFavouriteCars) {
		_notFavouriteCarsKeys = notFavouriteCars;
	}
	
	
	
	// Motorcycles
	public Map getDefaultFavouriteMotorcycles() {
		Map m = new LinkedHashMap();
		m.put("honda", "Honda");
		m.put("yamaha", "Yamaha");
		m.put("Aprillia", "Aprillia");
		return m;
	}
	
	public Map getDefaultNotFavouriteMotorcycles() {
		Map m = new LinkedHashMap();
		m.put("cagiva", "Cagiva");
		m.put("harleyDavidson", "Harley Davidson");
		m.put("suzuki", "Suzuki");
		return m;
	}
	
	public List getFavouriteMotorcycles() {
		return _favouriteMotorcyclesKeys;
	}
	
	public void setFavouriteMotorcycles(List favouriteMotorcycles) {
		_favouriteMotorcyclesKeys = favouriteMotorcycles;
	}
	
	public List getNotFavouriteMotorcycles() {
		return _notFavouriteMotorcyclesKeys;
	}
	
	public void setNotFavouriteMotorcycles(List notFavouriteMotorcycles) {
		_notFavouriteMotorcyclesKeys = notFavouriteMotorcycles;
	}
	
	
	
	// Countries
	public Map getDefaultFavouriteCountries() {
		Map m = new LinkedHashMap();
		m.put("england", "England");
		m.put("america", "America");
		m.put("brazil", "Brazil");
		return m;
	}
	
	public Map getDefaultNotFavouriteCountries() {
		Map m = new LinkedHashMap();
		m.put("germany", "Germany");
		m.put("china", "China");
		m.put("russia", "Russia");
		return m;
	}
	
	public List getFavouriteCountries() {
		return _favouriteCountriesKeys;
	}
	
	public void setFavouriteCountries(List favouriteCountries) {
		_favouriteCountriesKeys = favouriteCountries;
	}
	
	public List getNotFavouriteCountries() {
		return _notFavouriteCountriesKeys;
	}
	
	public void setNotFavouriteCountries(List notFavouriteCountries) {
		_notFavouriteCountriesKeys = notFavouriteCountries;
	}
	
	
	public List getPrioritisedFavouriteCartoonCharacters() {
		return _prioritisedFavouriteCartoonCharacters;
	}
	public void setPrioritisedFavouriteCartoonCharacters(List prioritisedFavouriteCartoonCharacters) {
		_prioritisedFavouriteCartoonCharacters = prioritisedFavouriteCartoonCharacters;
	}
	
	public List getPrioritisedFavouriteCars() {
		return _prioritisedFavouriteCars;
	}
	public void setPrioritisedFavouriteCars(List prioritisedFavouriteCars) {
		_prioritisedFavouriteCars = prioritisedFavouriteCars;
	}
	
	
	public List getPrioritisedFavouriteCountries() {
		return _prioritisedFavouriteCountries;
	}
	public void setPrioritisedFavouriteCountries(List prioritisedFavouriteCountries) {
		_prioritisedFavouriteCountries = prioritisedFavouriteCountries;
	}
	
	
	
	
	// actions
	
	public String input() throws Exception {
		return SUCCESS;
	}
	
	public String submit() throws Exception {
		return SUCCESS;
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/LotsOfRichtexteditorAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase;

import com.opensymphony.xwork2.ActionSupport;

/**
 * 
 */
public class LotsOfRichtexteditorAction extends ActionSupport {

	public String description1;
	public String description2 = "This is Description 2";
	public String description3;
	public String description4 = "This is Description 4";
	
	public String getDescription1() {
		return this.description1;
	}
	public void setDescription1(String description1) {
		this.description1 = description1;
	}
	
	
	public String getDescription2() {
		return this.description2;
	}
	public void setDescription2(String description2) {
		this.description2 = description2;
	}
	
	
	public String getDescription3() {
		return this.description3;
	}
	public void setDescription3(String description3) {
		this.description3 = description3;
	}
	
	
	
	
	public String getDescription4() {
		return this.description4;
	}
	public void setDescription4(String description4) {
		this.description4 = description4;
	}
	
	
	
	
	public String input() throws Exception {
		return SUCCESS;
	}
	
	public String submit() throws Exception {
		return SUCCESS;
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/ShowDynamicTreeAction.java,false,"package org.apache.struts2.showcase;

import org.apache.struts2.showcase.ajax.tree.Category;

import com.opensymphony.xwork2.ActionSupport;

// START SNIPPET: treeExampleDynamicJavaShow 

public class ShowDynamicTreeAction extends ActionSupport {
	
	public Category getTreeRootNode() {
		return Category.getById(1);
	}
}

// END SNIPPET: treeExampleDynamicJavaShow

"
apps/showcase/src/main/java/org/apache/struts2/showcase/UITagExample.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase;

import org.apache.struts2.ServletActionContext;
import com.opensymphony.xwork2.ActionSupport;
import com.opensymphony.xwork2.Validateable;
import com.opensymphony.xwork2.util.OgnlValueStack;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.io.File;

/**
 */
public class UITagExample extends ActionSupport implements Validateable {
	
	private static final long serialVersionUID = -94044809860988047L;
	
	
	String name;
    Date birthday;
    String bio;
    String favoriteColor;
    List friends;
    boolean legalAge;
    String state;
    String region;
    File picture;
    String pictureContentType;
    String pictureFileName;
    String favouriteLanguage;
    String favouriteVehicalType = "MotorcycleKey";
    String favouriteVehicalSpecific = "YamahaKey";
    
    List leftSideCartoonCharacters;
    List rightSideCartoonCharacters;
    
    List favouriteLanguages = new ArrayList();
    List vehicalTypeList = new ArrayList();
    Map vehicalSpecificMap = new HashMap();
    
    String thoughts;
    
    public UITagExample() {
    	favouriteLanguages.add(new Language("EnglishKey", "English Language"));
    	favouriteLanguages.add(new Language("FrenchKey", "French Language"));
    	favouriteLanguages.add(new Language("SpanishKey", "Spanish Language"));
    	
    	VehicalType car = new VehicalType("CarKey", "Car");
    	VehicalType motorcycle = new VehicalType("MotorcycleKey", "Motorcycle");
    	vehicalTypeList.add(car);
    	vehicalTypeList.add(motorcycle);
    	
    	List cars = new ArrayList();
    	cars.add(new VehicalSpecific("MercedesKey", "Mercedes"));
    	cars.add(new VehicalSpecific("HondaKey", "Honda"));
    	cars.add(new VehicalSpecific("FordKey", "Ford"));
    	
    	List motorcycles = new ArrayList();
    	motorcycles.add(new VehicalSpecific("SuzukiKey", "Suzuki"));
    	motorcycles.add(new VehicalSpecific("YamahaKey", "Yamaha"));
    	
    	vehicalSpecificMap.put(car, cars);
    	vehicalSpecificMap.put(motorcycle, motorcycles);
    }
    
    
    
    public List getLeftSideCartoonCharacters() {
    	return leftSideCartoonCharacters;
    }
    public void setLeftSideCartoonCharacters(List leftSideCartoonCharacters) {
    	this.leftSideCartoonCharacters = leftSideCartoonCharacters;
    }
    
    
    public List getRightSideCartoonCharacters() {
    	return rightSideCartoonCharacters;
    }
    public void setRightSideCartoonCharacters(List rightSideCartoonCharacters) {
    	this.rightSideCartoonCharacters = rightSideCartoonCharacters;
    }
    
    
    public String getFavouriteVehicalType() {
    	return favouriteVehicalType;
    }
    
    public void setFavouriteVehicalType(String favouriteVehicalType) {
    	this.favouriteVehicalType = favouriteVehicalType;
    }
    
    public String getFavouriteVehicalSpecific() {
    	return favouriteVehicalSpecific;
    }
    
    public void setFavouriteVehicalSpecific(String favouriteVehicalSpecific) {
    	this.favouriteVehicalSpecific = favouriteVehicalSpecific;
    }
    
    public List getVehicalTypeList() {
    	return vehicalTypeList;
    }
    
    public List getVehicalSpecificList() {
    	OgnlValueStack stack = ServletActionContext.getValueStack(ServletActionContext.getRequest());
    	Object vehicalType = stack.findValue("top");
    	if (vehicalType != null && vehicalType instanceof VehicalType) {
    		List l = (List) vehicalSpecificMap.get(vehicalType);
    		return l;
    	}
    	return Collections.EMPTY_LIST;
    }
    
    public List getFavouriteLanguages() {
    	return favouriteLanguages;
    }

    public String execute() throws Exception {
        return SUCCESS;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public String getBio() {
        return bio;
    }

    public void setBio(String bio) {
        this.bio = bio;
    }

    public String getFavoriteColor() {
        return favoriteColor;
    }

    public void setFavoriteColor(String favoriteColor) {
        this.favoriteColor = favoriteColor;
    }

    public List getFriends() {
        return friends;
    }

    public void setFriends(List friends) {
        this.friends = friends;
    }

    public boolean isLegalAge() {
        return legalAge;
    }

    public void setLegalAge(boolean legalAge) {
        this.legalAge = legalAge;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public String getRegion() {
        return region;
    }

    public void setRegion(String region) {
        this.region = region;
    }

    public void setPicture(File picture) {
        this.picture = picture;
    }

    public void setPictureContentType(String pictureContentType) {
        this.pictureContentType = pictureContentType;
    }

    public void setPictureFileName(String pictureFileName) {
        this.pictureFileName = pictureFileName;
    }
    
    public void setFavouriteLanguage(String favouriteLanguage) {
    	this.favouriteLanguage = favouriteLanguage;
    }
    
    public String getFavouriteLanguage() {
    	return favouriteLanguage;
    }
    
    
    public void setThoughts(String thoughts) {
    	this.thoughts = thoughts;
    }
    
    public String getThoughts() {
    	return this.thoughts;
    }
    
    
    
    public String doSubmit() {
    	return SUCCESS;
    }
    
    
    
    // === inner class 
    public static class Language {
    	String description;
    	String key;
    	
    	public Language(String key, String description) {
    		this.key = key;
    		this.description = description;
    	}
    	
    	public String getKey() { 
    		return key; 
    	}
    	public String getDescription() { 
    		return description; 
    	}
    	
    }
    
    
    public static class VehicalType {
    	String key;
    	String description;
    	public VehicalType(String key, String description) {
    		this.key = key;
    		this.description = description;
    	}
    	
    	public String getKey() { return this.key; }
    	public String getDescription() { return this.description; }
    	
    	public boolean equals(Object obj) {
    		if (! (obj instanceof VehicalType)) { 
    			return false;
    		}
    		else {
    			return key.equals(((VehicalType)obj).getKey());
    		}
    	}
    	
    	public int hashCode() {
    		return key.hashCode();
    	}
    }
    
    
    public static class VehicalSpecific {
    	String key; 
    	String description;
    	public VehicalSpecific(String key, String description) {
    		this.key = key;
    		this.description = description;
    	}
    	
    	public String getKey() { return this.key; }
    	public String getDescription() { return this.description; }
    	
    	public boolean equals(Object obj) {
    		if (! (obj instanceof VehicalSpecific)) {
    			return false;
    		}
    		else {
    			return key.equals(((VehicalSpecific)obj).getKey());
    		}
    	}
    	
    	public int hashCode() {
    		return key.hashCode();
    	}
    }
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/action/AbstractCRUDAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.action;

import org.apache.log4j.Logger;
import com.opensymphony.xwork2.ActionSupport;
import org.apache.struts2.showcase.dao.Dao;
import org.apache.struts2.showcase.model.IdEntity;

import java.util.Collection;
import java.io.Serializable;

/**
 * AbstractCRUDAction.
 *
 */

public abstract class AbstractCRUDAction extends ActionSupport {

    private static final Logger log = Logger.getLogger(AbstractCRUDAction.class);

    private Collection availableItems;
    private String[] toDelete;

    protected abstract Dao getDao();


    public Collection getAvailableItems() {
        return availableItems;
    }

    public String[] getToDelete() {
        return toDelete;
    }

    public void setToDelete(String[] toDelete) {
        this.toDelete = toDelete;
    }

    public String list() throws Exception {
        this.availableItems = getDao().findAll();
        if (log.isDebugEnabled()) {
            log.debug("AbstractCRUDAction - [list]: " + (availableItems !=null?""+availableItems.size():"no") + " items found");
        }
        return execute();
    }

    public String delete() throws Exception {
        if (toDelete != null) {
            int count=0;
            for (int i = 0, j=toDelete.length; i < j; i++) {
                count = count + getDao().delete(toDelete[i]);
            }
            if (log.isDebugEnabled()) {
                log.debug("AbstractCRUDAction - [delete]: " + count + " items deleted.");
            }
        }
        return SUCCESS;
    }

    /**
     * Utility method for fetching already persistent object from storage for usage in params-prepare-params cycle.
     *
     * @param tryId     The id to try to get persistent object for
     * @param tryObject The object, induced by first params invocation, possibly containing id to try to get persistent
     *                  object for
     * @return The persistent object, if found. <tt>null</tt> otherwise.
     */
    protected IdEntity fetch(Serializable tryId, IdEntity tryObject) {
        IdEntity result = null;
        if (tryId != null) {
            result = getDao().get(tryId);
        } else if (tryObject != null) {
            result = getDao().get(tryObject.getId());
        }
        return result;
    }
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/action/EmployeeAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.action;

import com.opensymphony.xwork2.Preparable;
import org.apache.log4j.Logger;
import org.apache.struts2.showcase.application.TestDataProvider;
import org.apache.struts2.showcase.dao.Dao;
import org.apache.struts2.showcase.dao.EmployeeDao;
import org.apache.struts2.showcase.model.Employee;
import org.apache.struts2.showcase.model.Skill;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

/**
 * JsfEmployeeAction.
 */

public class EmployeeAction extends AbstractCRUDAction implements Preparable {

    private static final long serialVersionUID = 7047317819789938957L;

    private static final Logger log = Logger.getLogger(EmployeeAction.class);

    private Long empId;
    protected EmployeeDao employeeDao;
    private Employee currentEmployee;
    private List selectedSkills;

    public Long getEmpId() {
        return empId;
    }

    public void setEmpId(Long empId) {
        this.empId = empId;
    }

    public Employee getCurrentEmployee() {
        return currentEmployee;
    }

    public void setCurrentEmployee(Employee currentEmployee) {
        this.currentEmployee = currentEmployee;
    }

    public String[] getAvailablePositions() {
        return TestDataProvider.POSITIONS;
    }

    public List getAvailableLevels() {
        return Arrays.asList(TestDataProvider.LEVELS);
    }

    public List getSelectedSkills() {
        return selectedSkills;
    }

    public void setSelectedSkills(List selectedSkills) {
        this.selectedSkills = selectedSkills;
    }

    protected Dao getDao() {
        return employeeDao;
    }

    public void setEmployeeDao(EmployeeDao employeeDao) {
        if (log.isDebugEnabled()) {
            log.debug("JsfEmployeeAction - [setEmployeeDao]: employeeDao injected.");
        }
        this.employeeDao = employeeDao;
    }

    /**
     * This method is called to allow the action to prepare itself.
     *
     * @throws Exception thrown if a system level exception occurs.
     */
    public void prepare() throws Exception {
        Employee preFetched = (Employee) fetch(getEmpId(), getCurrentEmployee());
        if (preFetched != null) {
            setCurrentEmployee(preFetched);
        }
    }

    public String execute() throws Exception {
        if (getCurrentEmployee() != null && getCurrentEmployee().getOtherSkills() != null) {
            setSelectedSkills(new ArrayList());
            Iterator it = getCurrentEmployee().getOtherSkills().iterator();
            while (it.hasNext()) {
                getSelectedSkills().add(((Skill) it.next()).getName());
            }
        }
        return super.execute();
    }

    public String save() throws Exception {
        if (getCurrentEmployee() != null) {
            setEmpId((Long) employeeDao.merge(getCurrentEmployee()));
            employeeDao.setSkills(getEmpId(), getSelectedSkills());
        }
        return SUCCESS;
    }

}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/action/SkillAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.action;

import org.apache.struts2.showcase.dao.Dao;
import org.apache.struts2.showcase.dao.SkillDao;
import org.apache.struts2.showcase.model.Skill;
import com.opensymphony.xwork2.Preparable;
import org.apache.log4j.Logger;

/**
 * SkillAction.
 *
 */

public class SkillAction extends AbstractCRUDAction implements Preparable {

    private static final Logger log = Logger.getLogger(SkillAction.class);

    private String skillName;
    protected SkillDao skillDao;
    private Skill currentSkill;

    public String getSkillName() {
        return skillName;
    }

    public void setSkillName(String skillName) {
        this.skillName = skillName;
    }

    protected Dao getDao() {
        return skillDao;
    }

    public void setSkillDao(SkillDao skillDao) {
        if (log.isDebugEnabled()) {
            log.debug("SkillAction - [setSkillDao]: skillDao injected.");
        }
        this.skillDao = skillDao;
    }

    public Skill getCurrentSkill() {
        return currentSkill;
    }

    public void setCurrentSkill(Skill currentSkill) {
        this.currentSkill = currentSkill;
    }

    /**
     * This method is called to allow the action to prepare itself.
     *
     * @throws Exception thrown if a system level exception occurs.
     */
    public void prepare() throws Exception {
        Skill preFetched = (Skill) fetch(getSkillName(), getCurrentSkill());
        if (preFetched != null) {
            setCurrentSkill(preFetched);
        }
    }

    public String save() throws Exception {
        if (getCurrentSkill() != null) {
            setSkillName((String) skillDao.merge(getCurrentSkill()));
        }
        return SUCCESS;
    }

}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/actionchaining/ActionChain1.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.actionchaining;

import com.opensymphony.xwork2.ActionSupport;

/**
 * 
 */
public class ActionChain1 extends ActionSupport {

	private static final long serialVersionUID = -6811701750042275153L;
	
	private String actionChain1Property1 = "Property Set In Action Chain 1";

	public String getActionChain1Property1() { 
		return actionChain1Property1;
	}
	public void setActionChain1Property1(String actionChain1Property1) {
		this.actionChain1Property1 = actionChain1Property1;
	}
	
	
	public String input() throws Exception {
		return SUCCESS;
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/actionchaining/ActionChain2.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.actionchaining;

import com.opensymphony.xwork2.ActionSupport;

/**
 * 
 */
public class ActionChain2 extends ActionSupport {

	private static final long serialVersionUID = 3951745956044674809L;
	
	private String actionChain1Property1;
	private String actionChain2Property1 = "Property Set in Action Chain 2";
	
	
	public String getActionChain1Property1() { 
		return actionChain1Property1;
	}
	public void setActionChain1Property1(String actionChain1Property1) {
		this.actionChain1Property1 = actionChain1Property1;
	}
	
	
	
	public String getActionChain2Property1() { 
		return actionChain2Property1;
	}
	public void setActionChain2Property1(String actionChain2Property1) {
		this.actionChain2Property1 = actionChain2Property1;
	}
	
	
	
	
	public String execute() throws Exception {
		return SUCCESS;
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/actionchaining/ActionChain3.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.actionchaining;

import com.opensymphony.xwork2.ActionSupport;

/**
 * 
 */
public class ActionChain3 extends ActionSupport {

	private static final long serialVersionUID = -1456568865075250621L;
	
	private String actionChain1Property1;
	private String actionChain2Property1;
	private String actionChain3Property1 = "Property set in Action Chain 3";
	
	
	public String getActionChain1Property1() { 
		return actionChain1Property1;
	}
	public void setActionChain1Property1(String actionChain1Property1) {
		this.actionChain1Property1 = actionChain1Property1;
	}
	
	
	
	public String getActionChain2Property1() { 
		return actionChain2Property1;
	}
	public void setActionChain2Property1(String actionChain2Property1) {
		this.actionChain2Property1 = actionChain2Property1;
	}
	
	
	
	public String getActionChain3Property1() {
		return actionChain3Property1;
	}
	public void setActionChain3Property1(String actionChain3Property1) {
		this.actionChain3Property1 = actionChain3Property1;
	}
	
	
	
	
	public String execute() throws Exception {
		return SUCCESS;
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/ajax/AjaxTestAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.ajax;

import com.opensymphony.xwork2.Action;


/**
 */
public class AjaxTestAction implements Action {

    private static int counter = 0;
    private String data;

    public long getServerTime() {
        return System.currentTimeMillis();
    }

    public int getCount() {
        return ++counter;
    }

    public String getData() {
        return data;
    }

    public void setData(String data) {
        this.data = data;
    }

    public String execute() throws Exception {
        return SUCCESS;
    }
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/ajax/Example4ShowPanelAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.ajax;

import java.text.SimpleDateFormat;
import java.util.Date;

import com.opensymphony.xwork2.ActionSupport;

/**
 * @version $Date$ $Id$
 */
public class Example4ShowPanelAction extends ActionSupport {

	private String name;
	private String gender;
	
	private static final long serialVersionUID = 7751976335066456596L;

	public String panel1() throws Exception {
		return SUCCESS;
	}
	
	public String panel2() throws Exception {
		return SUCCESS;
	}
	
	public String panel3() throws Exception {
		return SUCCESS;
	}

	public String getGender() {
		return gender;
	}

	public void setGender(String gender) {
		this.gender = gender;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
	
	public String getTodayDate() {
		SimpleDateFormat sdf = new SimpleDateFormat("dd-MMMM-yyyy");
		return sdf.format(new Date());
	}
	
	public String getTodayTime() {
		SimpleDateFormat sdf = new SimpleDateFormat("kk:mm:ss");
		return sdf.format(new Date());
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/ajax/tree/Category.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.ajax.tree;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;

/**
 */
public class Category {
    private static Map<Long, Category> catMap = new HashMap<Long, Category>();

    static {
        new Category(1, "Root",
                new Category(2, "Java",
                        new Category(3, "Web Frameworks",
                                new Category(4, "Struts"),
                                new Category(7, "Stripes"),
                                new Category(8, "Rife")),
                        new Category(9, "Persistence",
                                new Category(10, "iBatis"),
                                new Category(11, "Hibernate"),
                                new Category(12, "JDO"),
                                new Category(13, "JDBC"))),
                new Category(14, "JavaScript",
                        new Category(15, "Dojo"),
                        new Category(16, "Prototype"),
                        new Category(17, "Scriptaculous"),
                        new Category(18, "OpenRico"),
                        new Category(19, "DWR")));
    }

    public static Category getById(long id) {
        return catMap.get(id);
    }

    private long id;
    private String name;
    private List<Category> children;
    private boolean toggle;

    public Category(long id, String name, Category... children) {
        this.id = id;
        this.name = name;
        this.children = new ArrayList<Category>();
        for (Category child : children) {
            this.children.add(child);
        }

        catMap.put(id, this);
    }

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public List<Category> getChildren() {
        return children;
    }

    public void setChildren(List<Category> children) {
        this.children = children;
    }

    public void toggle() {
        toggle = !toggle;
    }

    public boolean isToggle() {
        return toggle;
    }
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/ajax/tree/GetCategory.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.ajax.tree;

import com.opensymphony.xwork2.ActionSupport;

/**
 */
public class GetCategory extends ActionSupport {
    private long catId;
    private Category category;

    public String execute() throws Exception {
        if (catId < 1) {
            // force the root
            catId = 1;
        }

        category = Category.getById(catId);

        return SUCCESS;
    }

    public void setCatId(long catId) {
        this.catId = catId;
    }

    public Category getCategory() {
        return category;
    }
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/ajax/tree/Toggle.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.ajax.tree;

import com.opensymphony.xwork2.ActionSupport;

/**
 */
public class Toggle extends GetCategory {
    public String execute() throws Exception {
        super.execute();

        getCategory().toggle();

        return SUCCESS;
    }
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/application/MemoryStorage.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.application;

import org.apache.struts2.showcase.exception.CreateException;
import org.apache.struts2.showcase.exception.DuplicateKeyException;
import org.apache.struts2.showcase.exception.StorageException;
import org.apache.struts2.showcase.exception.UpdateException;
import org.apache.struts2.showcase.model.IdEntity;
import org.apache.struts2.showcase.application.Storage;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

/**
 * MemoryStorage.
 * Very simple in-memory persistence emulation.
 *
 */

public class MemoryStorage implements Storage {

	private static final long serialVersionUID = 8611213748834904125L;


    private Map memory = new HashMap();

    private Map getEntityMap ( Class entityClass ) {
        if (entityClass != null) {
            Map tryMap = (Map) memory.get(entityClass);
            if (tryMap == null) {
                synchronized(memory) {
                    tryMap = new HashMap();
                    memory.put(entityClass, tryMap);
                }
            }
            return tryMap;
        } else {
            return null;
        }
    }

    private IdEntity intStore( Class entityClass, IdEntity object ) {
        getEntityMap(entityClass).put(object.getId(), object);
        return object;
    }

    public IdEntity get( Class entityClass, Serializable id ) {
        if (entityClass != null && id != null) {
            return (IdEntity) getEntityMap(entityClass).get(id);
        } else {
            return null;
        }
    }

    public Serializable create ( IdEntity object ) throws CreateException {
        if (object == null) {
            throw new CreateException("Either given class or object was null");
        }
        if (object.getId() == null) {
            throw new CreateException("Cannot store object with null id");
        }
        if (get(object.getClass(), object.getId()) != null) {
            throw new DuplicateKeyException("Object with this id already exists.");
        }
        return intStore(object.getClass(), object).getId();
    }

    public IdEntity update ( IdEntity object ) throws UpdateException {
        if (object == null) {
            throw new UpdateException("Cannot update null object.");
        }
        if ( get(object.getClass(), object.getId())==null ) {
            throw new UpdateException("Object to update not found.");
        }
        return intStore(object.getClass(), object);
    }

    public Serializable merge ( IdEntity object ) throws StorageException {
        if (object == null) {
            throw new StorageException("Cannot merge null object");
        }
        if (object.getId() == null || get(object.getClass(), object.getId())==null) {
            return create(object);
        } else {
            return update(object).getId();
        }
    }

    public int delete( Class entityClass, Serializable id ) throws CreateException {
        try {
            if (get(entityClass, id) != null) {
                getEntityMap(entityClass).remove(id);
                return 1;
            } else {
                return 0;
            }
        } catch (Exception e) {
            throw new CreateException(e);
        }
    }

    public int delete( IdEntity object ) throws CreateException {
        if (object == null) {
            throw new CreateException("Cannot delete null object");
        }
        return delete(object.getClass(), object.getId());
    }

    public Collection findAll( Class entityClass ) {
        if (entityClass != null) {
        	return getEntityMap(entityClass).values();
        } else {
            return new ArrayList();
        }
    }

    public void reset() {
        this.memory = new HashMap();
    }

}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/application/Storage.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.application;

import org.apache.struts2.showcase.model.IdEntity;
import org.apache.struts2.showcase.exception.CreateException;
import org.apache.struts2.showcase.exception.UpdateException;
import org.apache.struts2.showcase.exception.StorageException;

import java.io.Serializable;
import java.util.Collection;

/**
 * Storage. Interface.
 *
 */

public interface Storage extends Serializable {
    IdEntity get( Class entityClass, Serializable id );

    Serializable create ( IdEntity object ) throws CreateException;

    IdEntity update ( IdEntity object ) throws UpdateException;

    Serializable merge ( IdEntity object ) throws StorageException;

    int delete( Class entityClass, Serializable id ) throws CreateException;

    int delete( IdEntity object ) throws CreateException;

    Collection findAll( Class entityClass );
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/application/TestDataProvider.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.application;

import org.apache.struts2.showcase.dao.EmployeeDao;
import org.apache.struts2.showcase.dao.SkillDao;
import org.apache.struts2.showcase.exception.StorageException;
import org.apache.struts2.showcase.model.Employee;
import org.apache.struts2.showcase.model.Skill;
import org.apache.log4j.Logger;
import org.springframework.beans.factory.InitializingBean;

import java.io.Serializable;
import java.util.Date;
import java.util.Arrays;

/**
 * TestDataProvider.
 *
 */

public class TestDataProvider implements Serializable, InitializingBean {

	private static final long serialVersionUID = 1L;

	private static final Logger log = Logger.getLogger(TestDataProvider.class);

    public static final String[] POSITIONS = {
            "Developer",
            "System Architect",
            "Sales Manager",
            "CEO"
    };

    public static final String[] LEVELS = {
            "Junior",
            "Senior",
            "Master"
    };

    private static final Skill[] TEST_SKILLS = {
            new Skill("WW-SEN", "Struts Senior Developer"),
            new Skill("WW-JUN", "Struts Junior Developer"),
            new Skill("SPRING-DEV", "Spring Developer")
    };

    public static final Employee[] TEST_EMPLOYEES = {
            new Employee(new Long(1), "Alan", "Smithee", new Date(), new Float(2000f), true, POSITIONS[0],
                    TEST_SKILLS[0], null, "alan", LEVELS[0], "Nice guy"),
            new Employee(new Long(2), "Robert", "Robson", new Date(), new Float(10000f), false, POSITIONS[1],
                    TEST_SKILLS[1], Arrays.asList(TEST_SKILLS).subList(1,TEST_SKILLS.length), "rob", LEVELS[1], "Smart guy")
    };

    private SkillDao skillDao;
    private EmployeeDao employeeDao;

    public void setSkillDao(SkillDao skillDao) {
        this.skillDao = skillDao;
    }

    public void setEmployeeDao(EmployeeDao employeeDao) {
        this.employeeDao = employeeDao;
    }

    protected void addTestSkills() {
        try {
            for (int i = 0, j = TEST_SKILLS.length; i < j; i++) {
                skillDao.merge(TEST_SKILLS[i]);
            }
            if (log.isInfoEnabled()) {
                log.info("TestDataProvider - [addTestSkills]: Added test skill data.");
            }
        } catch (StorageException e) {
            log.error("TestDataProvider - [addTestSkills]: Exception catched: " + e.getMessage());
        }
    }

    protected void addTestEmployees() {
        try {
            for (int i = 0, j = TEST_EMPLOYEES.length; i < j; i++) {
                employeeDao.merge(TEST_EMPLOYEES[i]);
            }
            if (log.isInfoEnabled()) {
                log.info("TestDataProvider - [addTestEmployees]: Added test employee data.");
            }
        } catch (StorageException e) {
            log.error("TestDataProvider - [addTestEmployees]: Exception catched: " + e.getMessage());
        }
    }

    protected void addTestData() {
        addTestSkills();
        addTestEmployees();
    }

    public void afterPropertiesSet() throws Exception {
        addTestData();
    }

}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/chat/ChatAuthenticationInterceptor.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.chat;


import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.dispatcher.SessionMap;

import com.opensymphony.xwork2.Action;
import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.interceptor.Interceptor;

public class ChatAuthenticationInterceptor implements Interceptor {

	private static final long serialVersionUID = 1L;
	
	private static final Log _log = LogFactory.getLog(ChatAuthenticationInterceptor.class);
	
	public static final String USER_SESSION_KEY = "chatUserSessionKey";

	public void destroy() {
	}

	public void init() {
	}

	public String intercept(ActionInvocation invocation) throws Exception {
		
		_log.debug("Authenticating chat user");
		
		SessionMap session = (SessionMap) ActionContext.getContext().get(ActionContext.SESSION);
		User user = (User) session.get(USER_SESSION_KEY);
		
		if (user == null) {
			return Action.LOGIN;
		}
		return invocation.invoke();
	}

}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/chat/ChatException.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.chat;

public class ChatException extends RuntimeException {
	
	private static final long serialVersionUID = 1L;

	public enum ErrorType {
		ROOM_ALREADY_EXISTS, 
		USER_ALREADY_EXISTS,
		NO_SUCH_ROOM_EXISTS
	}
	
	public ChatException(String description, ErrorType type) {
		super(description);
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/chat/ChatInterceptor.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.chat;

import javax.servlet.http.HttpSession;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.opensymphony.xwork2.Action;
import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.interceptor.Interceptor;

/**
 * Authenticate showcase chat example, make sure everyone have a username.
 */
public class ChatInterceptor implements Interceptor {
	
	private static final Log _log = LogFactory.getLog(ChatInterceptor.class);

	private static final long serialVersionUID = 1L;
	
	public static final String CHAT_USER_SESSION_KEY = "ChatUserSessionKey";

	public void destroy() {
	}

	public void init() {
	}

	public String intercept(ActionInvocation invocation) throws Exception {
		HttpSession session = (HttpSession) ActionContext.getContext().get(ActionContext.SESSION);
		User chatUser = (User) session.getAttribute(CHAT_USER_SESSION_KEY);
		if (chatUser == null) {
			_log.debug("Chat user not logged in");
			return Action.LOGIN;
		}
		return invocation.invoke();
	}
}


"
apps/showcase/src/main/java/org/apache/struts2/showcase/chat/ChatLoginAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.chat;

import java.util.Map;

import org.apache.struts2.interceptor.SessionAware;

import com.opensymphony.xwork2.ActionSupport;

public class ChatLoginAction extends ActionSupport implements SessionAware {

	private static final long serialVersionUID = 1L;
	
	private ChatService chatService;
	private Map session;
	
	private String name;
	
	public ChatLoginAction(ChatService chatService) {
		this.chatService = chatService;
	}
	
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	
	
	public String execute() throws Exception {
		try {
			chatService.login(new User(name));
			session.put(ChatAuthenticationInterceptor.USER_SESSION_KEY, new User(name));
		}
		catch(ChatException e) {
			e.printStackTrace();
			addActionError(e.getMessage());
			return INPUT;
		}
		return SUCCESS;
	}

	
	// === SessionAware ===
	public void setSession(Map session) {
		this.session = session;
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/chat/ChatLogoutAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.chat;

import java.util.Map;

import org.apache.struts2.interceptor.SessionAware;

import com.opensymphony.xwork2.ActionSupport;

public class ChatLogoutAction extends ActionSupport implements SessionAware {

	private static final long serialVersionUID = 1L;

	private ChatService chatService;
	
	private Map session;
	
	
	public ChatLogoutAction(ChatService chatService) {
		this.chatService = chatService;
	}
	
	public String execute() throws Exception {
		
		User user = (User) session.get(ChatAuthenticationInterceptor.USER_SESSION_KEY);
		if (user != null) {
			chatService.logout(user.getName());
			session.remove(ChatAuthenticationInterceptor.USER_SESSION_KEY);
		}
		
		return SUCCESS;
	}

	
	// === SessionAware ===
	public void setSession(Map session) {	
		this.session = session;
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/chat/ChatMessage.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.chat;

import java.util.Date;

public class ChatMessage {
	
	private Date creationDate;
	private String message;
	private User creator;
	
	public ChatMessage(String message, User creator) {
		assert(message != null);
		assert(creator != null);
		
		this.creationDate = new Date(System.currentTimeMillis());
		this.message = message;
		this.creator = creator;
	}
	
	public Date getCreationDate() {
		return creationDate;
	}
	public User getCreator() {
		return creator;
	}
	public String getMessage() {
		return message;
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/chat/ChatService.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.chat;

import java.util.List;

public interface ChatService {
	List<User> getAvailableUsers();
	void login(User user);
	void logout(String name);
	
	List<Room> getAvailableRooms();
	void addRoom(Room room);
	void enterRoom(User user, String roomName);
	void exitRoom(String userName, String roomName);
	List<ChatMessage> getMessagesInRoom(String roomName);
	void sendMessageToRoom(String roomName, User user, String message);
	List<User> getUsersAvailableInRoom(String roomName);
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/chat/ChatServiceImpl.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.chat;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class ChatServiceImpl implements ChatService {
	
	private Map<String, User> availableUsers = new LinkedHashMap<String, User>();
	private Map<String, Room> availableRooms = new LinkedHashMap<String, Room>();
	
	
	public List<User> getAvailableUsers() {
		return new ArrayList<User>(availableUsers.values());
	}

	public List<Room> getAvailableRooms() {
		return new ArrayList<Room>(availableRooms.values());
	}

	public void addRoom(Room room) {
		if (availableRooms.containsKey(room.getName())) {
			throw new ChatException("room ["+room.getName()+"] is already available", ChatException.ErrorType.valueOf("ROOM_ALREADY_EXISTS"));
		}
		availableRooms.put(room.getName(), room);
	}
	
	public void login(User user) {
		assert(user != null);
		if (availableUsers.containsKey(user.getName())) {
			throw new ChatException("User ["+user.getName()+"] already exists", ChatException.ErrorType.valueOf("USER_ALREADY_EXISTS"));
		}
		availableUsers.put(user.getName(), user);
	}

	public void logout(String name) {
		assert(name != null);
		assert(name.trim().length() > 0);
		availableUsers.remove(name);
		for (Room room : availableRooms.values()) {
			if (room.hasMember(name)) {
				room.memberExit(name);
			}
		}
	}

	public void exitRoom(String userName, String roomName) {
		assert(roomName != null);
		assert(roomName.trim().length()> 0);
		
		if (availableRooms.containsKey(roomName)) {
			Room room = availableRooms.get(roomName);
			room.memberExit(userName);
		}
	}
	
	public void enterRoom(User user, String roomName) {
		assert(roomName != null);
		assert(roomName.trim().length() > 0);
		if (! availableRooms.containsKey(roomName)) {
			throw new ChatException("No such room exists ["+roomName+"]", ChatException.ErrorType.NO_SUCH_ROOM_EXISTS);
		}
		Room room = availableRooms.get(roomName);
		room.memberEnter(user);
	}

	public List<ChatMessage> getMessagesInRoom(String roomName) {
		assert(roomName != null);
		assert(roomName.trim().length() > 0);
		if (! availableRooms.containsKey(roomName)) {
			throw new ChatException("No such room exists ["+roomName+"]", ChatException.ErrorType.NO_SUCH_ROOM_EXISTS);
		}
		Room room = availableRooms.get(roomName);
		return room.getChatMessages();
	}

	public void sendMessageToRoom(String roomName, User user, String message) {
		assert(roomName != null);
		if (! availableRooms.containsKey(roomName)) {
			throw new ChatException("No such room exists ["+roomName+"]", ChatException.ErrorType.NO_SUCH_ROOM_EXISTS);
		}
		Room room = availableRooms.get(roomName);
		room.addMessage(new ChatMessage(message, user));
	}

	public List<User> getUsersAvailableInRoom(String roomName) {
		assert(roomName != null);
		if (! availableRooms.containsKey(roomName)) {
			throw new ChatException("No such room exists ["+roomName+"]", ChatException.ErrorType.NO_SUCH_ROOM_EXISTS);
		}
		Room room = availableRooms.get(roomName);
		return room.getMembers();
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/chat/ChatSessionListener.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.chat;

import javax.servlet.http.HttpSession;
import javax.servlet.http.HttpSessionEvent;
import javax.servlet.http.HttpSessionListener;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.context.support.WebApplicationContextUtils;

public class ChatSessionListener implements HttpSessionListener {

	private static final Log _log = LogFactory.getLog(ChatSessionListener.class);
	
	public void sessionCreated(HttpSessionEvent event) {
	}

	public void sessionDestroyed(HttpSessionEvent event) {
		HttpSession session = event.getSession();
		WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(session.getServletContext());
		if (context != null) {
			User user = (User) session.getAttribute(ChatInterceptor.CHAT_USER_SESSION_KEY);
			if (user != null) {
				ChatService service = (ChatService) context.getBean("chatService");
				service.logout(user.getName());
				
				_log.info("session expired, logged user ["+user.getName()+"] out");
			}
		}
	}

}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/chat/Constants.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.chat;

public class Constants {
	public static String UPDATE_FREQ = "30000";
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/chat/CrudRoomAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.chat;

import com.opensymphony.xwork2.ActionSupport;

public class CrudRoomAction extends ActionSupport {

	private static final long serialVersionUID = 1L;

	private ChatService chatService;
	
	private String name;
	private String description;
	
	
	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public CrudRoomAction(ChatService chatService) {
		this.chatService = chatService;
	}
	
	public String create() throws Exception {
		try {
			chatService.addRoom(new Room(name, description));
		}
		catch(ChatException e) {
			addActionError(e.getMessage());
		}
		return SUCCESS;
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/chat/DateConverter.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.chat;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.util.StrutsTypeConverter;

public class DateConverter extends StrutsTypeConverter {
	
	private static final Log _log = LogFactory.getLog(DateConverter.class);

	public Object convertFromString(Map context, String[] values, Class toClass) {
		
		if (values.length > 0 && values[0] != null && values[0].trim().length() > 0) {
			SimpleDateFormat sdf = new SimpleDateFormat();
			try {
				return sdf.parse(values[0]);
			}
			catch(ParseException e) {
				_log.error("error converting value ["+values[0]+"] to Date ", e);
			}
		}
		return null;
	}

	public String convertToString(Map context, Object o) {
		
		if (o instanceof Date) {
			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy hh:mm:ss");
			return sdf.format((Date) o);
		}
		return "";
	}
}

"
apps/showcase/src/main/java/org/apache/struts2/showcase/chat/EnterRoomAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.chat;

import java.util.Map;

import org.apache.struts2.interceptor.SessionAware;

import com.opensymphony.xwork2.ActionSupport;

public class EnterRoomAction extends ActionSupport implements SessionAware {

	private static final long serialVersionUID = 1L;
	
	private ChatService chatService;
	private Map session;
	private String roomName;
	
	public String getRoomName() { return this.roomName; }
	public void setRoomName(String roomName) { this.roomName = roomName; }
	
	public EnterRoomAction(ChatService chatService) {
		this.chatService = chatService;
	}
	
	public String execute() throws Exception {
		
		User user = (User) session.get(ChatAuthenticationInterceptor.USER_SESSION_KEY);
		try {
			chatService.enterRoom(user, roomName);
		}
		catch(Exception e) {
			addActionError(e.getMessage());
		}	
		return SUCCESS;
	}

	
	// === SessionAware ===
	public void setSession(Map session) {
		this.session = session;
	}
	
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/chat/ExitRoomAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.chat;

import java.util.Map;

import org.apache.struts2.interceptor.SessionAware;

import com.opensymphony.xwork2.ActionSupport;

public class ExitRoomAction extends ActionSupport implements SessionAware {

	private static final long serialVersionUID = 1L;

	private String roomName;
	
	private Map session;
	
	public String getRoomName() { return roomName; }
	public void setRoomName(String roomName) { this.roomName = roomName; }
	
	private ChatService chatService; 
	
	public ExitRoomAction(ChatService chatService) {
		this.chatService = chatService;
	}
	
	public String execute() throws Exception {
		User user = (User) session.get(ChatAuthenticationInterceptor.USER_SESSION_KEY);
		chatService.exitRoom(user.getName(), roomName);
		
		return SUCCESS;
	}
	
	// === SessionAware ===
	public void setSession(Map session) {
		this.session = session;
	}
	
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/chat/MessagesAvailableInRoomAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.chat;

import java.util.ArrayList;
import java.util.List;

import com.opensymphony.xwork2.ActionSupport;

public class MessagesAvailableInRoomAction extends ActionSupport {

	private static final long serialVersionUID = 1L;

	private String roomName;
	private ChatService chatService;
	private List<ChatMessage> messagesAvailableInRoom = new ArrayList<ChatMessage>();
	
	public String getRoomName() { return this.roomName; }
	public void setRoomName(String roomName) {
		this.roomName = roomName;
	}
	
	public List<ChatMessage> getMessagesAvailableInRoom() {
		return messagesAvailableInRoom;
	}
	
	public MessagesAvailableInRoomAction(ChatService chatService) {
		this.chatService = chatService;
	}
	
	public String execute() throws Exception {
		try {
			messagesAvailableInRoom = chatService.getMessagesInRoom(roomName);
		}
		catch(ChatException e) {
			addActionError(e.getMessage());
		}
		return SUCCESS;
	}
	
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/chat/Room.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.chat;

import java.util.ArrayList;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class Room {
	
	private static final int MAX_CHAT_MESSAGES = 10;
	
	private String name;
	private String description;
	private Date creationDate;
	
	private List<ChatMessage> messages = new ArrayList<ChatMessage>();
	
	private Map<String, User> members = new LinkedHashMap<String, User>();
	
	public Room(String name, String description) {
		this.name = name;
		this.description = description;
		this.creationDate = new Date(System.currentTimeMillis());
	}
	
	
	// properties
	public Date getCreationDate() {
		return creationDate;
	}

	public String getDescription() {
		return description;
	}

	public String getName() {
		return name;
	}
	
	
	// (behaviour) members
	public List<User> getMembers() {
		return new ArrayList<User>(members.values());
	}
	public User findMember(String name) {
		assert(name != null);
		return members.get(name);
	}
	public boolean hasMember(String name) {
		assert(name != null);
		return members.containsKey(name);
	}
	public void memberEnter(User member) {
		assert(member != null);
		if (! hasMember(member.getName())) {
			members.put(member.getName(), member);
		}
	}
	
	public void memberExit(String memberName) {
		assert(memberName != null);
		assert(memberName.trim().length() > 0);
		members.remove(memberName);
	}

	
	// (behaviour) chat messags
	public void addMessage(ChatMessage chatMessage) {
		if (messages.size() > MAX_CHAT_MESSAGES) {
			// messages.remove(messages.size() - 1);
			messages.remove(0);
		}
		messages.add(chatMessage);
	}
	
	public List<ChatMessage> getChatMessages() {
		return new ArrayList<ChatMessage>(messages);
	}
	
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/chat/RoomsAvailableAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.chat;

import java.util.ArrayList;
import java.util.List;

import com.opensymphony.xwork2.ActionSupport;

public class RoomsAvailableAction extends ActionSupport {

	private static final long serialVersionUID = 1L;

	private List<Room> availableRooms = new ArrayList<Room>();
	
	private ChatService chatService;
	
	public RoomsAvailableAction(ChatService chatService) {
		this.chatService = chatService;
	}
	
	public String execute() throws Exception {
		availableRooms = chatService.getAvailableRooms();
		return SUCCESS;
	}
	
	public List<Room> getAvailableRooms() {
		return availableRooms;
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/chat/SendMessageToRoomAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.chat;

import java.util.Map;

import org.apache.struts2.interceptor.SessionAware;

import com.opensymphony.xwork2.ActionSupport;

public class SendMessageToRoomAction extends ActionSupport implements SessionAware {

	private static final long serialVersionUID = 1L;
	
	private ChatService chatService;
	
	private String roomName;
	private String message;
	private Map session;
	
	
	public SendMessageToRoomAction(ChatService chatService) {
		this.chatService = chatService;
	}
	
	public String getRoomName() { return this.roomName; }
	public void setRoomName(String roomName) {
		this.roomName = roomName;
	}
	
	public String getMessage() { return this.message; }
	public void setMessage(String message) {
		this.message = message;
	}
	
	
	public String execute() throws Exception {
		User user = (User) session.get(ChatAuthenticationInterceptor.USER_SESSION_KEY);
		try {
			chatService.sendMessageToRoom(roomName, user, message);
		}catch(ChatException e) {
			addActionError(e.getMessage());
		}
		return SUCCESS;
	}

	public void setSession(Map session) {
		this.session = session;
	}

	
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/chat/User.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.chat;

import java.io.Serializable;
import java.util.Date;

/**
 * Represends a user in the Chat example.
 */
public class User implements Serializable  {
	
	private static final long serialVersionUID = -1434958919516089297L;
	
	private String name;
	private Date creationDate;
	
	
	public User(String name) {
		this.name = name;
		this.creationDate = new Date(System.currentTimeMillis());
	}
	
	public Date getCreationDate() {
		return creationDate;
	}
	public String getName() {
		return name;
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/chat/UsersAvailableAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.chat;

import java.util.ArrayList;
import java.util.List;

import com.opensymphony.xwork2.ActionSupport;

public class UsersAvailableAction extends ActionSupport {

	private static final long serialVersionUID = 1L;
	
	private List<User> availableUsers = new ArrayList<User>();
	private ChatService chatService;
	
	public UsersAvailableAction(ChatService chatService) {
		this.chatService = chatService;
	}
	
	public String execute() throws Exception {
		
		availableUsers = chatService.getAvailableUsers();
		
		return SUCCESS;
	}
	
	public List<User> getAvailableUsers() {
		return availableUsers;
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/chat/UsersAvailableInRoomAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.chat;

import java.util.ArrayList;
import java.util.List;

import com.opensymphony.xwork2.ActionSupport;

public class UsersAvailableInRoomAction extends ActionSupport {

	private static final long serialVersionUID = 1L;
	
	private ChatService chatService;
	private List<User> usersAvailableInRoom = new ArrayList<User>();
	
	private String roomName;
	
	public UsersAvailableInRoomAction(ChatService chatService) {
		this.chatService = chatService;
	}
	
	
	public String getRoomName() { return this.roomName; }
	public void setRoomName(String roomName) {
		this.roomName = roomName;
	}
	
	public List<User> getUsersAvailableInRoom() {
		return usersAvailableInRoom;
	}
	
	public String execute() throws Exception {
		try {
			usersAvailableInRoom = chatService.getUsersAvailableInRoom(roomName);
		}
		catch(ChatException e) {
			addActionError(e.getMessage());
		}
		return SUCCESS;
	}

}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/conversion/Person.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.conversion;

import java.io.Serializable;

/**
 *
 */
public class Person implements Serializable {
	private String name;
	private Integer age;
	
	public void setName(String name) { this.name = name; }
	public String getName() { return this.name; }
	
	public void setAge(Integer age) { this.age = age; }
	public Integer getAge() { return this.age; }
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/conversion/PersonAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.conversion;

import java.util.List;

import com.opensymphony.xwork2.ActionSupport;

/**
 * 
 */
public class PersonAction extends ActionSupport {
	
	private List persons;
	
	public List getPersons() { return persons; }
	public void setPersons(List persons) { this.persons = persons; }
	
	
	
	public String input() throws Exception {
		return SUCCESS;
	}
	
	public String submit() throws Exception {
		return SUCCESS;
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/dao/AbstractDao.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.dao;

import org.apache.struts2.showcase.model.IdEntity;
import org.apache.struts2.showcase.exception.CreateException;
import org.apache.struts2.showcase.exception.UpdateException;
import org.apache.struts2.showcase.exception.StorageException;
import org.apache.struts2.showcase.application.Storage;

import java.io.Serializable;
import java.util.Collection;

/**
 * AbstractDao.
 *
 */

public abstract class AbstractDao implements Serializable, Dao {

    private Storage storage;

    public Storage getStorage() {
        return storage;
    }

    public void setStorage(Storage storage) {
        this.storage = storage;
    }

    public IdEntity get(Serializable id) {
        return getStorage().get(getFeaturedClass(), id);
    }

    public Serializable create(IdEntity object) throws CreateException {
        return getStorage().create(object);
    }

    public IdEntity update(IdEntity object) throws UpdateException {
        return getStorage().update(object);
    }

    public Serializable merge(IdEntity object) throws StorageException {
        return getStorage().merge(object);
    }

    public int delete(Serializable id) throws CreateException {
        return getStorage().delete(getFeaturedClass(), id);
    }

    public int delete(IdEntity object) throws CreateException {
        return getStorage().delete(object);
    }

    public Collection findAll() {
        return getStorage().findAll(getFeaturedClass());
    }

}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/dao/Dao.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.dao;

import org.apache.struts2.showcase.model.IdEntity;
import org.apache.struts2.showcase.exception.CreateException;
import org.apache.struts2.showcase.exception.UpdateException;
import org.apache.struts2.showcase.exception.StorageException;

import java.io.Serializable;
import java.util.Collection;

/**
 * Dao. Interface.
 *
 */

public interface Dao {

    Class getFeaturedClass();

    IdEntity get(Serializable id);

    Serializable create(IdEntity object) throws CreateException;

    IdEntity update(IdEntity object) throws UpdateException;

    Serializable merge(IdEntity object) throws StorageException;

    int delete(Serializable id) throws CreateException;

    int delete(IdEntity object) throws CreateException;

    Collection findAll();
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/dao/EmployeeDao.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.dao;

import org.apache.struts2.showcase.model.Employee;
import org.apache.struts2.showcase.model.Skill;

import java.util.List;
import java.util.ArrayList;

/**
 * EmployeeDao.
 *
 */

public class EmployeeDao extends AbstractDao {

	private static final long serialVersionUID = -6615310540042830594L;

    protected SkillDao skillDao;

    public void setSkillDao(SkillDao skillDao) {
        this.skillDao = skillDao;
    }

    public Class getFeaturedClass() {
        return Employee.class;
    }

    public Employee getEmployee( Long id ) {
        return (Employee) get(id);
    }

    public Employee setSkills(Employee employee, List skillNames) {
        if (employee!= null && skillNames != null) {
            employee.setOtherSkills(new ArrayList());
            for (int i = 0, j = skillNames.size(); i < j; i++) {
                Skill skill = (Skill) skillDao.get((String) skillNames.get(i));
                employee.getOtherSkills().add(skill);
            }
        }
        return employee;
    }

    public Employee setSkills(Long empId, List skillNames) {
        return setSkills((Employee) get(empId), skillNames);
    }

}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/dao/SkillDao.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.dao;

import org.apache.struts2.showcase.model.Skill;

/**
 * SkillDao.
 *
 */

public class SkillDao extends AbstractDao {

	private static final long serialVersionUID = -8160406514074630866L;

    public Class getFeaturedClass() {
        return Skill.class;
    }

    public Skill getSkill( String name ) {
        return (Skill) get(name);
    }
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/exception/CreateException.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.exception;

/**
 * CreateException.
 *
 */

public class CreateException extends StorageException {

	private static final long serialVersionUID = 6734349565111633783L;
	
    public CreateException(String message) {
        super(message);
    }

    public CreateException(String message, Throwable cause) {
        super(message, cause);
    }

    public CreateException(Throwable cause) {
        super(cause);
    }
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/exception/DeleteException.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.exception;

/**
 * DeleteException.
 *
 */

public class DeleteException extends StorageException {

	private static final long serialVersionUID = -5286362812955627352L;

	public DeleteException(String message) {
        super(message);
    }

    public DeleteException(Throwable cause) {
        super(cause);
    }

    public DeleteException(String message, Throwable cause) {
        super(message, cause);
    }

}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/exception/DuplicateKeyException.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.exception;

/**
 * DuplicateKeyException.
 *
 */

public class DuplicateKeyException extends CreateException {

	private static final long serialVersionUID = 989620752592415898L;

    public DuplicateKeyException(String message) {
        super(message);
    }

    public DuplicateKeyException(Throwable cause) {
        super(cause);
    }

    public DuplicateKeyException(String message, Throwable cause) {
        super(message, cause);
    }

}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/exception/StorageException.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.exception;

/**
 * StorageException.
 *
 */

public class StorageException extends Exception {

	private static final long serialVersionUID = -2528721270540362905L;
	
    public StorageException(String message) {
        super(message);
    }

    public StorageException(Throwable cause) {
        super(cause);
    }

    public StorageException(String message, Throwable cause) {
        super(message, cause);
    }

}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/exception/UpdateException.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.exception;


/**
 * UpdateException.
 *
 */

public class UpdateException extends StorageException {

	private static final long serialVersionUID = -4728238600375630452L;
	

    public UpdateException(String message) {
        super(message);
    }

    public UpdateException(Throwable cause) {
        super(cause);
    }

    public UpdateException(String message, Throwable cause) {
        super(message, cause);
    }
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/filedownload/FileDownloadAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.filedownload;

import org.apache.struts2.ServletActionContext;
import com.opensymphony.xwork2.Action;

import java.io.InputStream;

/**
 * Action to demonstrate how to use file download.
 * <p/>
 * This action is used to download a jpeg file from the image folder.
 *
 */
public class FileDownloadAction implements Action {

    public InputStream getImageStream() throws Exception {
        return ServletActionContext.getServletContext().getResourceAsStream("/images/struts.gif");
    }

    public String execute() throws Exception {
        return SUCCESS;
    }

}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/fileupload/FileUploadAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.fileupload;

import com.opensymphony.xwork2.ActionSupport;

import java.io.File;

/**
 * Show case File Upload example's action. <code>FileUploadAction</code>
 *
 */
public class FileUploadAction extends ActionSupport {

	private static final long serialVersionUID = 5156288255337069381L;
	
	private String contentType;
    private File upload;
    private String fileName;
    private String caption;
    
    // since we are using <s:file name="upload" .../> the file name will be
    // obtained through getter/setter of <file-tag-name>FileName
    public String getUploadFileName() {
    	return fileName;
    }
    public void setUploadFileName(String fileName) {
    	this.fileName = fileName;
    }

    
    // since we are using <s:file name="upload" ... /> the content type will be
    // obtained through getter/setter of <file-tag-name>ContentType
    public String getUploadContentType() {
        return contentType;
    }
    public void setUploadContentType(String contentType) {
        this.contentType = contentType;
    }

    
    // since we are using <s:file name="upload" ... /> the File itself will be
    // obtained through getter/setter of <file-tag-name>
    public File getUpload() {
        return upload;
    }
    public void setUpload(File upload) {
        this.upload = upload;
    }

    
    public String getCaption() {
        return caption;
    }
    public void setCaption(String caption) {
        this.caption = caption;
    }

    public String input() throws Exception {
        return SUCCESS;
    }

    public String upload() throws Exception  {
        return SUCCESS;
    }

}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/freemarker/CustomFreemarkerManager.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.freemarker;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.views.freemarker.FreemarkerManager;
import org.apache.struts2.views.freemarker.ScopesHashModel;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * This is an example of a custom FreemarkerManager, mean to be 
 * instantiated through Spring. 
 * <p/>
 * 
 * It will add into Freemarker's model
 * an utility class called {@link CustomFreemarkerManagerUtil} as a simple 
 * example demonstrating how to extends FreemarkerManager.
 * <p/>
 * 
 * The {@link CustomFreemarkerManagerUtil} will be created by Spring and 
 * injected through constructor injection.
 * <p/>
 */
public class CustomFreemarkerManager extends FreemarkerManager {
	
	private CustomFreemarkerManagerUtil util;
	
	public CustomFreemarkerManager(CustomFreemarkerManagerUtil util) {
		this.util = util;
	}
	
	public void populateContext(ScopesHashModel model, OgnlValueStack stack, Object action, HttpServletRequest request, HttpServletResponse response) {
		super.populateContext(model, stack, action, request, response);
		model.put("customFreemarkerManagerUtil", util);
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/freemarker/CustomFreemarkerManagerUtil.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.freemarker;

import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * This class is just a simple util that gets injected into 
 * {@link CustomFreemarkerManager} through Spring's constructor
 * injection, serving as a simple example in Struts' Showcase. 
 */
public class CustomFreemarkerManagerUtil {

	public String getTodayDate() {
		SimpleDateFormat sdf = new SimpleDateFormat("dd-MM-yyyy");
		return sdf.format(new Date());
	}
	
	public String getTimeNow() {
		SimpleDateFormat sdf = new SimpleDateFormat("hh:mm:ss");
		return sdf.format(new Date());
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/hangman/GetUpdatedHangmanAction.java,false,"package org.apache.struts2.showcase.hangman;

import java.util.Map;

import org.apache.struts2.interceptor.SessionAware;

import com.opensymphony.xwork2.ActionSupport;

public class GetUpdatedHangmanAction extends ActionSupport implements SessionAware {
	
	private static final long serialVersionUID = 5506025785406043027L;
	
	private Map session;
	private Hangman hangman;
	
	
	public String execute() throws Exception {
		hangman = (Hangman) session.get(HangmanConstants.HANGMAN_SESSION_KEY);
		
		System.out.println("\n\n\n");
		System.out.println("hangman="+hangman);
		System.out.println("available = "+hangman.getCharactersAvailable().size());
		System.out.println("guess left="+hangman.guessLeft());
		System.out.println("\n\n\n");
		
		return SUCCESS;
	}

	public void setSession(Map session) {
		this.session = session;
	}
	
	public Hangman getHangman() {
		return hangman;
	}
	public void setHangman(Hangman hangman) {
		this.hangman = hangman;
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/hangman/GuessCharacterAction.java,false,"package org.apache.struts2.showcase.hangman;

import java.util.Map;

import org.apache.struts2.interceptor.SessionAware;

import com.opensymphony.xwork2.ActionSupport;

public class GuessCharacterAction extends ActionSupport implements SessionAware {
	
	private static final long serialVersionUID = 9050915577007590674L;
	
	private Map session;
	private Character character;
	private Hangman hangman;
	
	public String execute() throws Exception {
		hangman = (Hangman) session.get(HangmanConstants.HANGMAN_SESSION_KEY);
		hangman.guess(character);
		
		return SUCCESS;
	}
	
	public Hangman getHangman() {
		return hangman;
	}

	public void setSession(Map session) {
		this.session = session;
	}
	
	public void setCharacter(Character character) {
		this.character = character;
	}
	
	public Character getCharacter() {
		return this.character;
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/hangman/Hangman.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.hangman;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Hangman implements Serializable {
	
	private static final long serialVersionUID = 8566954355839652509L;

	private Vocab vocab;
	
	private Boolean win = false;
	
	private int guessLeft = 5;
	public List<Character> charactersAvailable;
	public List<Character> charactersGuessed;
	
	public Hangman(Vocab vocab) {
		// Arrays.asList(...) returns List that doesn't support remove(), hence 
		// we wrap it with an ArrayList to avoid UnsupportedOperationException 
		// when doing a remove()
		charactersAvailable = new ArrayList<Character>(Arrays.asList(
			new Character[] {
				Character.valueOf('A'), Character.valueOf('B'), Character.valueOf('C'), 
				Character.valueOf('D'), Character.valueOf('E'), Character.valueOf('F'), 
				Character.valueOf('G'), Character.valueOf('H'), Character.valueOf('I'), 
				Character.valueOf('J'), Character.valueOf('K'), Character.valueOf('L'), 
				Character.valueOf('M'), Character.valueOf('N'), Character.valueOf('O'), 
				Character.valueOf('P'), Character.valueOf('Q'), Character.valueOf('R'), 
				Character.valueOf('S'), Character.valueOf('T'), Character.valueOf('U'), 
				Character.valueOf('V'), Character.valueOf('W'), Character.valueOf('X'), 
				Character.valueOf('Y'), Character.valueOf('Z')
			}));
		charactersGuessed = new ArrayList<Character>();
		this.vocab = vocab;
	}
	
	public void guess(Character character) {
		assert(character != null);
		
		synchronized(charactersAvailable) {
			if (guessLeft < 0) {
				throw new HangmanException(
					HangmanException.Type.valueOf("GAME_ENDED"), "Game already eneded");
			}
			Character characterInUpperCase = Character.toUpperCase(character);
			boolean ok = charactersAvailable.remove(characterInUpperCase);
			if (ok) {
				charactersGuessed.add(characterInUpperCase);
				if (! vocab.containCharacter(characterInUpperCase)) {
					guessLeft = guessLeft - 1;
				}
			}
			if (vocab.containsAllCharacter(charactersGuessed)) {
				win = true;
			}
			System.out.println(" *********************************** "+win);
		}
	}
	
	public Boolean isWin() {
		return this.win;
	}
	
	public Vocab getVocab() {
		return vocab;
	}
	
	public Boolean gameEnded() {
		return ((guessLeft < 0) || win);
	}
	
	public Integer guessLeft() {
		return guessLeft;
	}
	
	public List<Character> getCharactersAvailable() {
		synchronized(charactersAvailable) {
			 return new ArrayList<Character>(charactersAvailable);
			//return charactersAvailable;
		}
	}
	
	public boolean characterGuessedBefore(Character character) {
		return charactersGuessed.contains(character);
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/hangman/HangmanConstants.java,false,"package org.apache.struts2.showcase.hangman;

public class HangmanConstants {
	// keeps a Hangman object in HttpSession
	public static final String HANGMAN_SESSION_KEY = "Hangman_Session_Key";
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/hangman/HangmanException.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.hangman;

public class HangmanException extends RuntimeException {
	
	private static final long serialVersionUID = -8500292863595941335L;

	enum Type {
		GAME_ENDED, 
		NO_VOCAB, 
		NO_VOCAB_SOURCE;
	}
	
	
	private Type type;
	
	public HangmanException (Type type, String reason) {
		super(reason);
		this.type = type;
	}
	
	public Type getType() {
		return type;
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/hangman/HangmanService.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.hangman;

public class HangmanService {
	
	public VocabSource vocabSource;
	
	public HangmanService(VocabSource vocabSource) {
		this.vocabSource = vocabSource;
	}
	
	public Hangman startNewGame() {
		return new Hangman(vocabSource.getRandomVocab());
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/hangman/PropertiesVocabSource.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.hangman;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Properties;

public class PropertiesVocabSource implements VocabSource {

	private Properties prop;
	private List<Vocab> vocabs;
	
	public PropertiesVocabSource() {
	}
	
	public PropertiesVocabSource(Properties prop) {
		assert(prop != null);
		this.prop = prop;
		vocabs = readVocab(prop);
	}
	
	public void setVocabProperties(Properties prop) {
		assert(prop != null);
		this.prop = prop;
		vocabs = readVocab(prop);
	}
	
	public Vocab getRandomVocab() {
		if (vocabs == null) {
			throw new HangmanException(HangmanException.Type.valueOf("NO_VOCAB_SOURCE"), "No vocab source");
		}
		if (vocabs.size() <= 0) {
			throw new HangmanException(HangmanException.Type.valueOf("NO_VOCAB"), "No vocab");
		}
		long vocabIndex = Math.round((Math.random() * (double)prop.size()));
		vocabIndex = vocabIndex == vocabs.size() ? vocabs.size() - 1 : vocabIndex;
		return vocabs.get((int)vocabIndex);
	} 
	
	protected List<Vocab> readVocab(Properties prop) {
		List<Vocab> vocabList = new ArrayList<Vocab>();
		
		for (Map.Entry e : prop.entrySet()) {
			String vocab = (String) e.getKey();
			String hint = (String) e.getValue();
			
			vocabList.add(new Vocab(vocab, hint));
		}
		return vocabList;
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/hangman/StartHangmanAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.hangman;

import static org.apache.struts2.showcase.hangman.HangmanConstants.*;

import java.util.Map;

import org.apache.struts2.interceptor.SessionAware;

import com.opensymphony.xwork2.ActionSupport;

public class StartHangmanAction extends ActionSupport implements SessionAware {
	
	private static final long serialVersionUID = 2333463075324892521L;
	
	private HangmanService service;
	private Hangman hangman;
	private Map session;
	
	
	public StartHangmanAction(HangmanService service) {
		this.service = service;
	}
	
	public String execute() throws Exception {
		
		hangman = service.startNewGame();
		session.put(HANGMAN_SESSION_KEY, hangman);
		
		return SUCCESS;
	}

	public Hangman getHangman() {
		return hangman;
	}
	
	
	// === SessionAware ===
	public void setSession(Map session) {
		this.session = session;
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/hangman/Vocab.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.hangman;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Vocab implements Serializable {
	
	private static final long serialVersionUID = 1L;
	
	private String vocab;
	private String hint;
	private Character[] characters; // character this vocab is made up of
	
	public Vocab(String vocab, String hint) {
		assert(vocab != null);
		assert(hint != null);
		
		this.vocab = vocab.toUpperCase();
		this.hint = hint;
	}
	
	public String getVocab() { return this.vocab; }
	public String getHint() { return this.hint; }
	
	public Boolean containCharacter(Character character) {
		assert(character != null);
		
		return (vocab.contains(character.toString())) ? true : false;
	}
	
	public Character[] inCharacters() {
		if (characters == null) {
			char[] c = vocab.toCharArray();
			characters = new Character[c.length];
			for (int a=0; a< c.length; a++) {
				characters[a] = Character.valueOf(c[a]);
			}
		}
		return characters;
	}

	public boolean containsAllCharacter(List<Character> charactersGuessed) {
		Character[] chars = inCharacters();
		List<Character> tmpChars = Arrays.asList(chars);
		return charactersGuessed.containsAll(tmpChars);
	}
	
	public static void main(String args[]) throws Exception {
		Vocab v = new Vocab("JAVA", "a java word");
		
		List<Character> list1= new ArrayList<Character>();
		list1.add(new Character('J'));
		list1.add(new Character('V'));
		
		List<Character> list2 = new ArrayList<Character>();
		list2.add(new Character('J'));
		list2.add(new Character('V'));
		list2.add(new Character('A'));
		
		System.out.println(v.containsAllCharacter(list1));
		System.out.println(v.containsAllCharacter(list2));
		
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/hangman/VocabSource.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.hangman;

public interface VocabSource {
	Vocab getRandomVocab();
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/jsf/JsfEmployeeAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.jsf;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.apache.struts2.showcase.action.EmployeeAction;
import org.apache.struts2.showcase.dao.SkillDao;
import org.apache.struts2.showcase.model.Employee;
import org.apache.struts2.showcase.model.Skill;

/**
 * Overriding the EmployeeAction to main provide getters returning the data in
 * the form required by the JSF components
 */
public class JsfEmployeeAction extends EmployeeAction {

    private static final long serialVersionUID = 1L;

    /**
     * Creating a default employee and main skill, since the JSF EL can't handle
     * creating new objects as necessary
     * 
     */
    public JsfEmployeeAction() {
        Employee e = new Employee();
        e.setMainSkill(new Skill());
        setCurrentEmployee(e);
    }

    private SkillDao skillDao;

    public void setSkillDao(SkillDao skillDao) {
        this.skillDao = skillDao;
    }

    /**
     * Returning a List because the JSF dataGrid can't handle a Set for some
     * reason
     */
    @Override
    public Collection getAvailableItems() {
        return new ArrayList(super.getAvailableItems());
    }

    /**
     * Changing the String array into a Map
     */
    public Map<String, String> getAvailablePositionsAsMap() {
        Map<String, String> map = new LinkedHashMap<String, String>();
        for (String val : super.getAvailablePositions()) {
            map.put(val, val);
        }
        return map;
    }

    /**
     * Converting the list into a map
     */
    public Map getAvailableLevelsAsMap() {
        Map map = new LinkedHashMap();
        for (Object val : super.getAvailableLevels()) {
            map.put(val, val);
        }
        return map;
    }

    /**
     * Converting the Skill object list into a map
     */
    public Map<String, String> getAvailableSkills() {
        Map<String, String> map = new HashMap<String, String>();
        for (Object val : skillDao.findAll()) {
            Skill skill = (Skill) val;
            map.put(skill.getDescription(), skill.getName());
        }
        return map;
    }

    /**
     * Gets the selected Skill objects as a list
     */
    public List<String> getSelectedSkillsAsList() {
        System.out.println("asked for skills");
        List<String> list = new ArrayList<String>();
        List skills = super.getSelectedSkills();
        if (skills != null) {
            for (Object val : skills) {
                if (val instanceof Skill) {
                    list.add(((Skill) val).getDescription());
                } else {
                    Skill skill = skillDao.getSkill((String) val);
                    list.add(skill.getDescription());
                }
            }
        }
        return list;
    }
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/model/Employee.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.model;

import java.io.Serializable;
import java.util.Date;
import java.util.List;

/**
 * Employee.
 *
 */

public class Employee implements IdEntity {

	private static final long serialVersionUID = -6226845151026823748L;
	
	private Long empId; //textfield w/ conversion
    private String firstName;
    private String lastName;
    private Date birthDate; //datepicker
    private Float salary; //textfield w/ conversion
    private boolean married; //checkbox
    private String position; //combobox
    private Skill mainSkill; //select
    private List otherSkills; //doubleSelect
    private String password; //password
    private String level; //radio
    private String comment; //textarea

    public Employee() {
    }

    public Employee(Long empId, String firstName, String lastName) {
        this.empId = empId;
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public Employee(Long empId, String firstName, String lastName, Date birthDate, Float salary, boolean married, String position, Skill mainSkill, List otherSkills, String password, String level, String comment) {
        this.empId = empId;
        this.firstName = firstName;
        this.lastName = lastName;
        this.birthDate = birthDate;
        this.salary = salary;
        this.married = married;
        this.position = position;
        this.mainSkill = mainSkill;
        this.otherSkills = otherSkills;
        this.password = password;
        this.level = level;
        this.comment = comment;
    }

    public Long getEmpId() {
        return empId;
    }

    public void setEmpId(Long empId) {
        this.empId = empId;
    }

    public Serializable getId() {
        return getEmpId();
    }

    public void setId(Serializable id) {
        setEmpId((Long) id);
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public Date getBirthDate() {
        return birthDate;
    }

    public void setBirthDate(Date birthDate) {
        this.birthDate = birthDate;
    }

    public Float getSalary() {
        return salary;
    }

    public void setSalary(Float salary) {
        this.salary = salary;
    }

    public boolean isMarried() {
        return married;
    }

    public void setMarried(boolean married) {
        this.married = married;
    }

    public String getPosition() {
        return position;
    }

    public void setPosition(String position) {
        this.position = position;
    }

    public Skill getMainSkill() {
        return mainSkill;
    }

    public void setMainSkill(Skill mainSkill) {
        this.mainSkill = mainSkill;
    }

    public List getOtherSkills() {
        return otherSkills;
    }

    public void setOtherSkills(List otherSkills) {
        this.otherSkills = otherSkills;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getLevel() {
        return level;
    }

    public void setLevel(String level) {
        this.level = level;
    }

    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/model/IdEntity.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.model;

import java.io.Serializable;

/**
 * IdEntity. Interface.
 *
 */

public interface IdEntity extends Serializable {

    Serializable getId ();

    void setId ( Serializable id );

}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/model/Skill.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.model;

import java.io.Serializable;

/**
 * Skill.
 *
 */

public class Skill implements IdEntity {

	private static final long serialVersionUID = -4150317722693212439L;
	
	private String name;
    private String description;

    public Skill() {
    }

    public Skill(String name, String description) {
        this.name = name;
        this.description = description;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public Serializable getId() {
        return getName();
    }

    public void setId(Serializable id) {
        setName((String) id);
    }

    public String toString() {
        return getName();
    }
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/modelDriven/Gangster.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.modelDriven;

import java.io.Serializable;

/**
 * A model class to be used by the simple Model-Driven example. 
 * 
 */
public class Gangster implements Serializable {

	private static final long serialVersionUID = 3688389475320294992L;
	
	private String name;
	private int age;
	private String description;
	private boolean bustedBefore;
	
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public boolean isBustedBefore() {
		return bustedBefore;
	}
	public void setBustedBefore(boolean bustedBefore) {
		this.bustedBefore = bustedBefore;
	}
	public String getDescription() {
		return description;
	}
	public void setDescription(String description) {
		this.description = description;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/modelDriven/ModelDrivenAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.modelDriven;

import com.opensymphony.xwork2.ActionSupport;
import com.opensymphony.xwork2.ModelDriven;

/**
 * Action to demonstrate simple model-driven feature of the framework.
 * 
 */
public class ModelDrivenAction extends ActionSupport implements ModelDriven {

	private static final long serialVersionUID = 1271130427666936592L;

	public String input() throws Exception {
		return SUCCESS;
	}
	
	public String execute() throws Exception {
		return SUCCESS;
	}

	public Object getModel() {
		return new Gangster();
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/person/CreatePerson.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.person;

import com.opensymphony.xwork2.ActionSupport;

/**
 */
public class CreatePerson extends ActionSupport {
	
	private static final long serialVersionUID = 200410824352645515L;
	
	PersonManager personManager;
    Person person;

    public void setPersonManager(PersonManager personManager) {
        this.personManager = personManager;
    }

    public String execute() {
        personManager.createPerson(person);

        return SUCCESS;
    }

    public Person getPerson() {
        return person;
    }

    public void setPerson(Person person) {
        this.person = person;
    }
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/person/EditPerson.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.person;

import com.opensymphony.xwork2.ActionSupport;

import java.util.List;
import java.util.Iterator;
import java.util.ArrayList;

/**
 * <code>EditPerson</code>
 *
 */
public class EditPerson extends ActionSupport {

	private static final long serialVersionUID = 7699491775215130850L;
	
	PersonManager personManager;
    List persons = new ArrayList();

    public void setPersonManager(PersonManager personManager) {
        this.personManager = personManager;
    }

    public List getPersons() {
        return persons;
    }

    public void setPersons(List persons) {
        this.persons = persons;
    }

    /**
     * A default implementation that does nothing an returns "success".
     *
     * @return {@link #SUCCESS}
     */
    public String execute() throws Exception {
        persons.addAll(personManager.getPeople());
        return SUCCESS;
    }

    /**
     * A default implementation that does nothing an returns "success".
     *
     * @return {@link #SUCCESS}
     */
    public String save() throws Exception {

        // Set people = personManager.getPeople();

        for ( Iterator iter = persons.iterator(); iter.hasNext();) {
            Person p = (Person) iter.next();
            personManager.getPeople().remove(p);
            personManager.getPeople().add(p);
        }
        return SUCCESS;
    }

}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/person/ListPeople.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.person;

import com.opensymphony.xwork2.ActionSupport;

import java.util.List;
import java.util.ArrayList;

/**
 */
public class ListPeople extends ActionSupport {
	
	private static final long serialVersionUID = 3608017189783645371L;
	
	PersonManager personManager;
    List people = new ArrayList();

    public void setPersonManager(PersonManager personManager) {
        this.personManager = personManager;
    }

    public String execute() {
        people.addAll(personManager.getPeople());

        return SUCCESS;
    }

    public List getPeople() {
        return people;
    }

    public int getPeopleCount() {
        return people.size();
    }

}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/person/Person.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.person;

/**
 */
public class Person {
    Long id;
    String name;
    String lastName;

    public Person() {
    }

    public Person(Long id, String name, String lastName) {
        this.id = id;
        this.name = name;
        this.lastName = lastName;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        final Person person = (Person) o;

        if (id != null ? !id.equals(person.id) : person.id != null) return false;

        return true;
    }

    public int hashCode() {
        return (id != null ? id.hashCode() : 0);
    }


    public String toString() {
        return "Person{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", lastName='" + lastName + '\'' +
                '}';
    }
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/person/PersonManager.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.person;

import java.util.Set;
import java.util.HashSet;

/**
 */
public class PersonManager {
    private static Set people = new HashSet(5);
    private static long COUNT = 5;

    static {
        // create some imaginary persons
        Person p1 = new Person(new Long(1), "Patrick", "Lightbuddie");
        Person p2 = new Person(new Long(2), "Jason", "Carrora");
        Person p3 = new Person(new Long(3), "Alexandru", "Papesco");
        Person p4 = new Person(new Long(4), "Jay", "Boss");
        Person p5 = new Person(new Long(5), "Rainer", "Hermanos");
        people.add(p1);
        people.add(p2);
        people.add(p3);
        people.add(p4);
        people.add(p5);
    }

    public void createPerson(Person person) {
        person.setId(new Long(++COUNT));
        people.add(person);
    }

    public void updatePerson(Person person) {
        people.add(person);
    }

    public Set getPeople() {
        return people;
    }
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/sitemesh/NoneDecoratorMapper.java,true,"package org.apache.struts2.showcase.sitemesh;

import com.opensymphony.module.sitemesh.Decorator;
import com.opensymphony.module.sitemesh.Page;
import com.opensymphony.module.sitemesh.mapper.AbstractDecoratorMapper;

import javax.servlet.http.HttpServletRequest;

/**
 * @author Patrick Lightbody (plightbo at gmail dot com)
 */
public class NoneDecoratorMapper extends AbstractDecoratorMapper {
    public Decorator getDecorator(HttpServletRequest req, Page page) {
        if ("none".equals(req.getAttribute("decorator"))) {
            return null;
        }

        return super.getDecorator(req, page);
    }
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/tag/nonui/actionPrefix/SubmitAction.java,false,"package org.apache.struts2.showcase.tag.nonui.actionPrefix;

import com.opensymphony.xwork2.ActionSupport;

public class SubmitAction extends ActionSupport {

	private static final long serialVersionUID = -7832803019378213087L;
	
	private String text;
	
	public String getText() { return text; }
	public void setText(String text) { this.text = text; }
	
	public String execute() throws Exception {
		return SUCCESS;
	}
	
	public String alternateMethod() {
		return "methodPrefixResult";
	}
	
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/tag/nonui/actiontag/ActionTagDemo.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.tag.nonui.actiontag;

import com.opensymphony.xwork2.ActionSupport;

/**
 */
public class ActionTagDemo extends ActionSupport {
	
	private static final long serialVersionUID = -2749145880590245184L;

	public String show() throws Exception {
		return SUCCESS;
	}
	
	public String doInclude() throws Exception {
		return SUCCESS;
	}
}	
"
apps/showcase/src/main/java/org/apache/struts2/showcase/tag/nonui/iteratortag/AppendIteratorTagDemo.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.tag.nonui.iteratortag;

import com.opensymphony.xwork2.ActionSupport;
import com.opensymphony.xwork2.Validateable;

/**
 * 
 */
public class AppendIteratorTagDemo extends ActionSupport implements Validateable {

	private static final long serialVersionUID = -6525059998526094664L;
	
	private String iteratorValue1;
	private String iteratorValue2;
	
	
	public void validate() {
		if (iteratorValue1 == null || iteratorValue1.trim().length() <= 0 ) {
			addFieldError("iteratorValue1", "iterator value 1 cannot be empty");
		}
		else if (iteratorValue1.trim().indexOf(",") <= 0) {
			addFieldError("iteratorValue1", "iterator value 1 needs to be comma separated");
		}
		if (iteratorValue2 == null || iteratorValue2.trim().length() <= 0) {
			addFieldError("iteratorValue2", "iterator value 2 cannot be empty");
		}
		else if (iteratorValue2.trim().indexOf(",") <= 0) {
			addFieldError("iteratorValue2", "iterator value 2 needs to be comma separated");
		}
	}
	
	
	
	
	public String getIteratorValue1() { 
		return iteratorValue1;
	}
	public void setIteratorValue1(String iteratorValue1) {
		this.iteratorValue1 = iteratorValue1;
	}
	
	
	
	public String getIteratorValue2() {
		return iteratorValue2;
	}
	public void setIteratorValue2(String iteratorValue2) {
		this.iteratorValue2 = iteratorValue2;
	}
	
	
	
	public String input() throws Exception {
		return SUCCESS;
	}
	
	public String submit() throws Exception {
		return SUCCESS;
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/tag/nonui/iteratortag/IteratorGeneratorTagDemo.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.tag.nonui.iteratortag;

import com.opensymphony.xwork2.ActionSupport;

/**
 */
public class IteratorGeneratorTagDemo extends ActionSupport {

	private static final long serialVersionUID = 6893616642389337039L;
	
	private String value;
	private Integer count;
	private String separator;
	
	
	public String getValue() {
		return value;
	}
	public void setValue(String value) {
		this.value = value;
	}
	
	
	public Integer getCount() { 
		return count;
	}
	public void setCount(Integer count) {
		this.count = count;
	}
	
	
	
	public String getSeparator() {
		return this.separator;
	}
	public void setSeparator(String separator) {
		this.separator = separator;
	}
	
	
	public String submit() throws Exception {
		return SUCCESS;
	}
	
	
	public String input() throws Exception {
		return SUCCESS;
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/tag/nonui/iteratortag/MergeIteratorTagDemo.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.tag.nonui.iteratortag;

import com.opensymphony.xwork2.ActionSupport;
import com.opensymphony.xwork2.Validateable;


/**
 */
public class MergeIteratorTagDemo extends ActionSupport implements Validateable {

	private static final long serialVersionUID = 4401107963952961695L;
	
	private String iteratorValue1;
	private String iteratorValue2;
	
	
	public void validate() {
		if (iteratorValue1 == null || iteratorValue1.trim().length() <= 0 ) {
			addFieldError("iteratorValue1", "iterator value 1 cannot be empty");
		}
		else if (iteratorValue1.trim().indexOf(",") <= 0) {
			addFieldError("iteratorValue1", "iterator value 1 needs to be comma separated");
		}
		if (iteratorValue2 == null || iteratorValue2.trim().length() <= 0) {
			addFieldError("iteratorValue2", "iterator value 2 cannot be empty");
		}
		else if (iteratorValue2.trim().indexOf(",") <= 0) {
			addFieldError("iteratorValue2", "iterator value 2 needs to be comma separated");
		}
	}
	
	
	
	public String getIteratorValue1() {
		return this.iteratorValue1;
	}
	public void setIteratorValue1(String iteratorValue1) {
		this.iteratorValue1 = iteratorValue1;
	}
	
	
	
	public String getIteratorValue2() {
		return this.iteratorValue2;
	}
	public void setIteratorValue2(String iteratorValue2) {
		this.iteratorValue2 = iteratorValue2;
	}
	
	
	
	
	
	public String input() throws Exception {
		return SUCCESS;
	}
	
	public String submit() throws Exception {
		return SUCCESS;
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/tag/nonui/iteratortag/SubsetIteratorTagDemo.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.tag.nonui.iteratortag;

import com.opensymphony.xwork2.ActionSupport;
import com.opensymphony.xwork2.Validateable;

/**
 * 
 */
public class SubsetIteratorTagDemo extends ActionSupport implements Validateable {

	private static final long serialVersionUID = -8151855954644052650L;
	
	private String iteratorValue;
	private Integer count;
	private Integer start;
	
	
	public void validate() {
		if (iteratorValue == null || iteratorValue.trim().length() <= 0 ) {
			addFieldError("iteratorValue1", "iterator value 1 cannot be empty");
		}
		else if (iteratorValue.trim().indexOf(",") <= 0) {
			addFieldError("iteratorValue1", "iterator value 1 needs to be comma separated");
		}
	}
	
	
	
	public String getIteratorValue() {
		return this.iteratorValue;
	}
	public void setIteratorValue(String iteratorValue) {
		this.iteratorValue = iteratorValue;
	}
	
	
	
	public Integer getCount() {
		return this.count;
	}
	public void setCount(Integer count) {
		this.count = count;
	}
	
	
	
	public Integer getStart() {
		return this.start;
	}
	public void setStart(Integer start) {
		this.start = start;
	}
	
	
	
	
	
	public String input() throws Exception {
		return SUCCESS;
	}
	
	public String submit() throws Exception {
		return SUCCESS;
	}
	
	
	
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/token/TokenAction.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.token;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionSupport;

import java.util.Date;

/**
 * Example to illustrate the <code>token</code> and <code>token-session</code> interceptor.
 *
 */
public class TokenAction extends ActionSupport {

	private static final long serialVersionUID = 616150375751184884L;
	
	private int amount;

    public String execute() throws Exception {
        // transfer from source to destination

        Integer balSource = (Integer) ActionContext.getContext().getSession().get("balanceSource");
        Integer balDest = (Integer) ActionContext.getContext().getSession().get("balanceDestination");

        Integer newSource = new Integer(balSource.intValue() - amount);
        Integer newDest = new Integer(balDest.intValue() + amount);

        ActionContext.getContext().getSession().put("balanceSource", newSource);
        ActionContext.getContext().getSession().put("balanceDestination", newDest);
        ActionContext.getContext().getSession().put("time", new Date());

        Thread.sleep(2000); // to simulate processing time

        return SUCCESS;
    }

    public String doInput() throws Exception {
        // prepare input form
        Integer balSource = (Integer) ActionContext.getContext().getSession().get("balanceSource");
        Integer balDest = (Integer) ActionContext.getContext().getSession().get("balanceDestination");

        if (balSource == null) {
            // first time set up an initial account balance
            balSource = new Integer(1200);
            ActionContext.getContext().getSession().put("balanceSource", balSource);
        }

        if (balDest == null) {
            // first time set up an initial account balance
            balDest = new Integer(2500);
            ActionContext.getContext().getSession().put("balanceDestination", balDest);
        }

        return INPUT;
    }

    public int getAmount() {
        return amount;
    }

    public void setAmount(int amount) {
        this.amount = amount;
    }

}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/tutorial/HelloName.java,false,"package org.apache.struts2.showcase.tutorial;

import com.opensymphony.xwork2.ActionSupport;

public class HelloName extends ActionSupport {

    public String execute() throws Exception {
        if (getName() == null || getName().length() == 0)
            return ERROR;
        else
            return SUCCESS;
    }

    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}"
apps/showcase/src/main/java/org/apache/struts2/showcase/tutorial/HelloName2.java,false,"package org.apache.struts2.showcase.tutorial;

import com.opensymphony.xwork2.ActionSupport;
import org.apache.struts2.interceptor.ParameterAware;

import java.util.Map;

public class HelloName2 extends ActionSupport implements ParameterAware {

    public static String NAME = "name";

    public String execute() {
        String[] name = (String[]) parameters.get(NAME);
        if (name == null || name[0] == null || name[0].length() == 0)
            return ERROR;
        else
            return SUCCESS;
    }

    Map parameters;

    public Map getParameters() {
        return parameters;
    }

    public void setParameters(Map parameters) {
        this.parameters = parameters;
    }
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/tutorial/HelloWorld.java,false,"package org.apache.struts2.showcase.tutorial;

import com.opensymphony.xwork2.Action;

import java.text.DateFormat;
import java.util.Date;

public class HelloWorld implements Action {

    public String execute() {
        message = "Hello, World!\n";
        message += "The time is:\n";
        message += DateFormat.getDateInstance().format(new Date());
        return SUCCESS;
    }

    private String message;

    public String getMessage() {
        return message;
    }

}"
apps/showcase/src/main/java/org/apache/struts2/showcase/validation/AbstractValidationActionSupport.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.validation;

import com.opensymphony.xwork2.ActionSupport;

/**
 */
public abstract class AbstractValidationActionSupport extends ActionSupport {
	
	public String submit() throws Exception {
		return "success";
	}
	
	public String input() throws Exception {
		return "input";
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/validation/FieldValidatorsExampleAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.validation;

import java.sql.Date;

/**
 */

// START SNIPPET: fieldValidatorsExample

public class FieldValidatorsExampleAction extends AbstractValidationActionSupport {
	
	private static final long serialVersionUID = -4829381083003175423L;
	
	private String requiredValidatorField = null;
	private String requiredStringValidatorField = null;
	private Integer integerValidatorField = null;
	private Date dateValidatorField = null;
	private String emailValidatorField = null;
	private String urlValidatorField = null;
	private String stringLengthValidatorField = null;
	private String regexValidatorField = null;
	private String fieldExpressionValidatorField = null;
	
	
	
	public Date getDateValidatorField() {
		return dateValidatorField;
	}
	public void setDateValidatorField(Date dateValidatorField) {
		this.dateValidatorField = dateValidatorField;
	}
	public String getEmailValidatorField() {
		return emailValidatorField;
	}
	public void setEmailValidatorField(String emailValidatorField) {
		this.emailValidatorField = emailValidatorField;
	}
	public Integer getIntegerValidatorField() {
		return integerValidatorField;
	}
	public void setIntegerValidatorField(Integer integerValidatorField) {
		this.integerValidatorField = integerValidatorField;
	}
	public String getRegexValidatorField() {
		return regexValidatorField;
	}
	public void setRegexValidatorField(String regexValidatorField) {
		this.regexValidatorField = regexValidatorField;
	}
	public String getRequiredStringValidatorField() {
		return requiredStringValidatorField;
	}
	public void setRequiredStringValidatorField(String requiredStringValidatorField) {
		this.requiredStringValidatorField = requiredStringValidatorField;
	}
	public String getRequiredValidatorField() {
		return requiredValidatorField;
	}
	public void setRequiredValidatorField(String requiredValidatorField) {
		this.requiredValidatorField = requiredValidatorField;
	}
	public String getStringLengthValidatorField() {
		return stringLengthValidatorField;
	}
	public void setStringLengthValidatorField(String stringLengthValidatorField) {
		this.stringLengthValidatorField = stringLengthValidatorField;
	}
	public String getFieldExpressionValidatorField() {
		return fieldExpressionValidatorField;
	}
	public void setFieldExpressionValidatorField(
			String fieldExpressionValidatorField) {
		this.fieldExpressionValidatorField = fieldExpressionValidatorField;
	}

    public String getUrlValidatorField() {
        return urlValidatorField;
    }

    public void setUrlValidatorField(String urlValidatorField) {
        this.urlValidatorField = urlValidatorField;
    }
}


// END SNIPPET: fieldValidatorsExample

"
apps/showcase/src/main/java/org/apache/struts2/showcase/validation/NonFieldValidatorsExampleAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.validation;

/**
 */

// START SNIPPET: nonFieldValidatorsExample

public class NonFieldValidatorsExampleAction extends AbstractValidationActionSupport {
	
	private static final long serialVersionUID = -524460368233581186L;
	
	private String someText;
	private String someTextRetype;
	private String someTextRetypeAgain;
	
	public String getSomeText() {
		return someText;
	}
	public void setSomeText(String someText) {
		this.someText = someText;
	}
	public String getSomeTextRetype() {
		return someTextRetype;
	}
	public void setSomeTextRetype(String someTextRetype) {
		this.someTextRetype = someTextRetype;
	}
	public String getSomeTextRetypeAgain() {
		return someTextRetypeAgain;
	}
	public void setSomeTextRetypeAgain(String someTextRetypeAgain) {
		this.someTextRetypeAgain = someTextRetypeAgain;
	}
}


// END SNIPPET: nonFieldValidatorsExample



"
apps/showcase/src/main/java/org/apache/struts2/showcase/validation/QuizAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.validation;

import com.opensymphony.xwork2.ActionSupport;

/**
 */

// START SNIPPET: quizAction 

public class QuizAction extends ActionSupport {
	
	private static final long serialVersionUID = -7505437345373234225L;
	
	String name;
    int age;
    String answer;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getAnswer() {
        return answer;
    }

    public void setAnswer(String answer) {
        this.answer = answer;
    }
}

// END SNIPPET: quizAction

"
apps/showcase/src/main/java/org/apache/struts2/showcase/validation/SubmitApplication.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.validation;

import com.opensymphony.xwork2.ActionSupport;

/**
 * 
 * @version $Date$ $Id$
 */
public class SubmitApplication extends ActionSupport {
	
	private String name;
	private Integer age;
	
	public void setName(String name) {
		this.name = name;
	}
	public String getName() {
		return this.name;
	}
	
	public void setAge(Integer age) {
		this.age = age;
	}
	public Integer getAge() {
		return age;
	}
	
	public String submitApplication() throws Exception {
		return SUCCESS;
	}
	
	public String applicationOk() throws Exception {
		addActionMessage("Your application looks ok.");
		return SUCCESS;
	}
	public String cancelApplication() throws Exception {
		addActionMessage("So you have decided to cancel the application");
		return SUCCESS;
	}
}
"
apps/showcase/src/main/java/org/apache/struts2/showcase/validation/User.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.validation;

import java.sql.Date;

/**
 */
public class User {
	
	private String name;
	private Integer age;
	private Date birthday;
	
	
	public Integer getAge() {
		return age;
	}
	public void setAge(Integer age) {
		this.age = age;
	}
	public Date getBirthday() {
		return birthday;
	}
	public void setBirthday(Date birthday) {
		this.birthday = birthday;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
}

"
apps/showcase/src/main/java/org/apache/struts2/showcase/validation/VisitorValidatorsExampleAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.validation;


// START SNIPPET: visitorValidatorsExample

public class VisitorValidatorsExampleAction extends AbstractValidationActionSupport {

	private static final long serialVersionUID = 4375454086939598216L;
	
	private User user;
	
	public User getUser() {
		return user;
	}
	
	public void setUser(User user) {
		this.user = user;
	}
}


// END SNIPPET: visitorValidatorsExample
"
apps/showcase/src/main/java/org/apache/struts2/showcase/wait/LongProcessAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.showcase.wait;

import com.opensymphony.xwork2.ActionSupport;

/**
 * Example to illustrate the <code>execAndWait</code> interceptor.
 *
 */
public class LongProcessAction extends ActionSupport {

	private static final long serialVersionUID = 2471910747833998708L;
	
	private int time;

    public int getTime() {
        return time;
    }

    public void setTime(int time) {
        this.time = time;
    }

    public String execute() throws Exception {
        System.err.println("time: " + time);
        Thread.sleep(time);

        return SUCCESS;
    }

}
"
core/src/main/java/org/apache/struts2/Main.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2;

import java.io.File;
import java.io.FilenameFilter;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * <!-- START SNIPPET: javadoc -->
 *
 * Struts comes with various related tools included in the struts-core-VERSION.jar file. You can access these
 * tools by simply unpacking the Struts distribution and running <b>java -jar struts-core-VERSION.jar</b>.
 * Struts will automatically include all jars in the same directory as the struts-core-VERSION.jar file as well as all
 * jars in the <i>lib</i> directory. This means you can invoke these tools either from within the standard directory
 * structure found in the Struts distribution, or from within your WEB-INF/lib directory.
 *
 * <p/> You can access the help information for these tools by simply running the jar without any arguments.
 *
 * <!-- END SNIPPET: javadoc -->
 */
public class Main {
    public static void main(String[] args) {
        if (args.length == 0) {
            System.out.println("Usage:");
            System.out.println("  java -jar struts.jar [command] (optional command args)");
            System.out.println("");
            System.out.println("Where [command] is one of the following:");
            System.out.println("  quickstart");
            System.out.println("  quickstart:xxx");
            System.out.println("  sitegraph");
            System.out.println("  sitegraph:xxx");
            System.out.println("");
            System.out.println("Execute the commands for additional usage instructions.");
            System.out.println("Note: the *:xxx commands are just shortcuts for ");
            System.out.println("      running the command on a webapp in the apps dir.");
            System.out.println("      For example, 'quickstart:sandbox' will start QuickStart");
            System.out.println("      automatically for the webapp 'sandbox'.");
            return;
        }

        // check the JDK version
        String version = System.getProperty("java.version");
        boolean jdk15 = version.indexOf("1.5") != -1;

        String javaHome = System.getProperty("java.home");
        ArrayList<URL> urls = new ArrayList<URL>();
        try {
            findJars(new File("lib"), urls);

            // use all the jars in the current that aren't the src jar
            File wd = new File(".");
            File[] jars = wd.listFiles(new FilenameFilter() {
                public boolean accept(File dir, String name) {
                    return name.endsWith(".jar") && name.indexOf("-src.") == -1;
                }
            });
            for (int i = 0; i < jars.length; i++) {
                File jar = jars[i];
                urls.add(jar.toURL());
            }

            // ... but there might not be any (ie: we're in development in IDEA), so use this as backup
            urls.add(new File(System.getProperty("struts.classes", "build/java")).toURL());
            urls.add(new File(System.getProperty("xwork.classes", "../xwork/build/java/")).toURL());

            // load tools.jar from JAVA_HOME
            File tools = new File(javaHome, "lib/tools.jar");
            if (!tools.exists()) {
                // hmm, not there, how about java.home?
                tools = new File(javaHome, "../lib/tools.jar");
            }
            if (!tools.exists()) {
                // try the OS X common path
                tools = new File(javaHome, "../Classes/classes.jar");
            }
            if (!tools.exists()) {
                // try the other OS X common path
                tools = new File(javaHome, "../Classes/classes.jar");
            }
            if (!tools.exists()) {
                // did the user specify it by hand?
                String prop = System.getProperty("tools");
                if (prop != null) {
                    tools = new File(prop);
                }
            }
            if (!tools.exists()) {
                System.out.println("Error: Could not find tools.jar! Please do one of the following: ");
                System.out.println("");
                System.out.println("        - Use the JDK's JVM (ie: c:\\jdk1.5.0\\bin\\java)");
                System.out.println("        - Specify JAVA_HOME to point to your JDK 1.5 home");
                System.out.println("        - Specify a direct path to tools.jar via, as shown below:");
                System.out.println("");
                System.out.println("       java -Dtools=/path/to/tools.jar -jar struts.jar ...");
                return;
            }

            // finally, add the verified tools.jar
            urls.add(tools.toURL());
        } catch (MalformedURLException e) {
            e.printStackTrace();
            System.out.println("Could not find URLs -- see stack trace.");
        }

        String command = args[0];
        String[] programArgs = new String[args.length - 1];
        System.arraycopy(args, 1, programArgs, 0, programArgs.length);
        if (command.startsWith("quickstart:")) {
            command = "quickstart";
            String name = checkWebAppArgs(args);
            programArgs = new String[]{"/" + name,
                    "apps/" + name + "/src/main/webapp",
                    "apps/" + name + "/src/main/java",
                    "apps/" + name + "/src/main/resources"};
        }

        if ("quickstart".equals(command)) {
            if (!jdk15) {
                System.out.println("Sorry, but QuickStart only runs on Java 1.5.");
                System.out.println("You are running: " + version);
                System.out.println("Please try again with Java 1.5, or deploy");
                System.out.println("  as a normal J2EE webapp to use Java 1.4.");
                return;
            }

            launch("org.apache.struts2.quickstart.QuickStart", programArgs, urls);
            return;
        }

        if (command.startsWith("sitegraph:")) {
            command = "sitegraph";
            String name = checkWebAppArgs(args);
            programArgs = new String[]{"-config", "apps/" + name + "/src/webapp/WEB-INF/classes",
                    "-views", "apps/" + name + "/src/webapp",
                    "-output", "."};
        }

        if ("sitegraph".equals(command)) {
            launch("org.apache.struts2.sitegraph.SiteGraph", programArgs, urls);
        }
    }

    private static String checkWebAppArgs(String[] args) {
        int colon = args[0].indexOf(':');
        String name = null;
        try {
            name = args[0].substring(colon + 1);
        } catch (Exception e) {
            //this is OK to skip
        }
        if (name == null || name.equals("")) {
            System.out.println("Error: you must specify the webapp you wish");
            System.out.println("       to deploy. The webapp name must be the");
            System.out.println("       name of the directory found in apps/.");
            System.out.println("");
            System.out.println("Example: java -jar struts-core-VERSION.jar quickstart:sandbox");
            System.exit(1);
        }

        return name;
    }

    private static void launch(String program, String[] programArgs, List<URL> urls) {
        Collections.reverse(urls);
        URL[] urlArray = urls.toArray(new URL[urls.size()]);
        URLClassLoader cl = new MainClassLoader(urlArray);
        Thread.currentThread().setContextClassLoader(cl);
        try {
            Class clazz = cl.loadClass(program);
            Method main = clazz.getDeclaredMethod("main", new Class[]{String[].class});
            main.invoke(null, new Object[]{programArgs});
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void findJars(File file, ArrayList<URL> urls) throws MalformedURLException {
        File[] files = file.listFiles();
        if (files == null) {
            return;
        }
        
        for (int i = 0; i < files.length; i++) {
            File f = files[i];
            if (f.isDirectory()) {
                findJars(f, urls);
            } else if (f.getName().endsWith(".jar")) {
                if (isValid(f.getName())) {
                    urls.add(f.toURL());
                }
            }
        }
    }

    private static boolean isValid(String name) {
        return !"dom.jar".equals(name);
    }

    /**
     * Reverses the typical order of classloading to defer only to the parent if the current class loader can't be
     * found. This is required to allow for the launcher to be embedded within struts.jar (otherwise the dependencies
     * wouldn't be found by the system ClassLoader when invoking using "java -jar struts-core-VERSION.jar ...").
     */
    public static class MainClassLoader extends URLClassLoader {
        public MainClassLoader(URL[] urls) {
            super(urls);
        }

        public Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
            if (name.startsWith("org.xml.") || name.startsWith("org.w3c.")
                    || name.startsWith("java.") || name.startsWith("javax.")
                    || name.startsWith("sun.") || name.startsWith("com.sun.")) {
                return super.loadClass(name, resolve);
            }

            ClassLoader parent = getParent();
            // First, check if the class has already been loaded
            Class c = findLoadedClass(name);
            if (c == null) {
                try {
                    c = findClass(name);
                } catch (Throwable t) {
                    // If still not found, only then ask the parent
                    c = parent.loadClass(name);
                }
            }
            if (resolve) {
                resolveClass(c);
            }

            return c;
        }
    }
}
"
core/src/main/java/org/apache/struts2/RequestUtils.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2;

import javax.servlet.http.HttpServletRequest;


/**
 * Request handling utility class.
 */
public class RequestUtils {

    /**
     * Retrieves the current request servlet path.
     * Deals with differences between servlet specs (2.2 vs 2.3+)
     * 
     * @param request the request
     * @return the servlet path
     */
    public static String getServletPath(HttpServletRequest request) {
        String servletPath = request.getServletPath();
        
        if (null != servletPath && !"".equals(servletPath)) {
            return servletPath;
        }
        
        String requestUri = request.getRequestURI();
        int startIndex = request.getContextPath().equals("") ? 0 : request.getContextPath().length();
        int endIndex = request.getPathInfo() == null ? requestUri.length() : requestUri.lastIndexOf(request.getPathInfo());
        
        if (startIndex > endIndex) { // this should not happen
            endIndex = startIndex;
        }
        
        return requestUri.substring(startIndex, endIndex);
    }
    
}
"
core/src/main/java/org/apache/struts2/ServletActionContext.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2;

import java.util.Map;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.jsp.PageContext;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * Web-specific context information for actions. This class subclasses <tt>ActionContext</tt> which
 * provides access to things like the action name, value stack, etc. This class adds access to
 * web objects like servlet parameters, request attributes and things like the HTTP session.
 */
public class ServletActionContext extends ActionContext implements StrutsStatics {
	
	private static final long serialVersionUID = -666854718275106687L;
	
	public static final String STRUTS_VALUESTACK_KEY = "struts.valueStack";

    @SuppressWarnings("unused")
    private ServletActionContext(Map context) {
        super(context);
    }

    /**
     * Gets the current action context
     * 
     * @param req The request
     * @return The current action context
     */
    public static ActionContext getActionContext(HttpServletRequest req) {
        OgnlValueStack vs = getValueStack(req);
        if (vs != null) {
            return new ActionContext(vs.getContext());
        } else {
            return null;
        }
    }

    /**
     * Gets the current value stack for this request
     *
     * @param req The request
     * @return The value stack
     */
    public static OgnlValueStack getValueStack(HttpServletRequest req) {
        return (OgnlValueStack) req.getAttribute(STRUTS_VALUESTACK_KEY);
    }

    /**
     * Returns the HTTP page context.
     *
     * @return the HTTP page context.
     */
    public static PageContext getPageContext() {
        return (PageContext) ActionContext.getContext().get(PAGE_CONTEXT);
    }

    /**
     * Sets the HTTP servlet request object.
     *
     * @param request the HTTP servlet request object.
     */
    public static void setRequest(HttpServletRequest request) {
        ActionContext.getContext().put(HTTP_REQUEST, request);
    }

    /**
     * Gets the HTTP servlet request object.
     *
     * @return the HTTP servlet request object.
     */
    public static HttpServletRequest getRequest() {
        return (HttpServletRequest) ActionContext.getContext().get(HTTP_REQUEST);
    }

    /**
     * Sets the HTTP servlet response object.
     *
     * @param response the HTTP servlet response object.
     */
    public static void setResponse(HttpServletResponse response) {
        ActionContext.getContext().put(HTTP_RESPONSE, response);
    }

    /**
     * Gets the HTTP servlet response object.
     *
     * @return the HTTP servlet response object.
     */
    public static HttpServletResponse getResponse() {
        return (HttpServletResponse) ActionContext.getContext().get(HTTP_RESPONSE);
    }

    /**
     * Gets the servlet context.
     *
     * @return the servlet context.
     */
    public static ServletContext getServletContext() {
        return (ServletContext) ActionContext.getContext().get(SERVLET_CONTEXT);
    }

    /**
     * Sets the current servlet context object
     * 
     * @param servletContext The servlet context to use
     */
    public static void setServletContext(ServletContext servletContext) {
        ActionContext.getContext().put(SERVLET_CONTEXT, servletContext);
    }
}
"
core/src/main/java/org/apache/struts2/StrutsConstants.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2;

/**
 * This class provides a central location for framework configuration keys
 * used to retrieve and store Struts configuration settings.
 */
public final class StrutsConstants {

    /** Whether Struts is in development mode or not */
    public static final String STRUTS_DEVMODE = "struts.devMode";

    /** Whether the localization messages should automatically be reloaded */
    public static final String STRUTS_I18N_RELOAD = "struts.i18n.reload";
    
    /** The encoding to use for localization messages */
    public static final String STRUTS_I18N_ENCODING = "struts.i18n.encoding";

    /** Whether to reload the XML configuration or not */
    public static final String STRUTS_CONFIGURATION_XML_RELOAD = "struts.configuration.xml.reload";

    /** The URL extension to use to determine if the request is meant for a Struts action */
    public static final String STRUTS_ACTION_EXTENSION = "struts.action.extension";

    /** Whether to use the alterative syntax for the tags or not */
    public static final String STRUTS_TAG_ALTSYNTAX = "struts.tag.altSyntax";

    /** The HTTP port used by Struts URLs */
    public static final String STRUTS_URL_HTTP_PORT = "struts.url.http.port";
    
    /** The HTTPS port used by Struts URLs */
    public static final String STRUTS_URL_HTTPS_PORT = "struts.url.https.port";

    /** The default includeParams method to generate Struts URLs */
    public static final String STRUTS_URL_INCLUDEPARAMS = "struts.url.includeParams";

    /** The com.opensymphony.xwork.ObjectFactory implementation class */
    public static final String STRUTS_OBJECTFACTORY = "struts.objectFactory";
    
    /** The com.opensymphony.xwork.util.ObjectTypeDeterminer implementation class */
    public static final String STRUTS_OBJECTTYPEDETERMINER = "struts.objectTypeDeterminer";

    /** The package containing actions that use Rife continuations */
    public static final String STRUTS_CONTINUATIONS_PACKAGE = "struts.continuations.package";

    /** The org.apache.struts2.config.Configuration implementation class */
    public static final String STRUTS_CONFIGURATION = "struts.configuration";

    /** The default locale for the Struts application */
    public static final String STRUTS_LOCALE = "struts.locale";

    /** Whether to use a Servlet request parameter workaround necessary for some versions of WebLogic */
    public static final String STRUTS_DISPATCHER_PARAMETERSWORKAROUND = "struts.dispatcher.parametersWorkaround";

    /** The org.apache.struts2.views.freemarker.FreemarkerManager implementation class */
    public static final String STRUTS_FREEMARKER_MANAGER_CLASSNAME = "struts.freemarker.manager.classname";

    /** org.apache.struts2.views.velocity.VelocityManager implementation class */
    public static final String STRUTS_VELOCITY_MANAGER_CLASSNAME = "struts.velocity.manager.classname";
    
    /** The Velocity configuration file path */
    public static final String STRUTS_VELOCITY_CONFIGFILE = "struts.velocity.configfile";
    
    /** The location of the Velocity toolbox */
    public static final String STRUTS_VELOCITY_TOOLBOXLOCATION = "struts.velocity.toolboxlocation";
    
    /** List of Velocity context names */
    public static final String STRUTS_VELOCITY_CONTEXTS = "struts.velocity.contexts";

    /** The directory containing UI templates */
    public static final String STRUTS_UI_TEMPLATEDIR = "struts.ui.templateDir";
    
    /** The default UI template theme */
    public static final String STRUTS_UI_THEME = "struts.ui.theme";

    /** The maximize size of a multipart request (file upload) */
    public static final String STRUTS_MULTIPART_MAXSIZE = "struts.multipart.maxSize";
    
    /** The directory to use for storing uploaded files */
    public static final String STRUTS_MULTIPART_SAVEDIR = "struts.multipart.saveDir";
    
    /** 
     * The org.apache.struts2.dispatcher.multipart.MultiPartRequest parser implementation 
     * for a multipart request (file upload) 
     */
    public static final String STRUTS_MULTIPART_PARSER = "struts.multipart.parser";

    /** Whether Spring should autoWire or not */
    public static final String STRUTS_OBJECTFACTORY_SPRING_AUTOWIRE = "struts.objectFactory.spring.autoWire";
    
    /** Whether Spring should use its class cache or not */
    public static final String STRUTS_OBJECTFACTORY_SPRING_USE_CLASS_CACHE = "struts.objectFactory.spring.useClassCache";

    /** Whether or not XSLT templates should not be cached */
    public static final String STRUTS_XSLT_NOCACHE = "struts.xslt.nocache";

    /** Location of additional configuration properties files to load */
    public static final String STRUTS_CUSTOM_PROPERTIES = "struts.custom.properties";
    
    /** Location of additional localization properties files to load */
    public static final String STRUTS_CUSTOM_I18N_RESOURCES = "struts.custom.i18n.resources";
    
    /** The org.apache.struts2.dispatcher.mapper.ActionMapper implementation class */
    public static final String STRUTS_MAPPER_CLASS = "struts.mapper.class";

    /** Whether the Struts filter should serve static content or not */
    public static final String STRUTS_SERVE_STATIC_CONTENT = "struts.serve.static";
    
    /** If static content served by the Struts filter should set browser caching header properties or not */
    public static final String STRUTS_SERVE_STATIC_BROWSER_CACHE = "struts.serve.static.browserCache";

    /** Allows one to disable dynamic method invocation from the URL */
    public static final String STRUTS_ENABLE_DYNAMIC_METHOD_INVOCATION = "struts.enable.DynamicMethodInvocation";
}
"
core/src/main/java/org/apache/struts2/StrutsException.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2;

import com.opensymphony.xwork2.XWorkException;
import com.opensymphony.xwork2.util.location.Locatable;


/**
 * A generic runtime exception that optionally contains Location information 
 */
public class StrutsException extends XWorkException implements Locatable {

    private static final long serialVersionUID = 888724366243600135L;


    /**
     * Constructs a <code>StrutsException</code> with no detail message.
     */
    public StrutsException() {
    }

    /**
     * Constructs a <code>StrutsException</code> with the specified
     * detail message.
     *
     * @param s the detail message.
     */
    public StrutsException(String s) {
        this(s, null, null);
    }
    
    /**
     * Constructs a <code>StrutsException</code> with the specified
     * detail message and target.
     *
     * @param s the detail message.
     * @param target the target of the exception.
     */
    public StrutsException(String s, Object target) {
        this(s, (Throwable) null, target);
    }

    /**
     * Constructs a <code>StrutsException</code> with the root cause
     *
     * @param cause The wrapped exception
     */
    public StrutsException(Throwable cause) {
        this(null, cause, null);
    }
    
    /**
     * Constructs a <code>StrutsException</code> with the root cause and target
     *
     * @param cause The wrapped exception
     * @param target The target of the exception
     */
    public StrutsException(Throwable cause, Object target) {
        this(null, cause, target);
    }

    /**
     * Constructs a <code>StrutsException</code> with the specified
     * detail message and exception cause.
     *
     * @param s the detail message.
     * @param cause the wrapped exception
     */
    public StrutsException(String s, Throwable cause) {
        this(s, cause, null);
    }
    
    
     /**
     * Constructs a <code>StrutsException</code> with the specified
     * detail message, cause, and target
     *
     * @param s the detail message.
     * @param cause The wrapped exception
     * @param target The target of the exception
     */
    public StrutsException(String s, Throwable cause, Object target) {
        super(s, cause, target);
    }
}"
core/src/main/java/org/apache/struts2/StrutsStatics.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2;


/**
 * Constants used by Struts. The constants can be used to get or set objects 
 * out of the action context or other collections.
 * 
 * <p/>
 * 
 * Example:
 * <ul><code>ActionContext.getContext().put(HTTP_REQUEST, request);</code></ul>
 * <p/>
 * or
 * <p/>
 * <ul><code>
 * ActionContext context = ActionContext.getContext();<br>
 * HttpServletRequest request = (HttpServletRequest)context.get(HTTP_REQUEST);</code></ul>
 */
public interface StrutsStatics {

    /**
     * Constant for the HTTP request object.
     */
    public static final String HTTP_REQUEST = "com.opensymphony.xwork2.dispatcher.HttpServletRequest";

    /**
     * Constant for the HTTP response object.
     */
    public static final String HTTP_RESPONSE = "com.opensymphony.xwork2.dispatcher.HttpServletResponse";

    /**
     * Constant for an HTTP {@link javax.servlet.RequestDispatcher request dispatcher}.
     */
    public static final String SERVLET_DISPATCHER = "com.opensymphony.xwork2.dispatcher.ServletDispatcher";

    /**
     * Constant for the {@link javax.servlet.ServletContext servlet context} object.
     */
    public static final String SERVLET_CONTEXT = "com.opensymphony.xwork2.dispatcher.ServletContext";

    /**
     * Constant for the JSP {@link javax.servlet.jsp.PageContext page context}.
     */
    public static final String PAGE_CONTEXT = "com.opensymphony.xwork2.dispatcher.PageContext";
    
    /** Constant for the PortletContext object */
    public static final String STRUTS_PORTLET_CONTEXT = "struts.portlet.context";
}
"
core/src/main/java/org/apache/struts2/StrutsTestCase.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2;

import org.apache.struts2.config.Settings;
import org.apache.struts2.config.StrutsXMLConfigurationProvider;
import org.apache.struts2.dispatcher.Dispatcher;
import org.springframework.mock.web.MockServletContext;

import com.opensymphony.xwork2.XWorkTestCase;
import com.opensymphony.xwork2.config.ConfigurationManager;
import com.opensymphony.xwork2.util.LocalizedTextUtil;

/**
 * Base test case for unit testing Struts.
 */
public abstract class StrutsTestCase extends XWorkTestCase {


    /**
     * Sets up the configuration settings, XWork configuration, and
     * message resources
     */
    protected void setUp() throws Exception {
        super.setUp();
        Settings.reset();
        LocalizedTextUtil.clearDefaultResourceBundles();
        Dispatcher du = new Dispatcher(new MockServletContext());
        Dispatcher.setInstance(du);
        configurationManager = new ConfigurationManager();
        configurationManager.addConfigurationProvider(
                new StrutsXMLConfigurationProvider("struts.xml", false));
        du.setConfigurationManager(configurationManager);
        
    }

    protected void tearDown() throws Exception {
        super.tearDown();
    }

}
"
core/src/main/java/org/apache/struts2/components/ActionComponent.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.io.IOException;
import java.io.Writer;
import java.util.HashMap;
import java.util.Map;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.jsp.PageContext;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.ServletActionContext;
import org.apache.struts2.StrutsException;
import org.apache.struts2.dispatcher.Dispatcher;
import org.apache.struts2.dispatcher.RequestMap;
import org.apache.struts2.views.jsp.TagUtils;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionProxy;
import com.opensymphony.xwork2.ActionProxyFactory;
import com.opensymphony.xwork2.config.Configuration;
import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * <p>This tag enables developers to call actions directly from a JSP page by specifying the action name and an optional
 * namespace.  The body content of the tag is used to render the results from the Action.  Any result processor defined
 * for this action in struts.xml will be ignored, <i>unless</i> the executeResult parameter is specified.</p>
 * <!-- END SNIPPET: javadoc -->
 *
 * <!-- START SNIPPET: params -->
 * <ul>
 *      <li>id (String) - the id (if specified) to put the action under stack's context.
 * 		<li>name* (String) - name of the action to be executed (without the extension suffix eg. .action)</li>
 * 		<li>namespace (String) - default to the namespace where this action tag is invoked</li>
 *      <li>executeResult (Boolean) -  default is false. Decides wheather the result of this action is to be executed or not</li>
 *      <li>ignoreContextParams (Boolean) - default to false. Decides wheather the request parameters are to be included when the action is invoked</li>
 * </ul>
 * <!-- END SNIPPET: params -->
 *
 * <pre>
 * <!-- START SNIPPET: javacode -->
 * public class ActionTagAction extends ActionSupport {
 *
 *	public String execute() throws Exception {
 *		return "done";
 *	}
 *
 *	public String doDefault() throws Exception {
 *		ServletActionContext.getRequest().setAttribute("stringByAction", "This is a String put in by the action's doDefault()");
 *		return "done";
 *	}
 * }
 * <!-- END SNIPPET: javacode -->
 * </pre>
 *
 * <pre>
 * <!-- START SNIPPET: strutsxml -->
 *   <xwork>
 *      ....
 *     <action name="actionTagAction1" class="tmjee.testing.ActionTagAction">
 *         <result name="done">success.jsp</result>
 *     </action>
 *      <action name="actionTagAction2" class="tmjee.testing.ActionTagAction" method="default">
 *         <result name="done">success.jsp</result>
 *     </action>
 *      ....
 *   </xwork>
 * <!-- END SNIPPET: strutsxml -->
 * </pre>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 *  <div>The following action tag will execute result and include it in this page</div>
 *	<br />
 *	<s:action name="actionTagAction" executeResult="true" />
 *  <br />
 *  <div>The following action tag will do the same as above, but invokes method specialMethod in action</div>
 *	<br />
 *	<s:action name="actionTagAction!specialMethod" executeResult="true" />
 *  <br />
 *  <div>The following action tag will not execute result, but put a String in request scope
 *       under an id "stringByAction" which will be retrieved using property tag</div>
 *  <s:action name="actionTagAction!default" executeResult="false" />
 *  <s:property value="#attr.stringByAction" />
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @s.tag name="action" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ActionTag"
 * description="Execute an action from within a view"
 */
public class ActionComponent extends Component {
    private static final Log LOG = LogFactory.getLog(ActionComponent.class);

    protected HttpServletResponse res;
    protected HttpServletRequest req;

    protected ActionProxy proxy;
    protected String name;
    protected String namespace;
    protected boolean executeResult;
    protected boolean ignoreContextParams;

    public ActionComponent(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack);
        this.req = req;
        this.res = res;
    }

    public boolean end(Writer writer, String body) {
    	boolean end = super.end(writer, "", false);
		try {
			try {
				writer.flush();
			} catch (IOException e) {
				LOG.warn("error while trying to flush writer ", e);
			}
			executeAction();

			if ((getId() != null) && (proxy != null)) {
				getStack().setValue("#attr['" + getId() + "']",
						proxy.getAction());
			}
		} finally {
			popComponentStack();
		}
        return end;
    }

    private Map createExtraContext() {
        Map parentParams = null;

        if (!ignoreContextParams) {
            parentParams = new ActionContext(getStack().getContext()).getParameters();
        }

        Map newParams = (parentParams != null) ? new HashMap(parentParams) : new HashMap();

        if (parameters != null) {
            newParams.putAll(parameters);
        }

        ActionContext ctx = new ActionContext(stack.getContext());
        ServletContext servletContext = (ServletContext) ctx.get(ServletActionContext.SERVLET_CONTEXT);
        PageContext pageContext = (PageContext) ctx.get(ServletActionContext.PAGE_CONTEXT);
        Map session = ctx.getSession();
        Map application = ctx.getApplication();

        Dispatcher du = Dispatcher.getInstance();
        Map extraContext = du.createContextMap(new RequestMap(req),
                newParams,
                session,
                application,
                req,
                res,
                servletContext);

        OgnlValueStack newStack = new OgnlValueStack(stack);
        extraContext.put(ActionContext.VALUE_STACK, newStack);

        // add page context, such that ServletDispatcherResult will do an include
        extraContext.put(ServletActionContext.PAGE_CONTEXT, pageContext);

        return extraContext;
    }

    public ActionProxy getProxy() {
        return proxy;
    }

    /**
     * Execute the requested action.  If no namespace is provided, we'll
     * attempt to derive a namespace using buildNamespace().  The ActionProxy
     * and the namespace will be saved into the instance variables proxy and
     * namespace respectively.
     *
     * @see org.apache.struts2.views.jsp.TagUtils#buildNamespace
     */
    private void executeAction() {
        String actualName = findString(name, "name", "Action name is required. Example: updatePerson");

        if (actualName == null) {
            throw new StrutsException("Unable to find value for name " + name);
        }

        // handle "name!method" convention.
        final String actionName;
        final String methodName;

        int exclamation = actualName.lastIndexOf("!");
        if (exclamation != -1) {
            actionName = actualName.substring(0, exclamation);
            methodName = actualName.substring(exclamation + 1);
        } else {
            actionName = actualName;
            methodName = null;
        }

        String namespace;

        if (this.namespace == null) {
            namespace = TagUtils.buildNamespace(getStack(), req);
        } else {
            namespace = findString(this.namespace);
        }

        // get the old value stack from the request
        OgnlValueStack stack = getStack();
        // execute at this point, after params have been set
        try {
            Configuration config = Dispatcher.getInstance().getConfigurationManager().getConfiguration();
            proxy = ActionProxyFactory.getFactory().createActionProxy(config, namespace, actionName, createExtraContext(), executeResult, true);
            if (null != methodName) {
                proxy.setMethod(methodName);
            }
            // set the new stack into the request for the taglib to use
            req.setAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY, proxy.getInvocation().getStack());
            proxy.execute();

        } catch (Exception e) {
            String message = "Could not execute action: " + namespace + "/" + actualName;
            LOG.error(message, e);
        } finally {
            // set the old stack back on the request
            req.setAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY, stack);
        }

        if ((getId() != null) && (proxy != null)) {
            final Map context = stack.getContext();
            context.put(getId(), proxy.getAction());
        }
    }

    /**
     * the id (if speficied) to put the action under stack's context.
     * @s.tagattribute required="false" type="String"
     */
    public void setId(String id) {
        super.setId(id);
    }

    /**
     * name of the action to be executed (without the extension suffix eg. .action)
     * @s.tagattribute required="true" type="String"
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * namespace for action to call
     * @s.tagattribute required="false" type="String" default="namespace from where tag is used"
     */
    public void setNamespace(String namespace) {
        this.namespace = namespace;
    }

    /**
     * whether the result of this action (probably a view) should be executed/rendered
     * @s.tagattribute required="false" type="Boolean" default="false"
     */
    public void setExecuteResult(boolean executeResult) {
        this.executeResult = executeResult;
    }

    /**
     * whether the request parameters are to be included when the action is invoked
     * @s.tagattribute required="false" type="Boolean" default="false"
     */
    public void setIgnoreContextParams(boolean ignoreContextParams) {
        this.ignoreContextParams = ignoreContextParams;
    }
}
"
core/src/main/java/org/apache/struts2/components/ActionError.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 *
 * Render action errors if they exists the specific layout of the rendering depends on
 * the theme itself.
 *
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 *
 *    &lt;s:actionerror /&gt;
 *    &lt;s:form .... &gt;>
 *       ....
 *    &lt;/s:form&gt;
 *
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @s.tag name="actionerror" tld-body-content="empty" tld-tag-class="org.apache.struts2.views.jsp.ui.ActionErrorTag"
 * description="Render action errors if they exists"
 */
public class ActionError extends UIBean {

    public static final String TEMPLATE = "actionerror";


    public ActionError(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }

}
"
core/src/main/java/org/apache/struts2/components/ActionMessage.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 *
 * Render action messages if they exists, specific rendering layout depends on the 
 * theme itself.
 *
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 *    &lt;s:actionmessage /&gt;
 *    &lt;s:form .... &gt;
 *       ....
 *    &lt;/s:form&gt;
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @s.tag name="actionmessage" tld-body-content="empty" tld-tag-class="org.apache.struts2.views.jsp.ui.ActionMessageTag"
 * description="Render action messages if they exists"
 */
public class ActionMessage extends UIBean {

    private static final String TEMPLATE = "actionmessage";

    public ActionMessage(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }
}
"
core/src/main/java/org/apache/struts2/components/Anchor.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 *
 * A tag that creates a HTML &lt;a href='' /&gt; that when clicked calls a URL remote XMLHttpRequest call via the dojo
 * framework. The result from the URL is executed as JavaScript. If a "listenTopics" is supplied, it will publish a
 * 'click' message to that topic when the result is returned.
 *
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 *
 * <pre>
 * <!-- START SNIPPET: example1 -->
 * &lt;s:a id="link1" theme="ajax" href="/DoIt.action" errorText="An error ocurred" showErrorTransportText="true"&gt;
 *     &lt;img border="none" src="&lt;%=request.getContextPath()%&gt;/images/delete.gif"/&gt;
 *     &lt;s:param name="id" value="1"/&gt;
 * &lt;/s:a&gt;
 * <!-- END SNIPPET: example1 -->
 * </pre>
 *
 * </p>
 *
 * <!-- START SNIPPET: exampledescription1 -->
 *
 * Results in
 *
 * <!-- END SNIPPET: exampledescription1 -->
 *
 * </p>
 *
 * <pre>
 * <!-- START SNIPPET: example2 -->
 * &lt;a dojoType="BindAnchor" evalResult="true" id="link1" href="/DoIt.action?id=1" errorHtml="An error ocurred"
 * showTransportError="true"&gt;&lt;/a&gt;
 * <!-- END SNIPPET: example2 -->
 * </pre>
 *
 * </p>
 *
 * <!-- START SNIPPET: exampledescription2 -->
 *
 * Here is an example that uses the postInvokeJS. This example is in altSyntax=true:
 *
 * <!-- END SNIPPET: exampledescription2 -->
 *
 * </p>
 *
 * <pre>
 * <!-- START SNIPPET: example3 -->
 * &lt;s:a id="test" theme="ajax" href="/simpeResult.action" preInvokeJS="confirm(\'You sure\')"&gt;
 * 	A
 * &lt;/s:a&gt;
 * <!-- END SNIPPET: example3 -->
 * </pre>
 *
 * @s.tag name="a" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.AnchorTag"
 * description="Render a HTML href element that when clicked calls a URL via remote XMLHttpRequest"
 * 
 */
public class Anchor extends RemoteCallUIBean {
    final public static String OPEN_TEMPLATE = "a";
    final public static String TEMPLATE = "a-close";
    final public static String COMPONENT_NAME = Anchor.class.getName();

    protected String notifyTopics;
    protected String preInvokeJS;

    public Anchor(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    public String getDefaultOpenTemplate() {
        return OPEN_TEMPLATE;
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }

    public void evaluateExtraParams() {
        super.evaluateExtraParams();

        if (notifyTopics != null) {
            addParameter("notifyTopics", findString(notifyTopics));
        }

        if (preInvokeJS != null) {
            addParameter("preInvokeJS", findString(preInvokeJS));
        }
    }

    /**
     * The id to assign the component
     * @s.tagattribute required="false" type="String"
     */
    public void setId(String id) {
        super.setId(id);
    }

    /**
     * Topic names to post an event to after the remote call has been made
     * @s.tagattribute required="false"
     */
    public void setNotifyTopics(String notifyTopics) {
        this.notifyTopics = notifyTopics;
    }

    /**
     * A javascript snippet that will be invoked prior to the execution of the target href. If provided must return true or false. True indicates to continue executing target, false says do not execute link target. Possible uses are for confirm dialogs.
     * @s.tagattribute required="false" type="String"
     */
    public void setPreInvokeJS(String preInvokeJS) {
        this.preInvokeJS = preInvokeJS;
    }
}
"
core/src/main/java/org/apache/struts2/components/AppendIterator.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.io.Writer;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.components.Param.UnnamedParametric;
import org.apache.struts2.util.AppendIteratorFilter;
import org.apache.struts2.util.MakeIterator;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * <p>Component for AppendIteratorTag, which jobs is to append iterators to form an
 * appended iterator whereby entries goes from one iterator to another after each
 * respective iterator is exhausted of entries.</p>
 *
 * <p>For example, if there are 3 iterator appended (each iterator has 3 entries),
 * the following will be how the appended iterator entries will be arranged:</p>
 *
 * <ol>
 * 		<li>First Entry of the First Iterator</li>
 * 		<li>Second Entry of the First Iterator</li>
 * 		<li>Third Entry of the First Iterator</li>
 *      <li>First Entry of the Second Iterator</li>
 *      <li>Second Entry of the Second Iterator</li>
 *      <li>Third Entry of the Second Iterator</li>
 *      <li>First Entry of the Third Iterator</li>
 *      <li>Second Entry of the Third Iterator</li>
 *      <li>Third Entry of the Third ITerator</li>
 * </ol>
 * <!-- END SNIPPET: javadoc -->
 *
 * <!-- START SNIPPET: params -->
 * <ul>
 * 		<li>id (String) - the id of which if supplied will have the resultant
 *                        appended iterator stored under in the stack's context</li>
 * </ul>
 * <!-- END SNIPPET: params -->
 *
 *
 * <!-- START SNIPPET: code -->
 * public class AppendIteratorTagAction extends ActionSupport {
 *
 *	private List myList1;
 *	private List myList2;
 *	private List myList3;
 *
 *
 *	public String execute() throws Exception {
 *
 *		myList1 = new ArrayList();
 *		myList1.add("1");
 *		myList1.add("2");
 *		myList1.add("3");
 *
 *		myList2 = new ArrayList();
 *		myList2.add("a");
 *		myList2.add("b");
 *		myList2.add("c");
 *
 *		myList3 = new ArrayList();
 *		myList3.add("A");
 *		myList3.add("B");
 *		myList3.add("C");
 *
 *		return "done";
 *	}
 *
 *	public List getMyList1() { return myList1; }
 *	public List getMyList2() { return myList2; }
 *	public List getMyList3() { return myList3; }
 *}
 * <!-- END SNIPPET: code -->
 *
 * <!-- START SNIPPET: example -->
 * &lt;s:append id="myAppendIterator"&gt;
 *		&lt;s:param value="%{myList1}" /&gt;
 *		&lt;s:param value="%{myList2}" /&gt;
 *		&lt;s:param value="%{myList3}" /&gt;
 * &lt;/s:append&gt;
 * &lt;s:iterator value="%{#myAppendIterator}"&gt;
 *		&lt;s:property /&gt;
 * &lt;/s:iterator&gt;
 * <!-- END SNIPPET: example -->
 *
 *
 * @see org.apache.struts2.util.AppendIteratorFilter
 * @see org.apache.struts2.views.jsp.iterator.AppendIteratorTag
 *
 * @s.tag name="append" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.iterator.AppendIteratorTag"
 * description="Append the values of a list of iterators to one iterator"
 */
public class AppendIterator extends Component implements UnnamedParametric {

	private static final Log _log = LogFactory.getLog(AppendIterator.class);
	
	private AppendIteratorFilter appendIteratorFilter= null;
	private List _parameters;
	
	public AppendIterator(OgnlValueStack stack) {
		super(stack);
	}
	
	public boolean start(Writer writer) {
		_parameters = new ArrayList();
		appendIteratorFilter = new AppendIteratorFilter();

        return super.start(writer);
    }
	
	public boolean end(Writer writer, String body) {
		
		for (Iterator paramEntries = _parameters.iterator(); paramEntries.hasNext(); ) {
				
			Object iteratorEntryObj = paramEntries.next();
			if (! MakeIterator.isIterable(iteratorEntryObj)) {
				_log.warn("param with value resolved as "+iteratorEntryObj+" cannot be make as iterator, it will be ignored and hence will not appear in the merged iterator");
				continue;
			}
			appendIteratorFilter.setSource(MakeIterator.convert(iteratorEntryObj));
		}
		
		appendIteratorFilter.execute();
		
		if (getId() != null && getId().length() > 0) {
			getStack().getContext().put(getId(), appendIteratorFilter);
		}
		
		appendIteratorFilter = null;

        return super.end(writer, body);
    }

	// UnnamedParametric implementation --------------------------------------
	public void addParameter(Object value) {
		_parameters.add(value);
	}

    /**
     * the id of which if supplied will have the resultant appended iterator stored under in the stack's context
     * @s.tagattribute required="false"
     */
    public void setId(String id) {
        super.setId(id);
    }
}


"
core/src/main/java/org/apache/struts2/components/Bean.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.io.Writer;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.opensymphony.xwork2.util.ClassLoaderUtil;
import com.opensymphony.xwork2.ObjectFactory;
import com.opensymphony.xwork2.util.OgnlUtil;
import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * <p>Instantiates a class that conforms to the JavaBeans specification. This tag has a body which can contain
 * a number of {@link Param} elements to set any mutator methods on that class.</p>
 * <p/>
 * <p>If the id attribute is set on the BeanTag, it will place the instantiated bean into the
 * stack's Context.</p>
 * <p/>
 * <!-- END SNIPPET: javadoc -->
 *
 *
 * <!-- START SNIPPET: params -->
 * <ul>
 * 		<li>id - the stack's context id (if supplied) that the created bean will be store under</li>
 * 		<li>name* - the class name of the bean to be instantiated (must respect JavaBean specification)</li>
 * </ul>
 * <!-- END SNIPPET: params -->
 *
 *
 * <p>Examples:</p>
 * <p/>
 * <pre>
 * <!-- START SNIPPET: examples -->
 * &lt;-- in freemarker form --&gt;
 * [@s.bean name="org.apache.struts2.example.counter.SimpleCounter" id="counter"]
 *   [s:param name="foo" value="BAR"/]
 *   The value of foo is : [s:property value="foo"/], when inside the bean tag.<br />
 * [/s:bean]
 *
 * &lt;-- in jsp form --&gt;
 * &lt;s:bean name="org.apache.struts2.example.counter.SimpleCounter" id="counter"&gt;
 * 	 &lt;s:param name="foo" value="BAR" /&gt;
 *   The value of foot is : &lt;s:property value="foo"/&gt;, when inside the bean tag &lt;br /&gt;
 * &lt;/s:bean&gt;
 * <!-- END SNIPPET: examples -->
 * </pre>
 * <p/>
 *
 * <!-- START SNIPPET: examplesdescription -->
 * <p>This example instantiates a bean called SimpleCounter and sets the foo property (setFoo('BAR')). The
 * SimpleCounter object is then pushed onto the Valuestack, which means that we can called its accessor methods (getFoo())
 * with the Property tag and get their values.</p>
 * <p/>
 * <p>In the above example, the id has been set to a value of <i>counter</i>. This means that the SimpleCounter class
 * will be placed into the stack's context. You can access the SimpleCounter class using a Struts tag:</p>
 * <p/>
 * <pre>
 * &lt;-- jsp form --&gt;
 * &lt;s:property value="#counter" /&gt;
 *
 * &lt;-- freemarker form --&gt;
 * [s:property value="#counter.foo"/]
 * </pre>
 * <p/>
 * <p>In the property tag example, the <i>#</i> tells Ognl to search the context for the SimpleCounter class which has
 * an id(key) of <i>counter</i></p>
 * <!-- END SNIPPET: examplesdescription -->
 *
 * @see Param
 *
 * @s.tag name="bean" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.BeanTag"
 * description="Instantiate a JavaBean and place it in the context."
 */
public class Bean extends Component {
    protected static Log log = LogFactory.getLog(Bean.class);

    protected Object bean;
    protected String name;

    public Bean(OgnlValueStack stack) {
        super(stack);
    }

    public boolean start(Writer writer) {
        boolean result = super.start(writer);

        OgnlValueStack stack = getStack();

        try {
            String beanName = findString(name, "name", "Bean name is required. Example: com.acme.FooBean");
            bean = ObjectFactory.getObjectFactory().buildBean(ClassLoaderUtil.loadClass(beanName, getClass()), stack.getContext());
        } catch (Exception e) {
            log.error("Could not instantiate bean", e);

            return false;
        }

        // push bean on stack
        stack.push(bean);

        // store for reference later
        if (getId() != null) {
            getStack().getContext().put(getId(), bean);
        }

        return result;
    }

    public boolean end(Writer writer, String body) {
        OgnlValueStack stack = getStack();
        stack.pop();

        return super.end(writer, body);
    }

    public void addParameter(String key, Object value) {
        OgnlUtil.setProperty(key, value, bean, getStack().getContext());
    }

    /**
     * the class name of the bean to be instantiated (must respect JavaBean specification)
     * @s.tagattribute required="true" type="String"
     */
    public void setName(String name) {
        this.name = name;
    }
}
"
core/src/main/java/org/apache/struts2/components/Checkbox.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * Renders an HTML input element of type checkbox, populated by the specified property from the OgnlValueStack.
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * JSP:
 * &lt;s:checkbox label="checkbox test" name="checkboxField1" value="aBoolean" fieldValue="true"/&gt;
 *
 * Velocity:
 * #tag( Checkbox "label=checkbox test" "name=checkboxField1" "value=aBoolean" )
 *
 * Resulting HTML (simple template, aBoolean == true):
 * &lt;input type="checkbox" name="checkboxField1" value="true" checked="checked" /&gt;
 *
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @s.tag name="checkbox" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.CheckboxTag"
 * description="Render a checkbox input field"
  */
public class Checkbox extends UIBean {
    final public static String TEMPLATE = "checkbox";

    protected String fieldValue;

    public Checkbox(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }

    protected void evaluateExtraParams() {
        if (fieldValue != null) {
            addParameter("fieldValue", findString(fieldValue));
        } else {
            addParameter("fieldValue", "true");
        }
    }

    protected Class getValueClassType() {
        return Boolean.class; // for checkboxes, everything needs to end up as a Boolean
    }

    /**
     * The actual HTML value attribute of the checkbox.
     * @s.tagattribute required="false" default="'true'"
     */
    public void setFieldValue(String fieldValue) {
        this.fieldValue = fieldValue;
    }

}
"
core/src/main/java/org/apache/struts2/components/CheckboxList.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 *
 * Creates a series of checkboxes from a list. Setup is like &lt;s:select /&gt; or &lt;s:radio /&gt;, but creates checkbox tags.
 *
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * &lt;s:checkboxlist name="foo" list="bar"/&gt;
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @s.tag name="checkboxlist" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.CheckboxListTag"
 * description="Render a list of checkboxes"
  */
public class CheckboxList extends ListUIBean {
    final public static String TEMPLATE = "checkboxlist";

    public CheckboxList(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }
}
"
core/src/main/java/org/apache/struts2/components/ClosingUIBean.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.io.Writer;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * ClosingUIBean is the standard superclass for UI components such as div etc.
 */
public abstract class ClosingUIBean extends UIBean {
    private static final Log LOG = LogFactory.getLog(ClosingUIBean.class);

    protected ClosingUIBean(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    String openTemplate;

    public abstract String getDefaultOpenTemplate();

    /**
     * Set template to use for opening the rendered html.
     * @s.tagattribute required="false"
     */
    public void setOpenTemplate(String openTemplate) {
        this.openTemplate = openTemplate;
    }

    public boolean start(Writer writer) {
        boolean result = super.start(writer);
        try {
            evaluateParams();

            mergeTemplate(writer, buildTemplateName(openTemplate, getDefaultOpenTemplate()));
        } catch (Exception e) {
            LOG.error("Could not open template", e);
            e.printStackTrace();
        }

        return result;
    }
}
"
core/src/main/java/org/apache/struts2/components/ComboBox.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.util.Collection;
import java.util.Iterator;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.util.MakeIterator;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * The combo box is basically an HTML INPUT of type text and HTML SELECT grouped together to give you a combo box
 * functionality. You can place text in the INPUT control by using the SELECT control or type it in directly in
 * the text field.<p/>
 *
 * In this example, the SELECT will be populated from id=year attribute. Counter is itself an Iterator. It will
 * span from first to last. The population is done via javascript, and requires that this tag be surrounded by a
 * &lt;form&gt;.<p/>
 *
 * Note that unlike the &lt;s:select/&gt; tag, there is no ability to define the individual &lt;option&gt; tags' id attribute
 * or content separately. Each of these is simply populated from the toString() method of the list item. Presumably
 * this is because the select box isn't intended to actually submit useful data, but to assist the user in filling
 * out the text field.<p/>
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * JSP:
 * &lt;-- Example One --&gt;
 * &lt;s:bean name="struts.util.Counter" id="year"&gt;
 *   &lt;s:param name="first" value="text('firstBirthYear')"/&gt;
 *   &lt;s:param name="last" value="2000"/&gt;
 *
 *   &lt;s:combobox label="Birth year" size="6" maxlength="4" name="birthYear" list="#year"/&gt;
 * &lt;/s:bean&gt;
 * 
 * &lt;-- Example Two --&gt;
 * <s:combobox
 *     label="My Favourite Fruit"
 *     name="myFavouriteFruit"
 *     list="{'apple','banana','grape','pear'}"
 *     headerKey="-1"
 *     headerValue="--- Please Select ---"
 *     emptyOption="true"
 *     value="banana" />
 *     
 * &lt;-- Example Two --&gt;
 * <s:combobox
 *    label="My Favourite Color"
 *    name="myFavouriteColor"
 *    list="#{'red':'red','green':'green','blue':'blue'}"
 *    headerKey="-1"
 *    headerValue="--- Please Select ---"
 *    emptyOption="true"
 *    value="green" />
 *
 * Velocity:
 * #tag( ComboBox "label=Birth year" "size=6" "maxlength=4" "name=birthYear" "list=#year" )
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @s.tag name="combobox" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.ComboBoxTag"
 * description="Widget that fills a text box from a select"
  */
public class ComboBox extends TextField {
    final public static String TEMPLATE = "combobox";

    protected String list;
    protected String listKey;
    protected String listValue;
    protected String headerKey;
    protected String headerValue;
    protected String emptyOption;
    

    public ComboBox(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }

    public void evaluateExtraParams() {
        super.evaluateExtraParams();

        Object value = findValue(list, "list", 
        		"You must specify a collection/array/map/enumeration/iterator. " +
                "Example: people or people.{name}");
        
        if (headerKey != null) {
        	addParameter("headerKey", findString(headerKey));
        }
        if (headerValue != null) {
        	addParameter("headerValue", findString(headerValue));
        }
        if (emptyOption != null) {
        	addParameter("emptyOption", findValue(emptyOption, Boolean.class));
        }
        
        if (value instanceof Collection) {
        	Collection tmp = (Collection) value;
        	addParameter("list", tmp);
        	if (listKey != null) {
        		addParameter("listKey", listKey);
        	}
        	if (listValue != null) {
        		addParameter("listValue", listValue);
        	}
        }
        else if (value instanceof Map) {
        	Map tmp = (Map) value;
        	addParameter("list", MakeIterator.convert(tmp));
        	addParameter("listKey", "key");
        	addParameter("listValue", "value");
        }
        else if (value.getClass().isArray()) {
        	Iterator i = MakeIterator.convert(value);
        	addParameter("list", i);
        	if (listKey != null) {
        		addParameter("listKey", listKey);
        	}
        	if (listValue != null) {
        		addParameter("listValue", listValue);
        	}
        }
        else {
        	Iterator i = MakeIterator.convert(value);
        	addParameter("list", i);
        	if (listKey != null) {
        		addParameter("listKey", listKey);
        	}
        	if (listValue != null) {
        		addParameter("listValue", listValue);
        	}
        }
    }

    /**
     * Iteratable source to populate from. If this is missing, the select widget is simply not displayed.
     * @s.tagattribute required="true"
      */
    public void setList(String list) {
        this.list = list;
    }

    /**
     * Decide if an empty option is to be inserted. Default false.
     * @s.tagattribute required="false"
     */
	public void setEmptyOption(String emptyOption) {
		this.emptyOption = emptyOption;
	}

	/**
	 * set the header key for the header option. 
	 * @s.tagattribute required="false"
	 */
	public void setHeaderKey(String headerKey) {
		this.headerKey = headerKey;
	}

	/**
	 * set the header value for the header option.
	 * @s.tagattribute required="false"
	 */
	public void setHeaderValue(String headerValue) {
		this.headerValue = headerValue;
	}

	/**
	 * set the key used to retrive the option key.
	 * @s.tagattribute required="false"
	 */
	public void setListKey(String listKey) {
		this.listKey = listKey;
	}

	/**
	 * set the value used to retrive the option value.
	 * @s.tagattribute required="false"
	 */
	public void setListValue(String listValue) {
		this.listValue = listValue;
	}
    
    
}
"
core/src/main/java/org/apache/struts2/components/Component.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.Writer;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Stack;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.StrutsException;
import org.apache.struts2.dispatcher.mapper.ActionMapper;
import org.apache.struts2.dispatcher.mapper.ActionMapperFactory;
import org.apache.struts2.dispatcher.mapper.ActionMapping;
import org.apache.struts2.util.FastByteArrayOutputStream;
import org.apache.struts2.views.jsp.TagUtils;
import org.apache.struts2.views.util.ContextUtil;
import org.apache.struts2.views.util.UrlHelper;

import com.opensymphony.xwork2.util.OgnlValueStack;
import com.opensymphony.xwork2.util.TextParseUtil;

/**
 * Base class to extend for UI components.
 * <p/>
 * This class is a good extension point when building reuseable UI components.
 *
 */
public class Component {
    public static final String COMPONENT_STACK = "__component_stack";

    protected OgnlValueStack stack;
    protected Map parameters;
    protected String id;

    /**
     * Constructor.
     *
     * @param stack  OGNL value stack.
     */
    public Component(OgnlValueStack stack) {
        this.stack = stack;
        this.parameters = new HashMap();
        getComponentStack().push(this);
    }

    /**
     * Get's the name of this component.
     * @return the name of this component.
     */
    private String getComponentName() {
        Class c = getClass();
        String name = c.getName();
        int dot = name.lastIndexOf('.');

        return name.substring(dot + 1).toLowerCase();
    }

    /**
     * Get's the OGNL value stack assoicated with this component.
     * @return the OGNL value stack assoicated with this component.
     */
    public OgnlValueStack getStack() {
        return stack;
    }

    /**
     * Get's the component stack of this component.
     * @return the component stack of this component, never <tt>null</tt>.
     */
    public Stack getComponentStack() {
        Stack componentStack = (Stack) stack.getContext().get(COMPONENT_STACK);
        if (componentStack == null) {
            componentStack = new Stack();
            stack.getContext().put(COMPONENT_STACK, componentStack);
        }
        return componentStack;
    }

    /**
     * Callback for the start tag of this component.
     * Should the body be evaluated?
     *
     * @param writer  the output writer.
     * @return true if the body should be evaluated
     */
    public boolean start(Writer writer) {
        return true;
    }

    /**
     * Callback for the end tag of this component.
     * Should the body be evaluated again?
     * <p/>
     * <b>NOTE:</b> will pop component stack.
     * @param writer  the output writer.
     * @param body    the rendered body.
     * @return true if the body should be evaluated again
     */
    public boolean end(Writer writer, String body) {
        return end(writer, body, true);
    }

    /**
     * Callback for the start tag of this component.
     * Should the body be evaluated again?
     * <p/>
     * <b>NOTE:</b> has a parameter to determine to pop the component stack.
     * @param writer  the output writer.
     * @param body    the rendered body.
     * @param popComponentStack  should the component stack be popped?
     * @return true if the body should be evaluated again
     */
    protected boolean end(Writer writer, String body, boolean popComponentStack) {
    	assert(body != null);

        try {
            writer.write(body);
        } catch (IOException e) {
            throw new StrutsException("IOError while writing the body: " + e.getMessage(), e);
        }
        if (popComponentStack) {
        	popComponentStack();
        }
        return false;
    }

    /**
     * Pops the component stack.
     */
    protected void popComponentStack() {
    	getComponentStack().pop();
    }

    /**
     * Finds the nearest ancestor of this component stack.
     * @param clazz the class to look for, or if assignable from.
     * @return  the component if found, <tt>null</tt> if not.
     */
    protected Component findAncestor(Class clazz) {
        Stack componentStack = getComponentStack();
        int currPosition = componentStack.search(this);
        if (currPosition >= 0) {
        	int start = componentStack.size() - currPosition - 1;

        	//for (int i = componentStack.size() - 2; i >= 0; i--) {
        	for (int i = start; i >=0; i--) {
            	Component component = (Component) componentStack.get(i);
            	if (clazz.isAssignableFrom(component.getClass()) && component != this) {
            		return component;
            	}
        	}
        }

        return null;
    }

    /**
     * Evaluates the OGNL stack to find a String value.
     * @param expr  OGNL expression.
     * @return  the String value found.
     */
    protected String findString(String expr) {
        return (String) findValue(expr, String.class);
    }

    /**
     * Evaluates the OGNL stack to find a String value.
     * <p/>
     * If the given expression is <tt>null</tt/> a error is logged and a <code>RuntimeException</code> is thrown
     * constructed with a messaged based on the given field and errorMsg paramter.
     *
     * @param expr  OGNL expression.
     * @param field   field name used when throwing <code>RuntimeException</code>.
     * @param errorMsg  error message used when throwing <code>RuntimeException</code>.
     * @return  the String value found.
     * @throws StrutsException is thrown in case of expression is <tt>null</tt>.
     */
    protected String findString(String expr, String field, String errorMsg) {
        if (expr == null) {
            throw fieldError(field, errorMsg, null);
        } else {
            return findString(expr);
        }
    }

    /**
     * Constructs?a <code>RuntimeException</code> based on the given information.
     * <p/>
     * A message is constructed and logged at ERROR level before being returned
     * as a <code>RuntimeException</code>.
     * @param field   field name used when throwing <code>RuntimeException</code>.
     * @param errorMsg  error message used when throwing <code>RuntimeException</code>.
     * @param e  the caused exception, can be <tt>null</tt>.
     * @return  the constructed <code>StrutsException</code>.
     */
    protected StrutsException fieldError(String field, String errorMsg, Exception e) {
        String msg = "tag '" + getComponentName() + "', field '" + field + ( id != null ?"', id '" + id:"") +
                ( parameters != null && parameters.containsKey("name")?"', name '" + parameters.get("name"):"") +
                "': " + errorMsg;
        throw new StrutsException(msg, e);
    }

    /**
     * Finds a value from the OGNL stack based on the given expression.
     * Will always evaluate <code>expr</code> against stack except when <code>expr</code>
     * is null. If altsyntax (%{...}) is applied, simply strip it off.
     *
     * @param expr  the expression. Returns <tt>null</tt> if expr is null.
     * @return the value, <tt>null</tt> if not found.
     */
    protected Object findValue(String expr) {
        if (expr == null) {
            return null;
        }

        if (altSyntax()) {
            // does the expression start with %{ and end with }? if so, just cut it off!
            if (expr.startsWith("%{") && expr.endsWith("}")) {
                expr = expr.substring(2, expr.length() - 1);
            }
        }

        return getStack().findValue(expr);
    }

    /**
     * Is the altSyntax enabled? [TRUE]
     * <p/>
     * See <code>struts.properties</code> where the altSyntax flag is defined.
     */
    public boolean altSyntax() {
        return ContextUtil.isUseAltSyntax(stack.getContext());
    }

    /**
     * Evaluates the OGNL stack to find an Object value.
     * <p/>
     * Function just like <code>findValue(String)</code> except that if the
     * given expression is <tt>null</tt/> a error is logged and
     * a <code>RuntimeException</code> is thrown constructed with a
     * messaged based on the given field and errorMsg paramter.
     *
     * @param expr  OGNL expression.
     * @param field   field name used when throwing <code>RuntimeException</code>.
     * @param errorMsg  error message used when throwing <code>RuntimeException</code>.
     * @return  the Object found, is never <tt>null</tt>.
     * @throws StrutsException is thrown in case of not found in the OGNL stack, or expression is <tt>null</tt>.
     */
    protected Object findValue(String expr, String field, String errorMsg) {
        if (expr == null) {
            throw fieldError(field, errorMsg, null);
        } else {
            Object value = null;
            Exception problem = null;
            try {
                value = findValue(expr);
            } catch (Exception e) {
                problem = e;
            }

            if (value == null) {
                throw fieldError(field, errorMsg, problem);
            }

            return value;
        }
    }

    /**
     * Evaluates the OGNL stack to find an Object of the given type. Will evaluate
     * <code>expr</code> the portion wrapped with altSyntax (%{...})
     * against stack when altSyntax is on, else the whole <code>expr</code>
     * is evaluated against the stack.
     * <p/>
     * This method only supports the altSyntax. So this should be set to true.
     * @param expr  OGNL expression.
     * @param toType  the type expected to find.
     * @return  the Object found, or <tt>null</tt> if not found.
     */
    protected Object findValue(String expr, Class toType) {
        if (altSyntax() && toType == String.class) {
            return TextParseUtil.translateVariables('%', expr, stack);
        } else {
            if (altSyntax()) {
                // does the expression start with %{ and end with }? if so, just cut it off!
                if (expr.startsWith("%{") && expr.endsWith("}")) {
                    expr = expr.substring(2, expr.length() - 1);
                }
            }

            return getStack().findValue(expr, toType);
        }
    }

    /**
     * Renders an action URL by consulting the {@link org.apache.struts2.dispatcher.mapper.ActionMapper}.
     * @param action      the action
     * @param namespace   the namespace
     * @param method      the method
     * @param req         HTTP request
     * @param res         HTTP response
     * @param parameters  parameters
     * @param scheme      http or https
     * @param includeContext  should the context path be included or not
     * @param encodeResult    should the url be encoded
     * @return the action url.
     */
    protected String determineActionURL(String action, String namespace, String method,
                                        HttpServletRequest req, HttpServletResponse res, Map parameters, String scheme,
                                        boolean includeContext, boolean encodeResult) {
        String finalAction = findString(action);
        String finalNamespace = determineNamespace(namespace, getStack(), req);
        ActionMapping mapping = new ActionMapping(finalAction, finalNamespace, method, parameters);
        ActionMapper mapper = ActionMapperFactory.getMapper();
        String uri = mapper.getUriFromActionMapping(mapping);
        return UrlHelper.buildUrl(uri, req, res, parameters, scheme, includeContext, encodeResult);
    }

    /**
     * Determines the namespace of the current page being renderdd. Useful for Form, URL, and href generations.
     * @param namespace  the namespace
     * @param stack      OGNL value stack
     * @param req        HTTP request
     * @return  the namepsace of the current page being rendered, is never <tt>null</tt>.
     */
    protected String determineNamespace(String namespace, OgnlValueStack stack, HttpServletRequest req) {
        String result;

        if (namespace == null) {
            result = TagUtils.buildNamespace(stack, req);
        } else {
            result = findString(namespace);
        }

        if (result == null) {
            result = "";
        }

        return result;
    }

    /**
     * Pushes this component's parameter Map as well as the component itself on to the stack
     * and then copies the supplied parameters over. Because the component's parameter Map is
     * pushed before the component itself, any key-value pair that can't be assigned to componet
     * will be set in the parameters Map.
     *
     * @param params  the parameters to copy.
     */
    public void copyParams(Map params) {
        stack.push(parameters);
        stack.push(this);
        try {
            for (Iterator iterator = params.entrySet().iterator(); iterator.hasNext();) {
                Map.Entry entry = (Map.Entry) iterator.next();
                String key = (String) entry.getKey();
                stack.setValue(key, entry.getValue());
            }
        } finally {
            stack.pop();
            stack.pop();
        }
    }

    /**
     * Constructs a string representation of the given exception.
     * @param t  the exception
     * @return the exception as a string.
     */
    protected String toString(Throwable t) {
        FastByteArrayOutputStream bout = new FastByteArrayOutputStream();
        PrintWriter wrt = new PrintWriter(bout);
        t.printStackTrace(wrt);
        wrt.close();

        return bout.toString();
    }

    /**
     * Get's the parameters.
     * @return the parameters. Is never <tt>null</tt>.
     */
    public Map getParameters() {
        return parameters;
    }

    /**
     * Add's all the given parameters to this componenets own parameters.
     * @param params the parameters to add.
     */
    public void addAllParameters(Map params) {
        parameters.putAll(params);
    }

    /**
     * Add's the given key and value to this components own parameter.
     * <p/>
     * If the provided key is <tt>null</tt> nothing happends.
     * If the provided value is <tt>null</tt> any existing parameter with
     * the given key name is removed.
     * @param key  the key of the new parameter to add.
     * @param value the value assoicated with the key.
     */
    public void addParameter(String key, Object value) {
        if (key != null) {
            Map params = getParameters();

            if (value == null) {
                params.remove(key);
            } else {
                params.put(key, value);
            }
        }
    }

    /**
     * Get's the id for referencing element.
     * @return the id for referencing element.
     */
    public String getId() {
        return id;
    }

    /**
     * id for referencing element. For UI and form tags it will be used as HTML id attribute
     * @s.tagattribute required="false"
     */
    public void setId(String id) {
    	if (id != null) {
    		this.id = findString(id);
    	}
    }

    /**
     * Overwrite to set if body shold be used.
     * @return always false for this component.
     */
    public boolean usesBody() {
        return false;
    }

}
"
core/src/main/java/org/apache/struts2/components/Date.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.io.IOException;
import java.io.Writer;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.TextProvider;
import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * 
 * Format Date object in different ways.
 * <p>
 * The date tag will allow you to format a Date in a quick and easy way.
 * You can specify a <b>custom format</b> (eg. "dd/MM/yyyy hh:mm"), you can generate
 * <b>easy readable notations</b> (like "in 2 hours, 14 minutes"), or you can just fall back
 * on a <b>predefined format</b> with key 'struts.date.format' in your properties file.
 *
 * If that key is not defined, it will finally fall back to the default DateFormat.MEDIUM
 * formatting.
 *
 * <b>Note</b>: If the requested Date object isn't found on the stack, a blank will be returned.
 * </p>
 * 
 * Configurable attributes are :-
 * <ul>
 *    <li>name</li>
 *    <li>nice</li>
 *    <li>format</li>
 * </ul>
 * 
 * <p/>
 * 
 * Following how the date component will work, depending on the value of nice attribute 
 * (which by default is false) and the format attribute.
 * 
 * <p/>
 * 
 * <b><u>Condition 1: With nice attribute as true</u></b>
 * <table border="1">
 *   <tr>
 *      <td>i18n key</td>
 *      <td>default</td>
 *   </tr>	
 *   <tr>
 *   	<td>struts.date.format.past</td>
 *   	<td>{0} ago</td>
 *   </tr>
 *   <tr>
 *   	<td>struts.date.format.future</td>
 *      <td>in {0}</td>
 *   </tr>
 *   <tr>
 *   	<td>struts.date.format.seconds</td>
 *      <td>an instant</td>
 *   </tr>
 *   <tr>
 *   	<td>struts.date.format.minutes</td>
 *      <td>{0,choice,1#one minute|1<{0} minutes}</td>
 *   </tr>
 *   <tr>
 *   	<td>struts.date.format.hours</td>
 *   	<td>{0,choice,1#one hour|1<{0} hours}{1,choice,0#|1#, one minute|1<, {1} minutes}</td>
 *   </tr>
 *   <tr>
 *   	<td>struts.date.format.days</td>
 *   	<td>{0,choice,1#one day|1<{0} days}{1,choice,0#|1#, one hour|1<, {1} hours}</td>
 *   </tr>
 *   <tr>
 *   	<td>struts.date.format.years</td>
 *   	<td>{0,choice,1#one year|1<{0} years}{1,choice,0#|1#, one day|1<, {1} days}</td>
 *   </tr>
 * </table>
 * 
 * <p/>
 * 
 * <b><u>Condition 2: With nice attribute as false and format attribute is specified eg. dd/MM/yyyyy </u></b>
 * <p>In this case the format attribute will be used.</p>
 * 
 * <p/>
 * 
 * <b><u>Condition 3: With nice attribute as false and no format attribute is specified </u></b>
 * <table border="1">
 *    <tr>
 *      <td>i18n key</td>
 *      <td>default</td>
 *   </tr>	
 *   <tr>
 *   	<td>struts.date.format</td>
 *      <td>if one is not found DateFormat.MEDIUM format will be used</td>
 *   </tr>
 * </table>
 * 
 * 
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 * <pre>
 *  <!-- START SNIPPET: example -->
 *  &lt;s:date name="person.birthday" format="dd/MM/yyyy" /&gt;
 *  &lt;s:date name="person.birthday" format="%{getText('some.i18n.key')}" /&gt;
 *  &lt;s:date name="person.birthday" nice="true" /&gt;
 *  &lt;s:date name="person.birthday" /&gt;
 *  <!-- END SNIPPET: example -->
 * </pre>
 *
 * <code>Date</code>
 *
 * @s.tag name="date" tld-body-content="empty"
 *         tld-tag-class="org.apache.struts2.views.jsp.DateTag"
 *         description="Render a formatted date."
 */
public class Date extends Component {

    private static final Log LOG = LogFactory.getLog(Date.class);
    /**
     * Property name to fall back when no format is specified
     */
    public static final String DATETAG_PROPERTY = "struts.date.format";
    /**
     * Property name that defines the past notation (default: {0} ago)
     */
    public static final String DATETAG_PROPERTY_PAST = "struts.date.format.past";
    private static final String DATETAG_DEFAULT_PAST = "{0} ago";
    /**
     * Property name that defines the future notation (default: in {0})
     */
    public static final String DATETAG_PROPERTY_FUTURE = "struts.date.format.future";
    private static final String DATETAG_DEFAULT_FUTURE = "in {0}";
    /**
     * Property name that defines the seconds notation (default: in instant)
     */
    public static final String DATETAG_PROPERTY_SECONDS = "struts.date.format.seconds";
    private static final String DATETAG_DEFAULT_SECONDS = "an instant";
    /**
     * Property name that defines the minutes notation (default: {0,choice,1#one minute|1<{0} minutes})
     */
    public static final String DATETAG_PROPERTY_MINUTES = "struts.date.format.minutes";
    private static final String DATETAG_DEFAULT_MINUTES = "{0,choice,1#one minute|1<{0} minutes}";
    /**
     * Property name that defines the hours notation (default: {0,choice,1#one hour|1<{0} hours}{1,choice,0#|1#, one
     * minute|1<, {1} minutes})
     */
    public static final String DATETAG_PROPERTY_HOURS = "struts.date.format.hours";
    private static final String DATETAG_DEFAULT_HOURS = "{0,choice,1#one hour|1<{0} hours}{1,choice,0#|1#, one minute|1<, {1} minutes}";
    /**
     * Property name that defines the days notation (default: {0,choice,1#one day|1<{0} days}{1,choice,0#|1#, one hour|1<,
     * {1} hours})
     */
    public static final String DATETAG_PROPERTY_DAYS = "struts.date.format.days";
    private static final String DATETAG_DEFAULT_DAYS = "{0,choice,1#one day|1<{0} days}{1,choice,0#|1#, one hour|1<, {1} hours}";
    /**
     * Property name that defines the years notation (default: {0,choice,1#one year|1<{0} years}{1,choice,0#|1#, one
     * day|1<, {1} days})
     */
    public static final String DATETAG_PROPERTY_YEARS = "struts.date.format.years";
    private static final String DATETAG_DEFAULT_YEARS = "{0,choice,1#one year|1<{0} years}{1,choice,0#|1#, one day|1<, {1} days}";

    private String name;

    private String format;

    private boolean nice;

    public Date(OgnlValueStack stack) {
        super(stack);
    }

    private TextProvider findProviderInStack() {
        for (Iterator iterator = getStack().getRoot().iterator(); iterator
                .hasNext();) {
            Object o = iterator.next();

            if (o instanceof TextProvider) {
                return (TextProvider) o;
            }
        }
        return null;
    }

    /**
     * Calculates the difference in time from now to the given date, and outputs it nicely. <p/> An example: <br/>Now =
     * 2006/03/12 13:38:00, date = 2006/03/12 15:50:00 will output "in 1 hour, 12 minutes".
     *
     * @param tp   text provider
     * @param date the date
     * @return the date nicely
     */
    public String formatTime(TextProvider tp, java.util.Date date) {
        java.util.Date now = new java.util.Date();
        StringBuffer sb = new StringBuffer();
        List args = new ArrayList();
        long secs = Math.abs((now.getTime() - date.getTime()) / 1000);
        long mins = secs / 60;
        long sec = secs % 60;
        int min = (int) mins % 60;
        long hours = mins / 60;
        int hour = (int) hours % 24;
        int days = (int) hours / 24;
        int day = days % 365;
        int years = days / 365;

        if (years > 0) {
            args.add(new Long(years));
            args.add(new Long(day));
            args.add(sb);
            args.add(null);
            sb.append(tp.getText(DATETAG_PROPERTY_YEARS, DATETAG_DEFAULT_YEARS, args));
        } else if (day > 0) {
            args.add(new Long(day));
            args.add(new Long(hour));
            args.add(sb);
            args.add(null);
            sb.append(tp.getText(DATETAG_PROPERTY_DAYS, DATETAG_DEFAULT_DAYS, args));
        } else if (hour > 0) {
            args.add(new Long(hour));
            args.add(new Long(min));
            args.add(sb);
            args.add(null);
            sb.append(tp.getText(DATETAG_PROPERTY_HOURS, DATETAG_DEFAULT_HOURS, args));
        } else if (min > 0) {
            args.add(new Long(min));
            args.add(new Long(sec));
            args.add(sb);
            args.add(null);
            sb.append(tp.getText(DATETAG_PROPERTY_MINUTES, DATETAG_DEFAULT_MINUTES, args));
        } else {
            args.add(new Long(sec));
            args.add(sb);
            args.add(null);
            sb.append(tp.getText(DATETAG_PROPERTY_SECONDS, DATETAG_DEFAULT_SECONDS, args));
        }

        args.clear();
        args.add(sb.toString());
        if (date.before(now)) {
            // looks like this date is passed
            return tp.getText(DATETAG_PROPERTY_PAST, DATETAG_DEFAULT_PAST, args);
        } else {
            return tp.getText(DATETAG_PROPERTY_FUTURE, DATETAG_DEFAULT_FUTURE, args);
        }
    }

    public boolean end(Writer writer, String body) {
        String msg = null;
        OgnlValueStack stack = getStack();
        java.util.Date date = null;
        // find the name on the valueStack, and cast it to a date
        try {
            date = (java.util.Date) findValue(name);
        } catch (Exception e) {
            LOG.error("Could not convert object with key '" + name
                    + "' to a java.util.Date instance");
            // bad date, return a blank instead ?
            msg = "";
        }

        //try to find the format on the stack
        if (format != null) {
            format = findString(format);
        }
        if (date != null) {
            TextProvider tp = findProviderInStack();
            if (tp != null) {
                if (nice) {
                    msg = formatTime(tp, date);
                } else {
                    if (format == null) {
                        String globalFormat = null;

                        // if the format is not specified, fall back using the
                        // defined property DATETAG_PROPERTY
                        globalFormat = tp.getText(DATETAG_PROPERTY);

                        // if tp.getText can not find the property then the
                        // returned string is the same as input =
                        // DATETAG_PROPERTY
                        if (globalFormat != null
                                && !DATETAG_PROPERTY.equals(globalFormat)) {
                            msg = new SimpleDateFormat(globalFormat,
                                    ActionContext.getContext().getLocale())
                                    .format(date);
                        } else {
                            msg = DateFormat.getDateTimeInstance(
                                    DateFormat.MEDIUM, DateFormat.MEDIUM,
                                    ActionContext.getContext().getLocale())
                                    .format(date);
                        }
                    } else {
                        msg = new SimpleDateFormat(format, ActionContext
                                .getContext().getLocale()).format(date);
                    }
                }
                if (msg != null) {
                    try {
                        if (getId() == null) {
                            writer.write(msg);
                        } else {
                            stack.getContext().put(getId(), msg);
                        }
                    } catch (IOException e) {
                        LOG.error("Could not write out Date tag", e);
                    }
                }
            }
        }
        return super.end(writer, "");
    }

    /**
     * Date or DateTime format pattern
     *
     * @s.tagattribute required="false" rtexprvalue="false"
     */
    public void setFormat(String format) {
        this.format = format;
    }

    /**
     * Whether to print out the date nicely
     *
     * @s.tagattribute required="false" type="Boolean" default="false"
     */
    public void setNice(boolean nice) {
        this.nice = nice;
    }

    /**
     * @return Returns the name.
     */
    public String getName() {
        return name;
    }

    /**
     * The date value to format
     *
     * @s.tagattribute required="true" type="String"
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * @return Returns the format.
     */
    public String getFormat() {
        return format;
    }

    /**
     * @return Returns the nice.
     */
    public boolean isNice() {
        return nice;
	}
}
"
core/src/main/java/org/apache/struts2/components/DatePicker.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 *
 * Renders datepicker element.</p>
 * Format supported by this component are:-
 * <table border="1">
 *   <tr>
 *   	<td>Format</td>
 *    	<td>Description</td>
 *   </tr>
 *   <tr>
 *   	<td>#dd</td>
 *   	<td>Display day in two digits format</td>
 *   </tr>	
 *   <tr>
 *   	<td>#d</td>
 *   	<td>Try to display day in one digit format, if cannot use 2 digit format</td>
 *   </tr>
 *   <tr>
 *   	<td>#MM</td>
 *      <td>Display month in two digits format</td>
 *   </tr>
 *   <tr>
 *   	<td>#M</td>
 *   	<td>Try to display month in one digits format, if cannot use 2 digit format</td>
 *   </tr>
 *   <tr>
 *   	<td>#yyyy</td>
 *      <td>Display year in four digits format</td>
 *   </tr>
 *   <tr>
 *   	<td>#yy</td>
 *      <td>Display the last two digits of the yaer</td>
 *   </tr>
 *   <tr>
 *   	<td>#y</td>
 *      <td>Display the last digits of the year</td>
 *   </tr>
 * </table>
 *
 * <p/>
 *
 * <!-- END SNIPPET: javadoc -->
 *
 * <b>Examples</b>
 *
 * <pre>
 * <!-- START SNIPPET: expl1 -->
 *
 * Example 1:
 *     &lt;s:datepicker name="order.date" label="Order Date" /&gt;
 * Example 2:
 *     &lt;s:datepicker name="delivery.date" label="Delivery Date" format="#yyyy-#MM-#dd"  /&gt;
 *     
 * <!-- END SNIPPET: expl1 -->
 * </pre>
 * <p/>
 *
 * <!-- START SNIPPET: expldesc2 -->
 *
 * The css could be changed by using the following :-
 *
 * <!-- END SNIPPET: expldesc2 -->
 * 
 * <pre>
 * <!-- START SNIPPET: expl2 -->
 * 
 * &lt;s:datepicker name="birthday" label="Birthday" templateCss="...." /&gt;
 * 
 * <!-- END SNIPPET: expl2 -->
 * </pre>
 *
 * @s.tag name="datepicker" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.DatePickerTag"
 * description="Render datepicker"
 */
public class DatePicker extends TextField {

    final public static String TEMPLATE = "datepicker";

    protected String format;
    protected String dateIconPath;
    protected String templatePath;
    protected String templateCssPath;
    protected String size;

    public DatePicker(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }

    public void evaluateParams() {
        super.evaluateParams();

        if (format != null) {
            addParameter("format", findString(format));
        }
        if (dateIconPath != null) {
        	addParameter("dateIconPath", dateIconPath);
        }
        if (templatePath != null) {
        	addParameter("templatePath", templatePath);
        }
        if (templateCssPath != null) {
        	addParameter("templateCssPath", templateCssPath);
        }
        if (size != null) {
        	addParameter("size", findValue(size, Integer.class));
        }
    }

    /**
     * The format to use for date field.
     * @s.tagattribute required="false" type="String" default="Dateformat specified by language preset (%Y/%m/%d for en)"
     */
    public void setFormat(String format) {
        this.format = format;
    }
    
    /**
     * The date picker icon path
     * @s.tagattribute required="false" type="String" default="/struts/dojo/struts/widgets/dateIcon.gif"
     */
    public void setDateIconPath(String dateIconPath) {
    	this.dateIconPath = dateIconPath;
    }
    
    /**
     * The datepicker template path.
     * @s.tagattribute required="false" type="String"
     */
    public void setTemplatePath(String templatePath) {
    	this.templatePath = templatePath;
    }
    
    /**
     * The datepicker template css path.
     * @s.tagattribute required="false" type="String"
     */
    public void setTemplateCssPath(String templateCssPath) {
    	this.templateCssPath = templateCssPath;
    }
    
    /**
     * The datepicker text field size.
     * @s.tagattribute required="false" type="String"
     */
    public void setSize(String size) {
    	this.size = size;
    }
}
"
core/src/main/java/org/apache/struts2/components/Debug.java,false,"package org.apache.struts2.components;

import java.io.Writer;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.StrutsException;

import com.opensymphony.xwork2.util.OgnlUtil;
import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * <p>Renders an debug tag.</P>
 *
 * The debug information contain mostly stack information:
 * <ul>
 *    <li>Value Stack Contents</li>
 *    <li>Stack Context</li>
 * </ul>
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * &lt;ww:debug/&gt;
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @s.tag name="debug" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.DebugTag"
 * description="Render debug tag"
  */
public class Debug extends UIBean {
    public static final String TEMPLATE = "debug";

    public Debug(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }

    public boolean start(Writer writer) {
        boolean result = super.start(writer);

        OgnlValueStack stack = getStack();
        Iterator iter = stack.getRoot().iterator();
        List stackValues = new ArrayList(stack.getRoot().size());
        while (iter.hasNext()) {
            Object o = iter.next();
            Map values;
            try {
                values = OgnlUtil.getBeanMap(o);
            } catch (Exception e) {
                throw new StrutsException("Caught an exception while getting the property values of " + o, e);
            }
            stackValues.add(new DebugMapEntry(o.getClass().getName(), values));
        }

        addParameter("stackValues", stackValues);

        return result;
    }

    private class DebugMapEntry implements Map.Entry {
        private Object key;
        private Object value;

        DebugMapEntry(Object key, Object value) {
            this.key = key;
            this.value = value;
        }

        public Object getKey() {
            return key;
        }

        public Object getValue() {
            return value;
        }

        public Object setValue(Object newVal) {
            Object oldVal = value;
            value = newVal;
            return oldVal;
        }
    }

}
"
core/src/main/java/org/apache/struts2/components/Div.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.views.util.UrlHelper;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * The div tag is primarily an AJAX tag, providing a remote call from the current page to update a section
 * of content without having to refresh the entire page.<p/>
 *
 * It creates a HTML &lt;DIV /&gt; that obtains it's content via a remote XMLHttpRequest call
 * via the dojo framework.<p/>
 *
 * If a "listenTopics" is supplied, it will listen to that topic and refresh it's content when any message
 * is received.<p/>
 * <!-- END SNIPPET: javadoc -->
 *
 * <b>Important:</b> Be sure to setup the page containing this tag to be Configured for AJAX</p>
 *
 * <p/> <b>Examples</b>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * &lt;s:div ... /&gt;
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @s.tag name="div" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.DivTag"
 * description="Render HTML div providing content from remote call via AJAX"
  */
public class Div extends RemoteCallUIBean {
	
	private static final Log _log = LogFactory.getLog(Div.class);
	

    public static final String TEMPLATE = "div";
    public static final String TEMPLATE_CLOSE = "div-close";
    public static final String COMPONENT_NAME = Div.class.getName();

    protected String updateFreq;
    protected String delay;
    protected String loadingText;
    protected String listenTopics;

    public Div(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    public String getDefaultOpenTemplate() {
        return TEMPLATE;
    }

    protected String getDefaultTemplate() {
        return TEMPLATE_CLOSE;
    }

    public void evaluateExtraParams() {
        super.evaluateExtraParams();

        if (null != updateFreq && !"".equals(updateFreq)) {
            addParameter("updateFreq", findString(updateFreq));
        } else {
            addParameter("updateFreq", "0");
        }

        if (null != delay && !"".equals(delay)) {
            addParameter("delay", findString(delay));
        } else {
            addParameter("delay", "0");
        }
        
        String tmpUpdateFreq = (String) getParameters().get("delay");
        String tmpDelay = (String) getParameters().get("updateFreq");
        try {
        	int _updateFreq = Integer.parseInt(tmpUpdateFreq);
        	int _delay = Integer.parseInt(tmpDelay);
        	
        	if (_updateFreq <= 0 && _delay <= 0) {
        		addParameter("autoStart", "false");
        	}
        }
        catch(NumberFormatException e) {
        	// too bad, invalid updateFreq or delay provided, we
        	// can't determine autoStart mode.
        	_log.info("error while parsing updateFreq ["+tmpUpdateFreq+"] or delay ["+tmpDelay+"] to integer, cannot determine autoStart mode", e);
        }

        if (loadingText != null) {
            addParameter("loadingText", findString(loadingText));
        }

        if (listenTopics != null) {
            addParameter("listenTopics", findString(listenTopics));
        }

        if (href != null) {

            // This is needed for portal and DOJO ajax stuff!
            addParameter("href", null);
            addParameter("href", UrlHelper.buildUrl(findString(href), request, response, null));
        }
    }

    /**
     * How often to re-fetch the content (in milliseconds)
     * @s.tagattribute required="false" type="Integer" default="0"
     */
    public void setUpdateFreq(String updateFreq) {
        this.updateFreq = updateFreq;
    }

    /**
     * How long to wait before fetching the content (in milliseconds)
     * @s.tagattribute required="false" type="Integer" default="0"
     */
    public void setDelay(String delay) {
        this.delay = delay;
    }

    /**
     * The text to display to the user while the new content is being fetched (especially good if the content will take awhile)
     * @s.tagattribute required="false" rtexprvalue="true"
     */
    public void setLoadingText(String loadingText) {
        this.loadingText = loadingText;
    }

    /**
     * Topic name to listen to (comma delimited), that will cause the DIV's content to be re-fetched
     * @s.tagattribute required="false"
     */
    public void setListenTopics(String listenTopics) {
        this.listenTopics = listenTopics;
    }

}
"
core/src/main/java/org/apache/struts2/components/DoubleListUIBean.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * DoubleListUIBean is the standard superclass of all Struts double list handling components.
 *
 * <p/>
 *
 * <!-- START SNIPPET: javadoc -->
 * 
 * Note that the doublelistkey and doublelistvalue attribute will default to "key" and "value"
 * respectively only when the doublelist attribute is evaluated to a Map or its decendant.
 * Other thing else, will result in doublelistkey and doublelistvalue to be null and not used.
 * 
 * <!-- END SNIPPET: javadoc -->
 *
 */
public abstract class DoubleListUIBean extends ListUIBean {
	
	protected String emptyOption;
    protected String headerKey;
    protected String headerValue;
    protected String multiple;
    protected String size;
	
    protected String doubleList;
    protected String doubleListKey;
    protected String doubleListValue;
    protected String doubleName;
    protected String doubleValue;
    protected String formName;
    
    protected String doubleId;
    protected String doubleDisabled;
    protected String doubleMultiple;
    protected String doubleSize;
    protected String doubleHeaderKey;
    protected String doubleHeaderValue;
    protected String doubleEmptyOption;
    
    protected String doubleCssClass;
    protected String doubleCssStyle;
    
    protected String doubleOnclick;
    protected String doubleOndblclick;
    protected String doubleOnmousedown;
    protected String doubleOnmouseup;
    protected String doubleOnmouseover;
    protected String doubleOnmousemove;
    protected String doubleOnmouseout;
    protected String doubleOnfocus;
    protected String doubleOnblur;
    protected String doubleOnkeypress;
    protected String doubleOnkeydown;
    protected String doubleOnkeyup;
    protected String doubleOnselect;
    protected String doubleOnchange;
    
    protected String doubleAccesskey;
    

    public DoubleListUIBean(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    public void evaluateExtraParams() {
        super.evaluateExtraParams();

        //Object doubleName = null;
        
        if (emptyOption != null) {
            addParameter("emptyOption", findValue(emptyOption, Boolean.class));
        }

        if (multiple != null) {
            addParameter("multiple", findValue(multiple, Boolean.class));
        }

        if (size != null) {
            addParameter("size", findString(size));
        }

        if ((headerKey != null) && (headerValue != null)) {
            addParameter("headerKey", findString(headerKey));
            addParameter("headerValue", findString(headerValue));
        }
        
        
        if (doubleMultiple != null) {
        	addParameter("doubleMultiple", findValue(doubleMultiple, Boolean.class));
        }
        
        if (doubleSize != null) {
        	addParameter("doubleSize", findString(doubleSize));
        }
        
        if (doubleDisabled != null) {
        	addParameter("doubleDisabled", findValue(doubleDisabled, Boolean.class));
        }

        if (doubleName != null) {
            addParameter("doubleName", findString(this.doubleName));
        }

        if (doubleList != null) {
            addParameter("doubleList", doubleList);
        }
        
        Object tmpDoubleList = findValue(doubleList);
        if (doubleListKey != null) {
            addParameter("doubleListKey", doubleListKey);
        }else if (tmpDoubleList instanceof Map) {
        	addParameter("doubleListKey", "key");
        }
        
        if (doubleListValue != null) {
            if (altSyntax()) {
                // the same logic as with findValue(String)
                // if value start with %{ and end with }, just cut it off!
                if (doubleListValue.startsWith("%{") && doubleListValue.endsWith("}")) {
                    doubleListValue = doubleListValue.substring(2, doubleListValue.length() - 1);
                }
            }

            addParameter("doubleListValue", doubleListValue);
        }else if (tmpDoubleList instanceof Map) {
        	addParameter("doubleListValue", "value");
        }


        if (formName != null) {
            addParameter("formName", findString(formName));
        } else {
            // ok, let's look it up
            Component form = findAncestor(Form.class);
            if (form != null) {
                addParameter("formName", form.getParameters().get("name"));
            }
        }

        Class valueClazz = getValueClassType();

        if (valueClazz != null) {
            if (doubleValue != null) {
                addParameter("doubleNameValue", findValue(doubleValue, valueClazz));
            } else if (doubleName != null) {
                addParameter("doubleNameValue", findValue(doubleName.toString(), valueClazz));
            }
        } else {
            if (doubleValue != null) {
                addParameter("doubleNameValue", findValue(doubleValue));
            } else if (doubleName != null) {
                addParameter("doubleNameValue", findValue(doubleName.toString()));
            }
        }
        
        Form form = (Form) findAncestor(Form.class);
        if (doubleId != null) {
            // this check is needed for backwards compatibility with 2.1.x
            if (altSyntax()) {
                addParameter("doubleId", findString(doubleId));
            } else {
                addParameter("doubleId", doubleId);
            }
        } else if (form != null) {
            addParameter("doubleId", form.getParameters().get("id") + "_" +escape(this.doubleName));
        }
        
        if (doubleOnclick != null) {
        	addParameter("doubleOnclick", findString(doubleOnclick));
        }
        
        if (doubleOndblclick != null) {
        	addParameter("doubleOndblclick", findString(doubleOndblclick));
        }
        
        if (doubleOnmousedown != null) {
        	addParameter("doubleOnmousedown", findString(doubleOnmousedown));
        }
        
        if (doubleOnmouseup != null) {
        	addParameter("doubleOnmouseup", findString(doubleOnmouseup));
        }
        
        if (doubleOnmouseover != null) {
        	addParameter("doubleOnmouseover", findString(doubleOnmouseover));
        }
        
        if (doubleOnmousemove != null) {
        	addParameter("doubleOnmousemove", findString(doubleOnmousemove));
        }
        
        if (doubleOnmouseout != null) {
        	addParameter("doubleOnmouseout", findString(doubleOnmouseout));
        }
        
        if (doubleOnfocus != null) {
        	addParameter("doubleOnfocus", findString(doubleOnfocus));
        }
        
        if (doubleOnblur != null) {
        	addParameter("doubleOnblur", findString(doubleOnblur));
        }
        
        if (doubleOnkeypress != null) {
        	addParameter("doubleOnkeypress", findString(doubleOnkeypress));
        }
        
        if (doubleOnkeydown != null) {
        	addParameter("doubleOnkeydown", findString(doubleOnkeydown));
        }
        
        if (doubleOnselect != null) {
        	addParameter("doubleOnselect", findString(doubleOnselect));
        }
        
        if (doubleOnchange != null) {
        	addParameter("doubleOnchange", findString(doubleOnchange));
        }
        
        if (doubleCssClass != null) {
        	addParameter("doubleCss", findString(doubleCssClass));
        }
        
        if (doubleCssStyle != null) {
        	addParameter("doubleStyle", findString(doubleCssStyle));
        }
        
        if (doubleHeaderKey != null && doubleHeaderValue != null) {
        	addParameter("doubleHeaderKey", findString(doubleHeaderKey));
        	addParameter("doubleHeaderValue", findString(doubleHeaderValue));
        }
        
        if (doubleEmptyOption != null) {
        	addParameter("doubleEmptyOption", findValue(doubleEmptyOption, Boolean.class));
        }
        
        if (doubleAccesskey != null) {
        	addParameter("doubleAccesskey", findString(doubleAccesskey));
        }
    }

    /**
     * The second iterable source to populate from.
     * @s.tagattribute required="true"
     */
    public void setDoubleList(String doubleList) {
        this.doubleList = doubleList;
    }

    /**
     * The key expression to use for second list
     * @s.tagattribute required="false"
     */
    public void setDoubleListKey(String doubleListKey) {
        this.doubleListKey = doubleListKey;
    }

    /**
     * The value expression to use for second list
     * @s.tagattribute required="false"
     */
    public void setDoubleListValue(String doubleListValue) {
        this.doubleListValue = doubleListValue;
    }

    /**
     * The name for complete component
     * @s.tagattribute required="true"
     */
    public void setDoubleName(String doubleName) {
        this.doubleName = doubleName;
    }

    /**
     * The value expression for complete component
     * @s.tagattribute required="false"
     */
    public void setDoubleValue(String doubleValue) {
        this.doubleValue = doubleValue;
    }

    /**
     * The form name this component resides in and populates to
     * @s.tagattribute required="false"
     */
    public void setFormName(String formName) {
        this.formName = formName;
    }
    
    public String getFormName() {
    	return formName;
    }
    
    /**
     * The css class for the second list
     * @s.tagattribute required="false"
     */
    public void setDoubleCssClass(String doubleCssClass) {
    	this.doubleCssClass = doubleCssClass;
    }
    
    public String getDoubleCssClass() {
    	return doubleCssClass;
    }
    
    /**
     * The css style for the second list
     * @s.tagattribute required="false"
     */
    public void setDoubleCssStyle(String doubleCssStyle) {
    	this.doubleCssStyle = doubleCssStyle;
    }
    
    public String getDoubleCssStyle() {
    	return doubleCssStyle;
    }
    
    /**
     * The header key for the second list
     * @s.tagattribute required="false"
     */
    public void setDoubleHeaderKey(String doubleHeaderKey) {
    	this.doubleHeaderKey = doubleHeaderKey;
    }
    
    public String getDoubleHeaderKey() {
    	return doubleHeaderKey;
    }
    
    /**
     * The header value for the second list
     * @s.tagattribute required="false"
     */
    public void setDoubleHeaderValue(String doubleHeaderValue) {
    	this.doubleHeaderValue = doubleHeaderValue;
    }
    
    public String getDoubleHeaderValue() {
    	return doubleHeaderValue;
    }

    /**
     * Decides if the second list will add an empty option
     * @s.tagattribute required="false"
     */
    public void setDoubleEmptyOption(String doubleEmptyOption) {
    	this.doubleEmptyOption = doubleEmptyOption;
    }
    
    public String getDoubleEmptyOption() {
    	return this.doubleEmptyOption;
    }

    
	public String getDoubleDisabled() {
		return doubleDisabled;
	}

	/**
     * Decides if a disable attribute should be added to the second list
     * @s.tagattribute required="false"
     */
	public void setDoubleDisabled(String doubleDisabled) {
		this.doubleDisabled = doubleDisabled;
	}

	public String getDoubleId() {
		return doubleId;
	}

	/**
     * The id of the second list
     * @s.tagattribute required="false"
     */
	public void setDoubleId(String doubleId) {
		this.doubleId = doubleId;
	}

	public String getDoubleMultiple() {
		return doubleMultiple;
	}

	/**
     * Decides if multiple attribute should be set on the second list
     * @s.tagattribute required="false"
     */
	public void setDoubleMultiple(String doubleMultiple) {
		this.doubleMultiple = doubleMultiple;
	}

	public String getDoubleOnblur() {
		return doubleOnblur;
	}

	/**
     * Set the onblur attribute of the second list
     * @s.tagattribute required="false"
     */
	public void setDoubleOnblur(String doubleOnblur) {
		this.doubleOnblur = doubleOnblur;
	}

	public String getDoubleOnchange() {
		return doubleOnchange;
	}

	/**
     * Set the onchange attribute of the second list
     * @s.tagattribute required="false"
     */
	public void setDoubleOnchange(String doubleOnchange) {
		this.doubleOnchange = doubleOnchange;
	}

	public String getDoubleOnclick() {
		return doubleOnclick;
	}

	/**
     * Set the onclick attribute of the second list
     * @s.tagattribute required="false"
     */
	public void setDoubleOnclick(String doubleOnclick) {
		this.doubleOnclick = doubleOnclick;
	}

	public String getDoubleOndblclick() {
		return doubleOndblclick;
	}

	/**
     * Set the ondbclick attribute of the second list
     * @s.tagattribute required="false"
     */
	public void setDoubleOndblclick(String doubleOndblclick) {
		this.doubleOndblclick = doubleOndblclick;
	}

	public String getDoubleOnfocus() {
		return doubleOnfocus;
	}

	/**
     * Set the onfocus attribute of the second list
     * @s.tagattribute required="false"
     */
	public void setDoubleOnfocus(String doubleOnfocus) {
		this.doubleOnfocus = doubleOnfocus;
	}

	public String getDoubleOnkeydown() {
		return doubleOnkeydown;
	}

	/**
     * Set the onkeydown attribute of the second list
     * @s.tagattribute required="false"
     */
	public void setDoubleOnkeydown(String doubleOnkeydown) {
		this.doubleOnkeydown = doubleOnkeydown;
	}

	public String getDoubleOnkeypress() {
		return doubleOnkeypress;
	}

	/**
     * Set the onkeypress attribute of the second list
     * @s.tagattribute required="false"
     */
	public void setDoubleOnkeypress(String doubleOnkeypress) {
		this.doubleOnkeypress = doubleOnkeypress;
	}

	public String getDoubleOnkeyup() {
		return doubleOnkeyup;
	}

	/**
     * Set the onkeyup attribute of the second list
     * @s.tagattribute required="false"
     */
	public void setDoubleOnkeyup(String doubleOnkeyup) {
		this.doubleOnkeyup = doubleOnkeyup;
	}

	public String getDoubleOnmousedown() {
		return doubleOnmousedown;
	}

	/**
     * Set the onmousedown attribute of the second list
     * @s.tagattribute required="false"
     */
	public void setDoubleOnmousedown(String doubleOnmousedown) {
		this.doubleOnmousedown = doubleOnmousedown;
	}

	public String getDoubleOnmousemove() {
		return doubleOnmousemove;
	}

	/**
     * Set the onmousemove attribute of the second list
     * @s.tagattribute required="false"
     */
	public void setDoubleOnmousemove(String doubleOnmousemove) {
		this.doubleOnmousemove = doubleOnmousemove;
	}

	public String getDoubleOnmouseout() {
		return doubleOnmouseout;
	}

	/**
     * Set the onmouseout attribute of the second list
     * @s.tagattribute required="false"
     */
	public void setDoubleOnmouseout(String doubleOnmouseout) {
		this.doubleOnmouseout = doubleOnmouseout;
	}

	public String getDoubleOnmouseover() {
		return doubleOnmouseover;
	}

	/**
     * Set the onmouseover attribute of the second list
     * @s.tagattribute required="false"
     */
	public void setDoubleOnmouseover(String doubleOnmouseover) {
		this.doubleOnmouseover = doubleOnmouseover;
	}

	public String getDoubleOnmouseup() {
		return doubleOnmouseup;
	}

	/**
     * Set the onmouseup attribute of the second list
     * @s.tagattribute required="false"
     */
	public void setDoubleOnmouseup(String doubleOnmouseup) {
		this.doubleOnmouseup = doubleOnmouseup;
	}

	public String getDoubleOnselect() {
		return doubleOnselect;
	}

	/**
     * Set the onselect attribute of the second list
     * @s.tagattribute required="false"
     */
	public void setDoubleOnselect(String doubleOnselect) {
		this.doubleOnselect = doubleOnselect;
	}

	public String getDoubleSize() {
		return doubleSize;
	}

	/**
     * Set the size attribute of the second list
     * @s.tagattribute required="false"
     */
	public void setDoubleSize(String doubleSize) {
		this.doubleSize = doubleSize;
	}

	public String getDoubleList() {
		return doubleList;
	}

	/**
     * Set the list key of the second attribute
     * @s.tagattribute required="false"
     */
	public String getDoubleListKey() {
		return doubleListKey;
	}

	public String getDoubleListValue() {
		return doubleListValue;
	}

	public String getDoubleName() {
		return doubleName;
	}

	public String getDoubleValue() {
		return doubleValue;
	}
	
	/**
     * Decides of an empty option is to be inserted in the second list
     * @s.tagattribute required="false" default="false" type="Boolean"
     */
    public void setEmptyOption(String emptyOption) {
        this.emptyOption = emptyOption;
    }

    /**
     * Set the header key of the second list. Must not be empty! "'-1'" and "''" is correct, "" is bad.
     * @s.tagattribute required="false"
     */
    public void setHeaderKey(String headerKey) {
        this.headerKey = headerKey;
    }

    /**
     * Set the header value of the second list
     * @s.tagattribute required="false"
     */
    public void setHeaderValue(String headerValue) {
        this.headerValue = headerValue;
    }

    /**
     * Creates a multiple select. The tag will pre-select multiple values if the values are passed as an Array (of appropriate types) via the value attribute.
     * @s.tagattribute required="false"
     */
    public void setMultiple(String multiple) {
        // TODO: Passing a Collection may work too?
        this.multiple = multiple;
    }

    /**
     * Size of the element box (# of elements to show)
     * @s.tagattribute required="false" type="Integer"
     */
    public void setSize(String size) {
        this.size = size;
    }
    
    /**
     * Set the html accesskey attribute.
     * @s.tagattribute required="false"
     */
    public void setDoubleAccesskey(String doubleAccesskey) {
    	this.doubleAccesskey = doubleAccesskey;
    }
}
"
core/src/main/java/org/apache/struts2/components/DoubleSelect.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * Renders two HTML select elements with second one changing displayed values depending on selected entry of first one.
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * &lt;s:doubleselect label="doubleselect test1" name="menu" list="{'fruit','other'}" doubleName="dishes" doubleList="top == 'fruit' ? {'apple', 'orange'} : {'monkey', 'chicken'}" /&gt;
 * &lt;s:doubleselect label="doubleselect test2" name="menu" list="#{'fruit':'Nice Fruits', 'other':'Other Dishes'}" doubleName="dishes" doubleList="top == 'fruit' ? {'apple', 'orange'} : {'monkey', 'chicken'}" /&gt;
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @s.tag name="doubleselect" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.DoubleSelectTag"
 * description="Renders two HTML select elements with second one changing displayed values depending on selected entry of first one."
 */
public class DoubleSelect extends DoubleListUIBean {
    final public static String TEMPLATE = "doubleselect";


    public DoubleSelect(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }

    public void evaluateExtraParams() {
        super.evaluateExtraParams();

        // force the onchange parameter
        addParameter("onchange", getParameters().get("name") + "Redirect(this.options.selectedIndex)");
    }
}
"
core/src/main/java/org/apache/struts2/components/Else.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.io.Writer;
import java.util.Map;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 *
 * <p>Perform basic condition flow. 'If' tag could be used by itself or with 'Else If' Tag and/or single/multiple 'Else'
 * Tag.</p>
 *
 * <!-- END SNIPPET: javadoc -->
 *
 * <!-- START SNIPPET: params -->
 *
 * no params
 *
 * <!-- END SNIPPET: params -->
 *
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 *  &lt;s:if test="%{false}"&gt;
 * 	    &lt;div&gt;Will Not Be Executed&lt;/div&gt;
 *  &lt;/s:if&gt;
 * 	&lt;s:elseif test="%{true}"&gt;
 * 	    &lt;div&gt;Will Be Executed&lt;/div&gt;
 *  &lt;/s:elseif&gt;
 *  &lt;s:else&gt;
 * 	    &lt;div&gt;Will Not Be Executed&lt;/div&gt;
 *  &lt;/s:else&gt;
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @s.tag name="else" bodycontent="JSP" description="Else tag"  tld-tag-class="org.apache.struts2.views.jsp.ElseTag"
 */
public class Else extends Component {
    public Else(OgnlValueStack stack) {
        super(stack);
    }

    public boolean start(Writer writer) {
        Map context = stack.getContext();
        Boolean ifResult = (Boolean) context.get(If.ANSWER);

        context.remove(If.ANSWER);

        return !((ifResult == null) || (ifResult.booleanValue()));
    }
}
"
core/src/main/java/org/apache/struts2/components/ElseIf.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.io.Writer;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 *
 * <p>Perform basic condition flow. 'If' tag could be used by itself or with 'Else If' Tag and/or single/multiple 'Else'
 * Tag.</p>
 *
 * <!-- END SNIPPET: javadoc -->
 *
 *
 * <!-- START SNIPPET: params -->
 *
 * <ul>
 *
 * <li>test* (Boolean) - Logic to determined if body of tag is to be displayed</li>
 *
 * </ul>
 *
 * <!-- END SNIPPET: params -->
 *
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 *  &lt;s:if test="%{false}"&gt;
 * 	    &lt;div&gt;Will Not Be Executed&lt;/div&gt;
 *  &lt;/s:if&gt;
 * 	&lt;s:elseif test="%{true}"&gt;
 * 	    &lt;div&gt;Will Be Executed&lt;/div&gt;
 *  &lt;/s:elseif&gt;
 *  &lt;s:else&gt;
 * 	    &lt;div&gt;Will Not Be Executed&lt;/div&gt;
 *  &lt;/s:else&gt;
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @s.tag name="elseif" tld-body-content="JSP" description="Elseif tag"  tld-tag-class="org.apache.struts2.views.jsp.ElseIfTag"
 */
public class ElseIf extends Component {
    public ElseIf(OgnlValueStack stack) {
        super(stack);
    }

    protected Boolean answer;
    protected String test;

    public boolean start(Writer writer) {
        Boolean ifResult = (Boolean) stack.getContext().get(If.ANSWER);
        
        if ((ifResult == null) || (ifResult.booleanValue())) {
            return false;
        }

        //make the comparision
        answer = (Boolean) findValue(test, Boolean.class);

        if (answer == null) {
            answer = Boolean.FALSE;
        }
        if (answer.booleanValue()) {
            stack.getContext().put(If.ANSWER, answer);
        }
        return answer != null && answer.booleanValue();
    }

    public boolean end(Writer writer, String body) {
        if (answer == null) {
            answer = Boolean.FALSE;
        }
        if (answer.booleanValue()) {
            stack.getContext().put(If.ANSWER, answer);
        }
        return super.end(writer, "");
    }

    /**
     * Expression to determine if body of tag is to be displayed
     * @s.tagattribute required="true" type="Boolean"
     */
    public void setTest(String test) {
        this.test = test;
    }
}
"
core/src/main/java/org/apache/struts2/components/FieldError.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.util.ArrayList;
import java.util.List;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Param.UnnamedParametric;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 *
 * Render field errors if they exists. Specific layout depends on the particular theme.
 *
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * 
 *    &lt;!-- example 1 --&gt;
 *    &lt;s:fielderror /&gt;
 *
 *    &lt;!-- example 2 --&gt;
 *    &lt;s:fielderror&gt;
 *         &lt;s:param&gt;field1&lt;/s:param&gt;
 *         &lt;s:param&gt;field2&lt;/s:param&gt;
 *    &lt;/s:fielderror&gt;
 *    &lt;s:form .... &gt;>
 *       ....
 *    &lt;/s:form&gt;
 *
 *    OR
 *
 *    &lt;s:fielderror&gt;
 *    		&lt;s:param value="%{'field1'}" /&gt;
 *    		&lt;s:param value="%{'field2'}" /&gt;
 *    &lt;/s:fielderror&gt;
 *    &lt;s:form .... &gt;>
 *       ....
 *    &lt;/s:form&gt;
 *    
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 *
 * <p/> <b>Description</b><p/>
 *
 * 
 * <pre>
 * <!-- START SNIPPET: description -->
 *
 * Example 1: display all field errors<p/> 
 * Example 2: display field errors only for 'field1' and 'field2'<p/>
 *
 * <!-- END SNIPPET: description -->
 * </pre>
 *
 * @s.tag name="fielderror" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.FieldErrorTag"
 * description="Render field error (all or partial depending on param tag nested)if they exists"
 */
public class FieldError extends UIBean implements UnnamedParametric {

    private List errorFieldNames = new ArrayList();

    public FieldError(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    private static final String TEMPLATE = "fielderror";

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }

    public void addParameter(Object value) {
        if (value != null) {
            errorFieldNames.add(value.toString());
        }
    }

    public List getFieldErrorFieldNames() {
        return errorFieldNames;
    }
}

"
core/src/main/java/org/apache/struts2/components/File.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * Renders an HTML file input element.
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * &lt;s:file name="anUploadFile" accept="text/*" /&gt;
 * &lt;s:file name="anohterUploadFIle" accept="text/html,text/plain" /&gt;
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @s.tag name="file" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.FileTag"
 * description="Render a file input field"
 */
public class File extends UIBean {
    private final static Log log = LogFactory.getLog(File.class);

    final public static String TEMPLATE = "file";

    protected String accept;
    protected String size;

    public File(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }

    public void evaluateParams() {
        super.evaluateParams();

        Form form = (Form) findAncestor(Form.class);
        if (form != null) {
            String encType = (String) form.getParameters().get("enctype");
            if (!"multipart/form-data".equals(encType)) {
                // uh oh, this isn't good! Let's warn the developer
                log.warn("Struts has detected a file upload UI tag (s:file) being used without a form set to enctype 'multipart/form-data'. This is probably an error!");
            }

            String method = (String) form.getParameters().get("method");
            if (!"post".equalsIgnoreCase(method)) {
                // uh oh, this isn't good! Let's warn the developer
                log.warn("Struts has detected a file upload UI tag (s:file) being used without a form set to method 'POST'. This is probably an error!");
            }
        }

        if (accept != null) {
            addParameter("accept", findString(accept));
        }

        if (size != null) {
            addParameter("size", findString(size));
        }
    }

    /**
     * HTML accept attribute to indicate accepted file mimetypes
     * @s.tagattribute required="false"
     */
    public void setAccept(String accept) {
        this.accept = accept;
    }

    /**
     * HTML size attribute
     * @s.tagattribute required="false" type="Integer"
     */
    public void setSize(String size) {
        this.size = size;
    }
}
"
core/src/main/java/org/apache/struts2/components/Form.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.lang.StringUtils;
import org.apache.struts2.StrutsConstants;
import org.apache.struts2.config.Settings;
import org.apache.struts2.dispatcher.Dispatcher;
import org.apache.struts2.dispatcher.mapper.ActionMapperFactory;
import org.apache.struts2.dispatcher.mapper.ActionMapping;
import org.apache.struts2.portlet.context.PortletActionContext;
import org.apache.struts2.portlet.util.PortletUrlHelper;
import org.apache.struts2.views.util.UrlHelper;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.ObjectFactory;
import com.opensymphony.xwork2.config.Configuration;
import com.opensymphony.xwork2.config.RuntimeConfiguration;
import com.opensymphony.xwork2.config.entities.ActionConfig;
import com.opensymphony.xwork2.config.entities.InterceptorMapping;
import com.opensymphony.xwork2.interceptor.MethodFilterInterceptorUtil;
import com.opensymphony.xwork2.util.OgnlValueStack;
import com.opensymphony.xwork2.validator.ActionValidatorManagerFactory;
import com.opensymphony.xwork2.validator.FieldValidator;
import com.opensymphony.xwork2.validator.ValidationInterceptor;
import com.opensymphony.xwork2.validator.Validator;

/**
 * <!-- START SNIPPET: javadoc -->
 * <p/>
 * Renders HTML an input form.<p/>
 * <p/>
 * The remote form allows the form to be submitted without the page being refreshed. The results from the form
 * can be inserted into any HTML element on the page.<p/>
 * <p/>
 * NOTE:<p/>
 * The order / logic in determining the posting url of the generated HTML form is as follows:-
 * <ol>
 * <li>
 * If the action attribute is not specified, then the current request will be used to
 * determine the posting url
 * </li>
 * <li>
 * If the action is given, Struts will try to obtain an ActionConfig. This will be
 * successfull if the action attribute is a valid action alias defined struts.xml.
 * </li>
 * <li>
 * If the action is given and is not an action alias defined in struts.xml, Struts
 * will used the action attribute as if it is the posting url, separting the namespace
 * from it and using UrlHelper to generate the final url.
 * </li>
 * </ol>
 * <p/>
 * <!-- END SNIPPET: javadoc -->
 * <p/>
 * <p/> <b>Examples</b>
 * <p/>
 * <pre>
 * <!-- START SNIPPET: example -->
 * <p/>
 * &lt;s:form ... /&gt;
 * <p/>
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @s.tag name="form" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.FormTag"
 * description="Renders an input form"
 */
public class Form extends ClosingUIBean {
    public static final String OPEN_TEMPLATE = "form";
    public static final String TEMPLATE = "form-close";

    private int sequence = 0;
    
    protected String onsubmit;
    protected String action;
    protected String target;
    protected String enctype;
    protected String method;
    protected String namespace;
    protected String validate;
    protected String portletMode;
    protected String windowState;
    protected String acceptcharset;

    public Form(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    protected boolean evaluateNameValue() {
        return false;
    }

    public String getDefaultOpenTemplate() {
        return OPEN_TEMPLATE;
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }


    /*
    * Revised for Portlet actionURL as form action, and add wwAction as hidden
    * field. Refer to template.simple/form.vm
    */
    protected void evaluateExtraParams() {
        super.evaluateExtraParams();

        //boolean isAjax = "ajax".equalsIgnoreCase(this.theme);

        if (validate != null) {
            addParameter("validate", findValue(validate, Boolean.class));
        }

        // calculate the action and namespace
        /*String action = null;
        if (this.action != null) {
            // if it isn't specified, we'll make somethig up
            action = findString(this.action);
        }

        if (Dispatcher.getInstance().isPortletSupportActive() && PortletActionContext.isPortletRequest()) {
            evaluateExtraParamsPortletRequest(namespace, action);
        } else {
            String namespace = determineNamespace(this.namespace, getStack(),
                    request);
            evaluateExtraParamsServletRequest(action, namespace, isAjax);
        }*/

        if (onsubmit != null) {
            addParameter("onsubmit", findString(onsubmit));
        }

        if (target != null) {
            addParameter("target", findString(target));
        }

        if (enctype != null) {
            addParameter("enctype", findString(enctype));
        }

        if (method != null) {
            addParameter("method", findString(method));
        }

        if (acceptcharset != null) {
            addParameter("acceptcharset", findString(acceptcharset));
        }

        // keep a collection of the tag names for anything special the templates might want to do (such as pure client
        // side validation)
        if (!parameters.containsKey("tagNames")) {
            // we have this if check so we don't do this twice (on open and close of the template)
            addParameter("tagNames", new ArrayList());
        }
    }
    
    /**
     * Form component determine the its HTML element id as follows:-
     * <ol>
     *    <li>if an 'id' attribute is specified.</li>
     *    <li>if an 'action' attribute is specified, it will be used as the id.</li>
     * </ol>
     */
    protected void populateComponentHtmlId(Form form) {
    	boolean isAjax = "ajax".equalsIgnoreCase(this.theme);
    	
    	String action = null;
        if (this.action != null) {
            // if it isn't specified, we'll make somethig up
            action = findString(this.action);
        }

        if (id != null) {
        	addParameter("id", escape(id));
        }
        if (Dispatcher.getInstance().isPortletSupportActive() && PortletActionContext.isPortletRequest()) {
            evaluateExtraParamsPortletRequest(namespace, action);
        } else {
            String namespace = determineNamespace(this.namespace, getStack(),
                    request);
            evaluateExtraParamsServletRequest(action, namespace, isAjax);
        }
    }

    /**
     * @param isAjax
     * @param namespace
     * @param action
     */
    private void evaluateExtraParamsServletRequest(String action, String namespace, boolean isAjax) {
        if (action == null) {
            // no action supplied? ok, then default to the current request (action or general URL)
            ActionInvocation ai = (ActionInvocation) getStack().getContext().get(ActionContext.ACTION_INVOCATION);
            if (ai != null) {
                action = ai.getProxy().getActionName();
                namespace = ai.getProxy().getNamespace();
            } else {
                // hmm, ok, we need to just assume the current URL cut down
                String uri = request.getRequestURI();
                action = uri.substring(uri.lastIndexOf('/'));
            }
        }

        String actionMethod = "";
        // FIXME: our implementation is flawed - the only concept of ! should be in DefaultActionMapper
        boolean allowDynamicMethodCalls = "true".equals(Settings.get(StrutsConstants.STRUTS_ENABLE_DYNAMIC_METHOD_INVOCATION));

        // handle "name!method" convention.
        if (allowDynamicMethodCalls) {
            if (action.indexOf("!") != -1) {
                int endIdx = action.lastIndexOf("!");
                actionMethod = action.substring(endIdx + 1, action.length());
                action = action.substring(0, endIdx);
            }
        }

        Configuration config = Dispatcher.getInstance().getConfigurationManager().getConfiguration();
        final ActionConfig actionConfig = config.getRuntimeConfiguration().getActionConfig(namespace, action);
        String actionName = action;
        if (actionConfig != null) {

            ActionMapping mapping = new ActionMapping(action, namespace, actionMethod, parameters);
            String result = UrlHelper.buildUrl(ActionMapperFactory.getMapper().getUriFromActionMapping(mapping), request, response, null);
            addParameter("action", result);

            // let's try to get the actual action class and name
            // this can be used for getting the list of validators
            addParameter("actionName", actionName);
            try {
                Class clazz = ObjectFactory.getObjectFactory().getClassInstance(actionConfig.getClassName());
                addParameter("actionClass", clazz);
            } catch (ClassNotFoundException e) {
                // this is OK, we'll just move on
            }

            addParameter("namespace", namespace);

            // if the name isn't specified, use the action name
            if (name == null) {
                addParameter("name", action);
            }

            // if the id isn't specified, use the action name
            if (id == null) {
                addParameter("id", action);
            }
        } else if (action != null) {
            // Since we can't find an action alias in the configuration, we just assume
            // the action attribute supplied is the path to be used as the uri this
            // form is submitting to.

            String result = UrlHelper.buildUrl(action, request, response, null);
            addParameter("action", result);

            // namespace: cut out anything between the start and the last /
            int slash = result.lastIndexOf('/');
            if (slash != -1) {
                addParameter("namespace", result.substring(0, slash));
            } else {
                addParameter("namespace", "");
            }

            // name/id: cut out anything between / and . should be the id and name
            if (id == null) {
                slash = result.lastIndexOf('/');
                int dot = result.indexOf('.', slash);
                if (dot != -1) {
                    id = result.substring(slash + 1, dot);
                } else {
                    id = result.substring(slash + 1);
                }
                addParameter("id", escape(id));
            }
        }

        // WW-1284
        // evaluate if client-side js is to be enabled. (if validation interceptor 
        // does allow validation eg. method is not filtered out)
        evaluateClientSideJsEnablement(actionName, namespace, actionMethod);
    }

    private void evaluateClientSideJsEnablement(String actionName, String namespace, String actionMethod) {

        // Only evaluate if Client-Side js is to be enable when validate=true
        Boolean validate = (Boolean) getParameters().get("validate");
        if (validate != null && validate.booleanValue()) {

            addParameter("performValidation", Boolean.FALSE);

            RuntimeConfiguration runtimeConfiguration = Dispatcher.getInstance().getConfigurationManager().getConfiguration().getRuntimeConfiguration();
            ActionConfig actionConfig = runtimeConfiguration.getActionConfig(namespace, actionName);

            if (actionConfig != null) {
                List interceptors = actionConfig.getInterceptors();
                for (Iterator i = interceptors.iterator(); i.hasNext();) {
                    InterceptorMapping interceptorMapping = (InterceptorMapping) i.next();
                    if (ValidationInterceptor.class.isInstance(interceptorMapping.getInterceptor())) {
                        ValidationInterceptor validationInterceptor = (ValidationInterceptor) interceptorMapping.getInterceptor();

                        Set excludeMethods = validationInterceptor.getExcludeMethodsSet();
                        Set includeMethods = validationInterceptor.getIncludeMethodsSet();

                        if (MethodFilterInterceptorUtil.applyMethod(excludeMethods, includeMethods, actionMethod)) {
                            addParameter("performValidation", Boolean.TRUE);
                        }
                        return;
                    }
                }
            }
        }
    }

    /**
     * Constructs the action url adapted to a portal environment.
     *
     * @param action The action to create the URL for.
     */
    private void evaluateExtraParamsPortletRequest(String namespace, String action) {

        if (this.action != null) {
            // if it isn't specified, we'll make somethig up
            action = findString(this.action);
        }

        String type = "action";
        if (StringUtils.isNotEmpty(method)) {
            if ("GET".equalsIgnoreCase(method.trim())) {
                type = "render";
            }
        }
        if (action != null) {
            String result = PortletUrlHelper.buildUrl(action, namespace,
                    getParameters(), type, portletMode, windowState);
            addParameter("action", result);

            // namespace: cut out anything between the start and the last /
            int slash = result.lastIndexOf('/');
            if (slash != -1) {
                addParameter("namespace", result.substring(0, slash));
            } else {
                addParameter("namespace", "");
            }

            // name/id: cut out anything between / and . should be the id and
            // name
            if (id == null) {
                slash = action.lastIndexOf('/');
                int dot = action.indexOf('.', slash);
                if (dot != -1) {
                    id = action.substring(slash + 1, dot);
                } else {
                    id = action.substring(slash + 1);
                }
                addParameter("id", escape(id));
            }
        }

    }

    public List getValidators(String name) {
        Class actionClass = (Class) getParameters().get("actionClass");
        if (actionClass == null) {
            return Collections.EMPTY_LIST;
        }

        List all = ActionValidatorManagerFactory.getInstance().getValidators(actionClass, (String) getParameters().get("actionName"));
        List validators = new ArrayList();
        for (Iterator iterator = all.iterator(); iterator.hasNext();) {
            Validator validator = (Validator) iterator.next();
            if (validator instanceof FieldValidator) {
                FieldValidator fieldValidator = (FieldValidator) validator;
                if (fieldValidator.getFieldName().equals(name)) {
                    validators.add(fieldValidator);
                }
            }
        }

        return validators;
    }
    
    /**
     * Get a incrementing sequence unique to this <code>Form</code> component.
     * It is used by <code>Form</code> component's child that might need a 
     * sequence to make them unique.
     * 
     * @return int
     */
    protected int getSequence() {
    	return sequence++;
    }


    /**
     * HTML onsubmit attribute
     *
     * @s.tagattribute required="false"
     */
    public void setOnsubmit(String onsubmit) {
        this.onsubmit = onsubmit;
    }

    /**
     * Set action nane to submit to, without .action suffix
     *
     * @s.tagattribute required="false" default="current action"
     */
    public void setAction(String action) {
        this.action = action;
    }

    /**
     * HTML form target attribute
     *
     * @s.tagattribute required="false"
     */
    public void setTarget(String target) {
        this.target = target;
    }

    /**
     * HTML form enctype attribute
     *
     * @s.tagattribute required="false"
     */
    public void setEnctype(String enctype) {
        this.enctype = enctype;
    }

    /**
     * HTML form method attribute
     *
     * @s.tagattribute required="false"
     */
    public void setMethod(String method) {
        this.method = method;
    }

    /**
     * namespace for action to submit to
     *
     * @s.tagattribute required="false" default="current namespace"
     */
    public void setNamespace(String namespace) {
        this.namespace = namespace;
    }

    /**
     * Whether client side/remote validation should be performed. Only useful with theme xhtml/ajax
     *
     * @s.tagattribute required="false" type="Boolean" default="false"
     */
    public void setValidate(String validate) {
        this.validate = validate;
    }

    /**
     * The portlet mode to display after the form submit
     *
     * @s.tagattribute required="false"
     */
    public void setPortletMode(String portletMode) {
        this.portletMode = portletMode;
    }

    /**
     * The window state to display after the form submit
     *
     * @s.tagattribute required="false"
     */
    public void setWindowState(String windowState) {
        this.windowState = windowState;
    }

    /**
     * The accepted charsets for this form. The values may be comma or blank delimited.
     *
     * @s.tagattribute required="false"
     */
    public void setAcceptcharset(String acceptcharset) {
        this.acceptcharset = acceptcharset;
    }
}
"
core/src/main/java/org/apache/struts2/components/FormButton.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * FormButton.
 */
public abstract class FormButton extends UIBean {

    static final String BUTTONTYPE_INPUT = "input";
    static final String BUTTONTYPE_BUTTON = "button";
    static final String BUTTONTYPE_IMAGE = "image";

    protected String action;
    protected String method;
    protected String align;
    protected String type;

    public FormButton(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    //public void evaluateParams() {
    public void evaluateExtraParams() {
    	super.evaluateExtraParams();
        if (align == null) {
            align = "right";
        }

        String submitType = BUTTONTYPE_INPUT;
        if (type != null && (BUTTONTYPE_BUTTON.equalsIgnoreCase(type) || (supportsImageType() && BUTTONTYPE_IMAGE.equalsIgnoreCase(type))))
        {
            submitType = type;
        }

        //super.evaluateParams();

        addParameter("type", submitType);

        if (!BUTTONTYPE_INPUT.equals(submitType) && (label == null)) {
            addParameter("label", getParameters().get("nameValue"));
        }

        if (action != null || method != null) {
            String name;

            if (action != null) {
                name = "action:" + findString(action);

                if (method != null) {
                    name += "!" + findString(method);
                }
            } else {
                name = "method:" + findString(method);
            }

            addParameter("name", name);
        }

        addParameter("align", findString(align));

    }
    
    /**
     * Override UIBean's implementation, such that component Html id is determined
     * in the following order :-
     * <ol>
     * 	 <li>This component id attribute</li>
     *   <li>[containing_form_id]_[this_component_name]</li>
     *   <li>[containing_form_id]_[this_component_action]_[this_component_method]</li>
     *   <li>[containing_form_id]_[this_component_method]</li>
     *   <li>[this_component_name]</li>
     *   <li>[this_component_action]_[this_component_method]</li>
     *   <li>[this_component_method]</li>
     *   <li>[an increasing sequential number unique to the form starting with 0]</li>
     * </ol>
     */
    protected void populateComponentHtmlId(Form form) {
        String _tmp_id = "";
        if (id != null) {
            // this check is needed for backwards compatibility with 2.1.x
            if (altSyntax()) {
            	_tmp_id = findString(id);
            } else {
            	_tmp_id = id;
            }
        }
        else {
        	if (form != null && form.getParameters().get("id") != null) {
				_tmp_id = _tmp_id + form.getParameters().get("id").toString() + "_";
        	}
			if (name != null) {
				_tmp_id = _tmp_id + escape(name);
			} else if (action != null || method != null){
				if (action != null) {
					_tmp_id = _tmp_id + escape(action);
				}
				if (method != null) {
					_tmp_id = _tmp_id + "_" + escape(method);
				}
			} else {
				// if form is null, this component is used, without a form, i guess
				// there's not much we could do then.
				if (form != null) {
					_tmp_id = _tmp_id + form.getSequence();
				}
			}
        }
		addParameter("id", _tmp_id);
    }

    /**
	 * Indicate whether the concrete button supports the type "image".
	 * 
	 * @return <tt>true</tt> if type image is supported.
	 */
    protected abstract boolean supportsImageType();

    /**
     * Set action attribute.
     *
     * @s.tagattribute required="false" type="String"
     */
    public void setAction(String action) {
        this.action = action;
    }

    /**
     * Set method attribute.
     *
     * @s.tagattribute required="false" type="String"
     */
    public void setMethod(String method) {
        this.method = method;
    }

    /**
     * HTML align attribute.
     *
     * @s.tagattribute required="false" type="String"
     */
    public void setAlign(String align) {
        this.align = align;
    }

    /**
     * The type of submit to use. Valid values are <i>input</i>, <i>button</i> and <i>image</i>.
     *
     * @s.tagattribute required="false" type="String" default="input"
     */
    public void setType(String type) {
        this.type = type;
    }
}
"
core/src/main/java/org/apache/struts2/components/GenericUIBean.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.util.ContainUtil;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * 
 * Renders an custom UI widget using the specified templates. Additional objects can be passed in to the template
 * using the param tags.<p/>
 * 
 * <b>Freemarker:</b><p/>
 * Objects provided can be retrieve from within the template via $parameters._paramname_.<p/>
 * 
 * <b>Jsp:</b><p/>
 * Objects provided can be retrieve from within the template via &lt;s:property value="%{parameters._paramname_}" /&gt;<p/>
 *
 *
 * In the bottom JSP and Velocity samples, two parameters are being passed in to the component. From within the
 * component, they can be accessed as:- <p/>
 * 
 * <b>Freemarker:</b><p/>
 * $parameters.get('key1') and $parameters.get('key2') or $parameters.key1 and $parameters.key2<p/>
 * 
 * <b>Jsp:</b><p/>
 * &lt;s:property value="%{parameters.key1}" /&gt; and &lt;s:property value="%{'parameters.key2'}" /&gt; or
 * &lt;s:property value="%{parameters.get('key1')}" /&gt; and &lt;s:property value="%{parameters.get('key2')}" /&gt;<p/>
 *
 * Currently, your custom UI components can be written in Velocity, JSP, or Freemarker, and the correct rendering
 * engine will be found based on file extension.<p/>
 *
 * <b>Remember:</b> the value params will always be resolved against the OgnlValueStack so if you mean to pass a
 * string literal to your component, make sure to wrap it in quotes i.e. value="'value1'" otherwise, the the value
 * stack will search for an Object on the stack with a method of getValue1(). (now that i've written this, i'm not
 * entirely sure this is the case. i should verify this manana)<p/>
 * 
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * JSP
 *     &lt;s:component template="/my/custom/component.vm"/&gt;
 *     
 *       or
 *
 *     &lt;s:component template="/my/custom/component.vm"&gt;
 *       &lt;s:param name="key1" value="value1"/&gt;
 *       &lt;s:param name="key2" value="value2"/&gt;
 *     &lt;/s:component&gt;
 *
 * Velocity
 *     #s-component( "template=/my/custom/component.vm" )
 *
 *       or
 *
 *     #s-component( "template=/my/custom/component.vm" )
 *       #s-param( "name=key1" "value=value1" )
 *       #s-param( "name=key2" "value=value2" )
 *     #end
 *     
 * Freemarker
 *    &lt;@s..component template="/my/custom/component.ftl" />
 *    
 *      or
 *      
 *    &lt;@s..component template="/my/custom/component.ftl"&gt;
 *       &lt;@s..param name="key1" value="%{'value1'}" /&gt;
 *       &lt;@s..param name="key2" value="%{'value2'}" /&gt;
 *    &lt;/@s..component&gt;
 *     
 * <!-- END SNIPPET: example -->
 * </pre>
 * 
 * <p/>
 * 
 * <b>NOTE:</b>
 * <!-- START SNIPPET: note -->
 * 
 * If Jsp is used as the template, the jsp template itself must lie within the 
 * webapp itself and not the classpath. Unlike Freemarker or Velocity, JSP template
 * could not be picked up from the classpath.
 * 
 * <!-- END SNIPPET: note -->
 *
 * @s.tag name="component" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.ComponentTag"
 * description="Render a custom ui widget"
 */
public class GenericUIBean extends UIBean {
    private final static String TEMPLATE = "empty";

    public GenericUIBean(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    public boolean contains(Object obj1, Object obj2) {
        return ContainUtil.contains(obj1, obj2);
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }
}
"
core/src/main/java/org/apache/struts2/components/Head.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.StrutsConstants;
import org.apache.struts2.config.Settings;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 *
 * Renders parts of the HEAD section for an HTML file. This is useful as some themes require certain CSS and JavaScript
 * includes.<p/>
 *
 * If, for example, your page has ajax components integrated, without having the default theme set to ajax, you might
 * want to use the head tag with <b>theme="ajax"</b> so that the typical ajax header setup will be included in the
 * page.<p/>
 *
 * The tag also includes the option to set a custom datepicker theme if needed. See calendarcss parameter for
 * description for details.<p/>
 *
 * If you use the ajax theme you can turn a debug flag on by setting the debug parameter to <tt>true</tt>.
 *
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 *
 * <pre>
 * <!-- START SNIPPET: example1 -->
 * &lt;head&gt;
 *   &lt;title&gt;My page&lt;/title&gt;
 *   &lt;s:head/&gt;
 * &lt;/head&gt;
 * <!-- END SNIPPET: example1 -->
 * </pre>
 *
 * <pre>
 * <!-- START SNIPPET: example2 -->
 * &lt;head&gt;
 *   &lt;title&gt;My page&lt;/title&gt;
 *   &lt;s:head theme="ajax" calendarcss="calendar-green"/&gt;
 * &lt;/head&gt;
 * <!-- END SNIPPET: example2 -->
 * </pre>
 *
 * <pre>
 * <!-- START SNIPPET: example3 -->
 * &lt;head&gt;
 *   &lt;title&gt;My page&lt;/title&gt;
 *   &lt;s:head theme="ajax" debug="true"/&gt;
 * &lt;/head&gt;
 * <!-- END SNIPPET: example3 -->
 * </pre>
 *
 * @s.tag name="head" tld-body-content="empty" tld-tag-class="org.apache.struts2.views.jsp.ui.HeadTag"
 * description="Render a chunk of HEAD for your HTML file"
 */
public class Head extends UIBean {
    public static final String TEMPLATE = "head";

    private String calendarcss = "calendar-blue.css";
    private boolean debug;

    public Head(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }

    public void evaluateParams() {
        super.evaluateParams();

        if (calendarcss != null) {
            String css = findString(calendarcss);
            if (css != null && css.trim().length() > 0) {
                if (css.lastIndexOf(".css") < 0) {
                    addParameter("calendarcss", css + ".css");
                } else {
                    addParameter("calendarcss", css);
                }
            }
        }

        addParameter("encoding", Settings.get(StrutsConstants.STRUTS_I18N_ENCODING));
        addParameter("debug", Boolean.valueOf(debug).toString());
    }

    public String getCalendarcss() {
        return calendarcss;
    }

    /**
     * The jscalendar css theme to use" default="calendar-blue.css
     * @s.tagattribute required="false"
     */
    public void setCalendarcss(String calendarcss) {
        this.calendarcss = calendarcss;
    }

    public boolean isDebug() {
        return debug;
    }

    /**
     * Set to true to enable debugging mode for AJAX themes
     * @s.tagattribute required="false"
     */
    public void setDebug(boolean debug) {
        this.debug = debug;
    }


}
"
core/src/main/java/org/apache/struts2/components/Hidden.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * Renders an HTML input element of type hidden, populated by the specified property from the OgnlValueStack.
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * &lt;-- example one --&gt;
 * &lt;s:hidden name="foo" /&gt;
 * &lt;-- example two --&gt;
 * &lt;s:hidden name="foo" value="bar" /&gt;
 *
 * Example One Resulting HTML (if foo evaluates to bar):
 * &lt;input type="hidden" name="foo" value="bar" /&gt;
 * Example Two Resulting HTML (if getBar method of the action returns 'bar')
 * &lt;input type="hidden" name="foo" value="bar" /&gt;
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @s.tag name="hidden" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.HiddenTag"
 * description="Render a hidden input field"
  */
public class Hidden extends UIBean {
    final public static String TEMPLATE = "hidden";

    public Hidden(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }
}
"
core/src/main/java/org/apache/struts2/components/I18n.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.io.Writer;
import java.util.Locale;
import java.util.ResourceBundle;

import org.apache.struts2.StrutsException;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.LocaleProvider;
import com.opensymphony.xwork2.TextProviderSupport;
import com.opensymphony.xwork2.util.LocalizedTextUtil;
import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * 
 * Gets a resource bundle and place it on the value stack. This allows
 * the text tag to access messages from any bundle, and not just the bundle
 * associated with the current action.
 * 
 * <!-- END SNIPPET: javadoc -->
 * 
 * <p/>
 * 
 * <!-- START SNIPPET: params-->
 * 
 * <ul>
 * 		<li>name* - the resource bundle's name (eg foo/bar/customBundle)</li>
 * </ul>
 * 
 * <!-- END SNIPPET: params -->
 * 
 * <p/>
 * 
 * Example:
 * 
 * <pre>
 * <!-- START SNIPPET: example -->
 * 
 * &lt;s:i18n name="myCustomBundle"&gt;
 *    The i18n value for key aaa.bbb.ccc in myCustomBundle is &lt;s:property value="text('aaa.bbb.ccc')" /&gt;
 * &lt;/s:i18n&gt;
 * 
 * <!-- END SNIPPET: example -->
 * </pre>
 * 
 * 
 * <pre>
 * <!-- START SNIPPET: i18nExample -->
 * 
 * &lt;s:i18n name="some.package.bundle" &gt;
 *      &lt;s:text name="some.key" /&gt;
 * &lt;/s:i18n&gt;
 * 
 * <!-- END SNIPPET: i18nExample -->
 * </pre>
 * 
 * @s.tag name="i18n" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.I18nTag"
 * description="Get a resource bundle and place it on the value stack"
 */
public class I18n extends Component {
    protected boolean pushed;
    protected String name;

    public I18n(OgnlValueStack stack) {
        super(stack);
    }

    public boolean start(Writer writer) {
        boolean result = super.start(writer);

        try {
            String name = this.findString(this.name, "name", "Resource bundle name is required. Example: foo or foo_en");
            ResourceBundle bundle = (ResourceBundle) findValue("texts('" + name + "')");

            if (bundle == null) {
                bundle = LocalizedTextUtil.findResourceBundle(name, (Locale) getStack().getContext().get(ActionContext.LOCALE));
            }

            if (bundle != null) {
                final Locale locale = (Locale) getStack().getContext().get(ActionContext.LOCALE);
                getStack().push(new TextProviderSupport(bundle, new LocaleProvider() {
                    public Locale getLocale() {
                        return locale;
                    }
                }));
                pushed = true;
            }
        } catch (Exception e) {
            String msg = "Could not find the bundle " + name;
            throw new StrutsException(msg, e);
        }

        return result;
    }

    public boolean end(Writer writer, String body) {
        if (pushed) {
            getStack().pop();
        }

        return super.end(writer, body);
    }

    /**
     * Name of ressource bundle to use (eg foo/bar/customBundle)
     * @s.tagattribute required="true" default="String"
     */
    public void setName(String name) {
        this.name = name;
    }
}
"
core/src/main/java/org/apache/struts2/components/If.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.io.Writer;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 *
 * <p>Perform basic condition flow. 'If' tag could be used by itself or
 * with 'Else If' Tag and/or single/multiple 'Else' Tag.</p>
 *
 * <!-- END SNIPPET: javadoc -->
 *
 *
 * <!-- START SNIPPET: params -->
 *
 * <ul>
 *
 *  <li>test* (Boolean) - Logic to determined if body of tag is to be displayed</li>
 *
 * </ul>
 *
 * <!-- END SNIPPET: params -->
 *
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 *  &lt;s:if test="%{false}"&gt;
 *	    &lt;div&gt;Will Not Be Executed&lt;/div&gt;
 *  &lt;/s:if&gt;
 * 	&lt;s:elseif test="%{true}"&gt;
 *	    &lt;div&gt;Will Be Executed&lt;/div&gt;
 *  &lt;s:else&gt;
 *  &lt;/s:elseif&gt;
 *	    &lt;div&gt;Will Not Be Executed&lt;/div&gt;
 *  &lt;/s:else&gt;
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @see Else
 * @see ElseIf
 *
 * @s.tag name="if" tld-body-content="JSP" description="If tag" tld-tag-class="org.apache.struts2.views.jsp.IfTag"
 */
public class If extends Component {
    public static final String ANSWER = "struts.if.answer";

    Boolean answer;
    String test;

    /**
     * Expression to determine if body of tag is to be displayed
     * @s.tagattribute required="true" type="Boolean"
     */
    public void setTest(String test) {
        this.test = test;
    }

    public If(OgnlValueStack stack) {
        super(stack);
    }

    public boolean start(Writer writer) {
        answer = (Boolean) findValue(test, Boolean.class);

        if (answer == null) {
            answer = Boolean.FALSE;
        }
        stack.getContext().put(ANSWER, answer);
        return answer.booleanValue();
    }

    public boolean end(Writer writer, String body) {
    	stack.getContext().put(ANSWER, answer);
        return super.end(writer, body);
    }
}
"
core/src/main/java/org/apache/struts2/components/Include.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.Writer;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.StringTokenizer;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.ServletRequest;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.RequestUtils;
import org.apache.struts2.StrutsConstants;
import org.apache.struts2.config.Settings;
import org.apache.struts2.util.FastByteArrayOutputStream;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * <p>Include a servlet's output (result of servlet or a JSP page).</p>
 * <p>Note: Any additional params supplied to the included page are <b>not</b> accessible within the rendered page
 * through the &lt;s:property...&gt; tag!</p>
 * <!-- END SNIPPET: javadoc -->
 *
 *
 * <!-- START SNIPPET: params -->
 * <ul>
 * 		<li>value* (String) - jsp page to be included</li>
 * </ul>
 * <!-- END SNIPPET: params -->
 *
 *
 * <p/> <b>Examples</b>
 * <pre>
 * <!-- START SNIPPET: example -->
 * &lt;-- One: --&gt;
 * &lt;s:include value="myJsp.jsp" /&gt;
 *
 * &lt;-- Two: --&gt;
 * &lt;s:include value="myJsp.jsp"&gt;
 *    &lt;s:param name="param1" value="value2" /&gt;
 *    &lt;s:param name="param2" value="value2" /&gt;
 * &lt;/s:include&gt;
 *
 * &lt;-- Three: --&gt;
 * &lt;s:include value="myJsp.jsp"&gt;
 *    &lt;s:param name="param1"&gt;value1&lt;/s:param&gt;
 *    &lt;s:param name="param2"&gt;value2&lt;s:param&gt;
 * &lt;/s:include&gt;
 * <!-- END SNIPPET: example -->
 *
 * <!-- START SNIPPET: exampledescription -->
 * Example one - do an include myJsp.jsp page
 * Example two - do an include to myJsp.jsp page with parameters param1=value1 and param2=value2
 * Example three - do an include to myJsp.jsp page with parameters param1=value1 and param2=value2
 * <!-- END SNIPPET: exampledescription -->
 * </pre>
 *
 * @s.tag name="include" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.IncludeTag"
 * description="Include a servlet's output (result of servlet or a JSP page)"
 */
public class Include extends Component {

	private static final Log _log = LogFactory.getLog(Include.class);

    private static String encoding;
    private static boolean encodingDefined = true;

    protected String value;
    private HttpServletRequest req;
    private HttpServletResponse res;

    public Include(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack);
        this.req = req;
        this.res = res;
    }

    public boolean end(Writer writer, String body) {
        String page = findString(value, "value", "You must specify the URL to include. Example: /foo.jsp");
        StringBuffer urlBuf = new StringBuffer();

        // Add URL
        urlBuf.append(page);

        // Add request parameters
        if (parameters.size() > 0) {
            urlBuf.append('?');

            String concat = "";

            // Set parameters
            Iterator iter = parameters.entrySet().iterator();

            while (iter.hasNext()) {
                Map.Entry entry = (Map.Entry) iter.next();
                Object name = entry.getKey();
                List values = (List) entry.getValue();

                for (int i = 0; i < values.size(); i++) {
                    urlBuf.append(concat);
                    urlBuf.append(name);
                    urlBuf.append('=');

                    try {
                        urlBuf.append(URLEncoder.encode(values.get(i).toString(), "UTF-8"));
                    } catch (Exception e) {
                    	_log.warn("unable to url-encode "+values.get(i).toString()+", it will be ignored");
                    }

                    concat = "&";
                }
            }
        }

        String result = urlBuf.toString();

        // Include
        try {
            include(result, writer, req, res);
        } catch (Exception e) {
            LogFactory.getLog(getClass()).warn("Exception thrown during include of " + result, e);
        }

        return super.end(writer, body);
    }

    /**
     * The jsp/servlet output to include
     * @s.tagattribute required="true" type="String"
     */
    public void setValue(String value) {
        this.value = value;
    }

    public static String getContextRelativePath(ServletRequest request, String relativePath) {
        String returnValue;

        if (relativePath.startsWith("/")) {
            returnValue = relativePath;
        } else if (!(request instanceof HttpServletRequest)) {
            returnValue = relativePath;
        } else {
            HttpServletRequest hrequest = (HttpServletRequest) request;
            String uri = (String) request.getAttribute("javax.servlet.include.servlet_path");

            if (uri == null) {
                uri = RequestUtils.getServletPath(hrequest);
            }

            returnValue = uri.substring(0, uri.lastIndexOf('/')) + '/' + relativePath;
        }

        // .. is illegal in an absolute path according to the Servlet Spec and will cause
        // known problems on Orion application servers.
        if (returnValue.indexOf("..") != -1) {
            Stack stack = new Stack();
            StringTokenizer pathParts = new StringTokenizer(returnValue.replace('\\', '/'), "/");

            while (pathParts.hasMoreTokens()) {
                String part = pathParts.nextToken();

                if (!part.equals(".")) {
                    if (part.equals("..")) {
                        stack.pop();
                    } else {
                        stack.push(part);
                    }
                }
            }

            StringBuffer flatPathBuffer = new StringBuffer();

            for (int i = 0; i < stack.size(); i++) {
                flatPathBuffer.append("/").append(stack.elementAt(i));
            }

            returnValue = flatPathBuffer.toString();
        }

        return returnValue;
    }

    public void addParameter(String key, Object value) {
        // don't use the default implementation of addParameter,
        // instead, include tag requires that each parameter be a list of objects,
        // just like the HTTP servlet interfaces are (String[]) 
        if (value != null) {
            List currentValues = (List) parameters.get(key);

            if (currentValues == null) {
                currentValues = new ArrayList();
                parameters.put(key, currentValues);
            }

            currentValues.add(value);
        }
    }

    public static void include(String aResult, Writer writer, ServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String resourcePath = getContextRelativePath(request, aResult);
        RequestDispatcher rd = request.getRequestDispatcher(resourcePath);

        if (rd == null) {
            throw new ServletException("Not a valid resource path:" + resourcePath);
        }

        PageResponse pageResponse = new PageResponse(response);

        // Include the resource
        rd.include((HttpServletRequest) request, pageResponse);

        //write the response back to the JspWriter, using the correct encoding.
        String encoding = getEncoding();

        if (encoding != null) {
            //use the encoding specified in the property file
            pageResponse.getContent().writeTo(writer, encoding);
        } else {
            //use the platform specific encoding
            pageResponse.getContent().writeTo(writer, null);
        }
    }

    /**
     * Get the encoding specified by the property 'struts.i18n.encoding' in struts.properties,
     * or return the default platform encoding if not specified.
     * <p/>
     * Note that if the property is not initially defined, this will return the system default,
     * even if the property is later defined.  This is mainly for performance reasons.  Undefined
     * properties throw exceptions, which are a costly operation.
     * <p/>
     * If the property is initially defined, it is read every time, until is is undefined, and then
     * the system default is used.
     * <p/>
     * Why not cache it completely?  Some applications will wish to be able to dynamically set the
     * encoding at runtime.
     *
     * @return The encoding to be used.
     */
    private static String getEncoding() {
        if (encodingDefined) {
            try {
                encoding = Settings.get(StrutsConstants.STRUTS_I18N_ENCODING);
            } catch (IllegalArgumentException e) {
                encoding = System.getProperty("file.encoding");
                encodingDefined = false;
            }
        }

        return encoding;
    }


    /**
     * Implementation of ServletOutputStream that stores all data written
     * to it in a temporary buffer accessible from {@link #getBuffer()} .
     *
     * @author <a href="joe@truemesh.com">Joe Walnes</a>
     * @author <a href="mailto:scott@atlassian.com">Scott Farquhar</a>
     */
    static final class PageOutputStream extends ServletOutputStream {

        private FastByteArrayOutputStream buffer;


        public PageOutputStream() {
            buffer = new FastByteArrayOutputStream();
        }


        /**
         * Return all data that has been written to this OutputStream.
         */
        public FastByteArrayOutputStream getBuffer() throws IOException {
            flush();

            return buffer;
        }

        public void close() throws IOException {
            buffer.close();
        }

        public void flush() throws IOException {
            buffer.flush();
        }

        public void write(byte[] b, int o, int l) throws IOException {
            buffer.write(b, o, l);
        }

        public void write(int i) throws IOException {
            buffer.write(i);
        }

        public void write(byte[] b) throws IOException {
            buffer.write(b);
        }
    }


    /**
     * Simple wrapper to HTTPServletResponse that will allow getWriter()
     * and getResponse() to be called as many times as needed without
     * causing conflicts.
     * <p/>
     * The underlying outputStream is a wrapper around
     * {@link PageOutputStream} which will store
     * the written content to a buffer.
     * <p/>
     * This buffer can later be retrieved by calling {@link #getContent}.
     *
     * @author <a href="mailto:joe@truemesh.com">Joe Walnes</a>
     * @author <a href="mailto:scott@atlassian.com">Scott Farquhar</a>
     */
    static final class PageResponse extends HttpServletResponseWrapper {

        protected PrintWriter pagePrintWriter;
        protected ServletOutputStream outputStream;
        private PageOutputStream pageOutputStream = null;


        /**
         * Create PageResponse wrapped around an existing HttpServletResponse.
         */
        public PageResponse(HttpServletResponse response) {
            super(response);
        }


        /**
         * Return the content buffered inside the {@link PageOutputStream}.
         *
         * @return
         * @throws IOException
         */
        public FastByteArrayOutputStream getContent() throws IOException {
            //if we are using a writer, we need to flush the
            //data to the underlying outputstream.
            //most containers do this - but it seems Jetty 4.0.5 doesn't
            if (pagePrintWriter != null) {
                pagePrintWriter.flush();
            }

            return ((PageOutputStream) getOutputStream()).getBuffer();
        }

        /**
         * Return instance of {@link PageOutputStream}
         * allowing all data written to stream to be stored in temporary buffer.
         */
        public ServletOutputStream getOutputStream() throws IOException {
            if (pageOutputStream == null) {
                pageOutputStream = new PageOutputStream();
            }

            return pageOutputStream;
        }

        /**
         * Return PrintWriter wrapper around PageOutputStream.
         */
        public PrintWriter getWriter() throws IOException {
            if (pagePrintWriter == null) {
                pagePrintWriter = new PrintWriter(new OutputStreamWriter(getOutputStream(), getCharacterEncoding()));
            }

            return pagePrintWriter;
        }
    }
}
"
core/src/main/java/org/apache/struts2/components/IteratorComponent.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.io.Writer;
import java.util.Iterator;

import org.apache.struts2.util.MakeIterator;
import org.apache.struts2.views.jsp.IteratorStatus;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 *
 * <p>Iterator will iterate over a value. An iterable value can be either of: java.util.Collection, java.util.Iterator,
 * java.util.Enumeration, java.util.Map, array.</p> <p/> <!-- END SNIPPET: javadoc -->
 *
 * <!-- START SNIPPET: params -->
 *
 * <ul>
 *
 * <li>status (String) - if specified, an instanceof IteratorStatus will be pushed into stack upon each iteration</li>
 *
 * <li>value (Object) - the source to iterate over, must be iteratable, else an the object itself will be put into a
 * newly created List (see MakeIterator#convert(Object)</li>
 *
 * <li>id (String) - if specified the current iteration object will be place with this id in Struts stack's context
 * scope</li>
 *
 * </ul>
 *
 * <!-- END SNIPPET: params -->
 *
 * <!-- START SNIPPET: example1description -->
 *
 * <p>The following example retrieves the value of the getDays() method of the current object on the value stack and
 * uses it to iterate over. The &lt;s:property/&gt; tag prints out the current value of the iterator.</p>
 *
 * <!-- END SNIPPET: example1description -->
 *
 * <pre>
 * <!-- START SNIPPET: example1code -->
 * &lt;s:iterator value="days"&gt;
 *   &lt;p&gt;day is: &lt;s:property/&gt;&lt;/p&gt;
 * &lt;/s:iterator&gt;
 * <!-- END SNIPPET: example1code -->
 * </pre>
 *
 *
 * <!-- START SNIPPET: example2description -->
 *
 * <p>The following example uses a {@link Bean} tag and places it into the ActionContext. The iterator tag will retrieve
 * that object from the ActionContext and then calls its getDays() method as above. The status attribute is also used to
 * create a {@link IteratorStatus} object, which in this example, its odd() method is used to alternate row
 * colours:</p>
 *
 * <!-- END SNIPPET: example2description -->
 * 
 * 
 * <pre>
 * <!-- START SNIPPET: example2code -->
 * 
 * &lt;s:bean name="org.apache.struts2.example.IteratorExample" id="it"&gt;
 *   &lt;s:param name="day" value="'foo'"/&gt;
 *   &lt;s:param name="day" value="'bar'"/&gt;
 * &lt;/s:bean&gt;
 * <p/>
 * &lt;table border="0" cellspacing="0" cellpadding="1"&gt;
 * &lt;tr&gt;
 *   &lt;th&gt;Days of the week&lt;/th&gt;
 * &lt;/tr&gt;
 * <p/>
 * &lt;s:iterator value="#it.days" status="rowstatus"&gt;
 *   &lt;tr&gt;
 *     &lt;s:if test="#rowstatus.odd == true"&gt;
 *       &lt;td style="background: grey"&gt;&lt;s:property/&gt;&lt;/td&gt;
 *     &lt;/s:if&gt;
 *     &lt;s:else&gt;
 *       &lt;td&gt;&lt;s:property/&gt;&lt;/td&gt;
 *     &lt;/s:else&gt;
 *   &lt;/tr&gt;
 * &lt;/s:iterator&gt;
 * &lt;/table&gt;
 * 
 * <!-- END SNIPPET: example2code -->
 * </pre>
 *
 * <!--START SNIPPET: example3description -->
 *
 * <p> The next example will further demonstrate the use of the status attribute, using a DAO obtained from the action
 * class through OGNL, iterating over groups and their users (in a security context). The last() method indicates if the
 * current object is the last available in the iteration, and if not, we need to seperate the users using a comma: </p>
 *
 * <!-- END SNIPPET: example3description -->
 *
 * <pre>
 * <!-- START SNIPPET: example3code -->
 * 
 * 	&lt;s:iterator value="groupDao.groups" status="groupStatus"&gt;
 * 		&lt;tr class="&lt;s:if test="#groupStatus.odd == true "&gt;odd&lt;/s:if&gt;&lt;s:else&gt;even&lt;/s:else&gt;"&gt;
 * 			&lt;td&gt;&lt;s:property value="name" /&gt;&lt;/td&gt;
 * 			&lt;td&gt;&lt;s:property value="description" /&gt;&lt;/td&gt;
 * 			&lt;td&gt;
 * 				&lt;s:iterator value="users" status="userStatus"&gt;
 * 					&lt;s:property value="fullName" /&gt;&lt;s:if test="!#userStatus.last"&gt;,&lt;/s:if&gt;
 * 				&lt;/s:iterator&gt;
 * 			&lt;/td&gt;
 * 		&lt;/tr&gt;
 * 	&lt;/s:iterator&gt;
 * 
 * <!-- END SNIPPET: example3code -->
 * </pre>
 * <p>
 *
 * <!-- START SNIPPET: example4description -->
 *
 * </p> The next example iterates over a an action collection and passes every iterator value to another action. The
 * trick here lies in the use of the '[0]' operator. It takes the current iterator value and passes it on to the edit
 * action. Using the '[0]' operator has the same effect as using &gt;s:property /&gt;. (The latter, however, does not
 * work from inside the param tag). </p>
 *
 * <!-- END SNIPPET: example4description -->
 *
 * <pre>
 * <!-- START SNIPPET: example4code -->
 * 
 * 		&lt;s:action name="entries" id="entries"/&gt;
 * 		&lt;s:iterator value="#entries.entries" &gt;
 * 			&lt;s:property value="name" /&gt;
 * 			&lt;s:property /&gt;
 * 			&lt;s:push value="..."&gt;
 * 				&lt;s:action name="edit" id="edit" &gt;
 * 					&lt;s:param name="entry" value="[0]" /&gt;
 * 				&lt;/s:action&gt;
 * 			&lt;/push&gt;
 * 		&lt;/s:iterator&gt;
 * 
 * <!-- END SNIPPET: example4code -->
 * </pre>
 * 
 * <!-- START SNIPPET: example5description -->
 * 
 * </p>To simulate a simple loop with iterator tag, the following could be done. 
 * It does the loop 5 times.
 * 
 * <!-- END SNIPPET: example5description -->
 * 
 * <pre>
 * <!-- START SNIPPET: example5code -->
 * 
 * &lt;s:iterator status="stat" value="{1,2,3,4,5}" &gt;
 *    &lt;!-- grab the index (start with 0 ... ) --&gt;
 *    &lt;s:property value="#stat.index" /&gt;
 *    
 *    &lt;!-- grab the top of the stack which should be the --&gt;
 *    &lt;!-- current iteration value (0, 1, ... 5) --&gt;
 *    &lt;s:property value="top" /&gt;
 * &lt;/s:iterator&gt;
 * 
 * <!-- END SNIPPET: example5code -->
 * </pre>
 * 
 * @s.tag name="iterator" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.IteratorTag"
 * description="Iterate over a iterable value"
 */
public class IteratorComponent extends Component {
    protected Iterator iterator;
    protected IteratorStatus status;
    protected Object oldStatus;
    protected IteratorStatus.StatusState statusState;
    protected String statusAttr;
    protected String value;

    public IteratorComponent(OgnlValueStack stack) {
        super(stack);
    }

    public boolean start(Writer writer) {
        //Create an iterator status if the status attribute was set.
        if (statusAttr != null) {
            statusState = new IteratorStatus.StatusState();
            status = new IteratorStatus(statusState);
        }

        OgnlValueStack stack = getStack();

        if (value == null) {
            value = "top";
        }
        iterator = MakeIterator.convert(findValue(value));
        
        // get the first
        if ((iterator != null) && iterator.hasNext()) {
            Object currentValue = iterator.next();
            stack.push(currentValue);

            String id = getId();
            
            if ((id != null) && (currentValue != null)) {
                //pageContext.setAttribute(id, currentValue);
                //pageContext.setAttribute(id, currentValue, PageContext.REQUEST_SCOPE);
            	stack.getContext().put(id, currentValue);
            }

            // Status object
            if (statusAttr != null) {
                statusState.setLast(!iterator.hasNext());
                oldStatus = stack.getContext().get(statusAttr);
                stack.getContext().put(statusAttr, status);
            }

            return true;
        } else {
        	super.end(writer, "");
            return false;
        }
    }

    public boolean end(Writer writer, String body) {
        OgnlValueStack stack = getStack();
        if (iterator != null) {
            stack.pop();
        }

        if (iterator!=null && iterator.hasNext()) {
            Object currentValue = iterator.next();
            stack.push(currentValue);

            String id = getId();

            if ((id != null) && (currentValue != null)) {
                //pageContext.setAttribute(id, currentValue);
                //pageContext.setAttribute(id, currentValue, PageContext.REQUEST_SCOPE);
            	stack.getContext().put(id, currentValue);
            }

            // Update status
            if (status != null) {
                statusState.next(); // Increase counter
                statusState.setLast(!iterator.hasNext());
            }

            return true;
        } else {
            // Reset status object in case someone else uses the same name in another iterator tag instance
            if (status != null) {
                if (oldStatus == null) {
                    stack.getContext().put(statusAttr, null);
                } else {
                    stack.getContext().put(statusAttr, oldStatus);
                }
            }
            super.end(writer, "");
            return false;
        }
    }

    /**
     * if specified, an instanceof IteratorStatus will be pushed into stack upon each iteration
     * @s.tagattribute required="false" type="Boolean" default="false"
     */
    public void setStatus(String status) {
        this.statusAttr = status;
    }

    /**
     * the iteratable source to iterate over, else an the object itself will be put into a newly created List
     * @s.tagattribute required="false"
     */
    public void setValue(String value) {
        this.value = value;
    }

}
"
core/src/main/java/org/apache/struts2/components/Label.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * Renders an HTML LABEL that will allow you to output label:name combination that has the same format treatment as
 * the rest of your UI controls.</p>
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 * <p/>
 * <!-- START SNIPPET: exdescription -->
 * In this example, a label is rendered. The label is retrieved from a ResourceBundle by calling ActionSupport's
 * getText() method giving you an output of 'User Name:tm_jee'. Assuming that i18n message user_name corresponds
 * to 'User Name' and the action's getUserName() method returns 'tm_jee'<p/>
 * <!-- END SNIPPET: exdescription -->
 * <pre>
 * <!-- START SNIPPET: example -->
 * &lt;s:label label="%{text('user_name')}" name="userName" /&gt;
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @s.tag name="label" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.LabelTag"
 * description="Render a label that displays read-only information"
 */
public class Label extends UIBean {
    final public static String TEMPLATE = "label";

    protected String forAttr;

    public Label(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }

    protected void evaluateExtraParams() {
        super.evaluateExtraParams();

        if (forAttr != null) {
            addParameter("for", findString(forAttr));
        }

        // try value first, then name (this overrides the default behavior in the superclass)
        if (value != null) {
            addParameter("nameValue", findString(value));
        } else if (name != null) {
            String expr = name;
            if (altSyntax()) {
                expr = "%{" + expr + "}";
            }

            addParameter("nameValue", findString(expr));
        }
    }

    /**
     * HTML for attribute
     * @s.tagattribute required="false"
     */
    public void setFor(String forAttr) {
        this.forAttr = forAttr;
    }
}
"
core/src/main/java/org/apache/struts2/components/ListUIBean.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.lang.reflect.Array;
import java.util.Collection;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.util.ContainUtil;
import org.apache.struts2.util.MakeIterator;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * DoubleListUIBean is the standard superclass of all Struts list handling components.
 *
 * <p/>
 * 
 * <!-- START SNIPPET: javadoc -->
 * 
 * Note that the listkey and listvalue attribute will default to "key" and "value"
 * respectively only when the list attribute is evaluated to a Map or its decendant.
 * Other thing else, will result in listkey and listvalue to be null and not used.
 * 
 * <!-- END SNIPPET: javadoc -->
 *
 */
public abstract class ListUIBean extends UIBean {
    protected Object list;
    protected String listKey;
    protected String listValue;
    
    // indicate if an exception is to be thrown when value attribute is null
    protected boolean throwExceptionOnNullValueAttribute = false; 

    protected ListUIBean(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    public void evaluateExtraParams() {
        Object value = null;

        if (list == null) {
            list = parameters.get("list");
        }

        if (list instanceof String) {
            value = findValue((String) list);
        } else if (list instanceof Collection) {
            value = list;
        } else if (MakeIterator.isIterable(list)) {
            value = MakeIterator.convert(list);
        }
        if (value == null) {
        	if (throwExceptionOnNullValueAttribute) {
        		// will throw an exception if not found
        		value = findValue((list == null) ? (String) list : list.toString(), "list",
                    "The requested list key '" + list + "' could not be resolved as a collection/array/map/enumeration/iterator type. " +
                    "Example: people or people.{name}");
        	}
        	else {
        		// ww-1010, allows value with null value to be compatible with ww 
        		// 2.1.7 behaviour
        		value = findValue((list == null)?(String) list:list.toString());
        	}
        }

        if (value instanceof Collection) {
            addParameter("list", value);
        } else {
            addParameter("list", MakeIterator.convert(value));
        }

        if (value instanceof Collection) {
            addParameter("listSize", new Integer(((Collection) value).size()));
        } else if (value instanceof Map) {
            addParameter("listSize", new Integer(((Map) value).size()));
        } else if (value != null && value.getClass().isArray()) {
            addParameter("listSize", new Integer(Array.getLength(value)));
        }

        if (listKey != null) {
            addParameter("listKey", listKey);
        } else if (value instanceof Map) {
            addParameter("listKey", "key");
        }

        if (listValue != null) {
            if (altSyntax()) {
                // the same logic as with findValue(String)
                // if value start with %{ and end with }, just cut it off!
                if (listValue.startsWith("%{") && listValue.endsWith("}")) {
                    listValue = listValue.substring(2, listValue.length() - 1);
                }
            }
            addParameter("listValue", listValue);
        } else if (value instanceof Map) {
            addParameter("listValue", "value");
        }
    }

    public boolean contains(Object obj1, Object obj2) {
        return ContainUtil.contains(obj1, obj2);
    }

    protected Class getValueClassType() {
        return null; // don't convert nameValue to anything, we need the raw value
    }

    /**
     * Iterable source to populate from. If the list is a Map (key, value), the Map key will become the option "value" parameter and the Map value will become the option body.
     * @s.tagattribute required="true"
     */
    public void setList(Object list) {
        this.list = list;
    }

    /**
     * Property of list objects to get field value from
     * @s.tagattribute required="false"
     */
    public void setListKey(String listKey) {
        this.listKey = listKey;
    }

    /**
     * Property of list objects to get field content from
     * @s.tagattribute required="false"
      */
    public void setListValue(String listValue) {
        this.listValue = listValue;
    }
    
    
    public void setThrowExceptionOnNullValueAttribute(boolean throwExceptionOnNullValueAttribute) {
    	this.throwExceptionOnNullValueAttribute = throwExceptionOnNullValueAttribute;
    }
}
"
core/src/main/java/org/apache/struts2/components/MergeIterator.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.io.Writer;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.components.Param.UnnamedParametric;
import org.apache.struts2.util.MakeIterator;
import org.apache.struts2.util.MergeIteratorFilter;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * <p>Component for MergeIteratorTag, which job is to merge iterators and successive 
 * call to the merged iterator will cause each merge iterator to have a chance to 
 * expose its element, subsequently next call will allow the next iterator to expose 
 * its element. Once the last iterator is done exposing its element, the first iterator
 * is allowed to do so again (unless it is exhausted of entries).</P>
 * 
 * <p>Internally the task are delegated to MergeIteratorFilter</p>
 * 
 * <p>Example if there are 3 lists being merged, each list have 3 entries, the following will
 * be the logic.</P>
 * <ol>
 * 		<li>Display first element of the first list</li>
 * 		<li>Display first element of the second list</li>
 * 		<li>Display first element of the third list</li>
 *      <li>Display second element of the first list</li>
 *      <li>Display second element of the second list</li>
 *      <li>Display second element of the third list</li>
 *      <li>Display third element of the first list</li>
 *      <li>Display thrid element of the second list</li>
 *      <li>Display third element of the thrid list</li>
 * </ol>
 * <!-- END SNIPPET: javadoc -->
 * 
 * <!-- START SNIPPET: params -->
 * <ul>
 * 			<li>id (String) - the id where the resultant merged iterator will be stored in the stack's context</li>
 * </ul>
 * <!-- END SNIPPET: params -->
 * 
 * 
 * <!-- START SNIPPET: javacode -->
 * public class MergeIteratorTagAction extends ActionSupport {
 *
 *	private List myList1;
 *	private List myList2;
 *	private List myList3;
 *	
 *	public List getMyList1() {
 *		return myList1;
 *	}
 *	
 *	public List getMyList2() {
 *		return myList2;
 *	}
 *	
 *	public List getMyList3() {
 *		return myList3;
 *	}
 *	
 *	
 *	public String execute() throws Exception {
 *		
 *		myList1 = new ArrayList();
 *		myList1.add("1");
 *		myList1.add("2");
 *		myList1.add("3");
 *		
 *		myList2 = new ArrayList();
 *		myList2.add("a");
 *		myList2.add("b");
 *		myList2.add("c");
 *		
 *		myList3 = new ArrayList();
 *		myList3.add("A");
 *		myList3.add("B");
 *		myList3.add("C");
 *		
 *		return "done";
 *	}
 * }
 * <!-- END SNIPPET: javacode -->
 *
 * <!-- START SNIPPET: example -->
 * &lt;s:merge id="myMergedIterator1"&gt;
 *		&lt;s:param value="%{myList1}" /&gt;
 *		&lt;s:param value="%{myList2}" /&gt;
 *		&lt;s:param value="%{myList3}" /&gt;
 * &lt;/s:merge&gt;
 * &lt;s:iterator value="%{#myMergedIterator1}"&gt;
 *		&lt;s:property /&gt;
 * &lt;/s:iterator&gt;
 * <!-- END SNIPPET: example -->
 *
 * <!-- START SNIPPET: description -->
 * This wil generate "1aA2bB3cC".
 * <!-- START SNIPPET: description -->
 *
 * @see org.apache.struts2.util.MergeIteratorFilter
 * @see org.apache.struts2.views.jsp.iterator.MergeIteratorTag
 *
 * @s.tag name="merge" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.iterator.MergeIteratorTag"
 * description="Merge the values of a list of iterators into one iterator"
 */
public class MergeIterator extends Component implements UnnamedParametric {
	
	private static final Log _log = LogFactory.getLog(MergeIterator.class);
	
	private MergeIteratorFilter mergeIteratorFilter = null;
	private List _parameters;

	public MergeIterator(OgnlValueStack stack) {
		super(stack);
	}
	
	public boolean start(Writer writer) {
		
		mergeIteratorFilter = new MergeIteratorFilter();
		_parameters = new ArrayList();

        return super.start(writer);
    }
	
	public boolean end(Writer writer, String body) {
		
		for (Iterator parametersIterator = _parameters.iterator(); parametersIterator.hasNext(); ) {
			Object iteratorEntryObj = parametersIterator.next();
			if (! MakeIterator.isIterable(iteratorEntryObj)) {
				_log.warn("param with value resolved as "+iteratorEntryObj+" cannot be make as iterator, it will be ignored and hence will not appear in the merged iterator");
				continue;
			}
			mergeIteratorFilter.setSource(MakeIterator.convert(iteratorEntryObj));
		}
		
		mergeIteratorFilter.execute();

		// if id exists, we put it in the stack's context
		if (getId() != null && getId().length() > 0) {
			getStack().getContext().put(getId(), mergeIteratorFilter);
		}
		
		mergeIteratorFilter = null;

        return super.end(writer, body);
    }

    /**
     * the id where the resultant merged iterator will be stored in the stack's context
     * @s.tagattribute required="false"
     */
    public void setId(String id) {
        super.setId(id);
    }

    // == UnnamedParametric interface implementation ---------------------
	public void addParameter(Object value) {
		_parameters.add(value);
	}
}
"
core/src/main/java/org/apache/struts2/components/OptGroup.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.io.Writer;
import java.util.ArrayList;
import java.util.List;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 *
 * Create a optgroup component which needs to resides within a select tag.
 *
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/>
 *
 * <!-- START SNIPPET: notice -->
 *
 * This component is to be used within a  Select component.
 *
 * <!-- END SNIPPET: notice -->
 *
 * <p/>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 *
 * &lt;s:select label="My Selection"
 *            name="mySelection"
 *            value="%{'POPEYE'}"
 *            list="%{#{'SUPERMAN':'Superman', 'SPIDERMAN':'spiderman'}}"&gt;
 *    &lt;s:optgroup label="Adult"
 *                 list="%{#{'SOUTH_PARK':'South Park'}}" /&gt;
 *    &lt;s:optgroup label="Japanese"
 *                 list="%{#{'POKEMON':'pokemon','DIGIMON':'digimon','SAILORMOON':'Sailormoon'}}" /&gt;
 * &lt;/s:select&gt;
 *
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @s.tag name="optgroup" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.OptGroupTag"
 * description="Renders a Select Tag's OptGroup Tag"
 */
public class OptGroup extends Component {

	public static final String INTERNAL_LIST_UI_BEAN_LIST_PARAMETER_KEY = "optGroupInternalListUiBeanList";

	private static Log _log = LogFactory.getLog(OptGroup.class);

	protected HttpServletRequest req;
	protected HttpServletResponse res;

	protected ListUIBean internalUiBean;

	public OptGroup(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
		super(stack);
		this.req = req;
		this.res = res;
		internalUiBean = new ListUIBean(stack, req, res) {
			protected String getDefaultTemplate() {
				return "empty";
			}
		};
	}

	public boolean end(Writer writer, String body) {
		Select select = (Select) findAncestor(Select.class);
		if (select == null) {
			_log.error("incorrect use of OptGroup component, this component must be used within a Select component",
					new IllegalStateException("incorrect use of OptGroup component, this component must be used within a Select component"));
			return false;
		}
		internalUiBean.start(writer);
		internalUiBean.end(writer, body);

		List listUiBeans = (List) select.getParameters().get(INTERNAL_LIST_UI_BEAN_LIST_PARAMETER_KEY);
		if (listUiBeans == null) {
			listUiBeans = new ArrayList();
		}
		listUiBeans.add(internalUiBean);
		select.addParameter(INTERNAL_LIST_UI_BEAN_LIST_PARAMETER_KEY, listUiBeans);

		return false;
	}

	/**
	 * Set the label attribute.
	 * @s.tagattribute required="false"
	 */
	public void setLabel(String label) {
		internalUiBean.setLabel(label);
	}

	/**
	 * Set the disable attribute.
	 * @s.tagattribute required="false"
	 */
	public void setDisabled(String disabled) {
		internalUiBean.setDisabled(disabled);
	}

	/**
	 * Set the list attribute.
	 * @s.tagattribute required="false"
	 */
	public void setList(String list) {
		internalUiBean.setList(list);
	}

	/**
	 * Set the listKey attribute.
	 * @s.tagattribute required="false"
	 */
	public void setListKey(String listKey) {
		internalUiBean.setListKey(listKey);
	}

	/**
	 * Set the listValue attribute.
	 * @s.tagattribute required="false"
	 */
	public void setListValue(String listValue) {
		internalUiBean.setListValue(listValue);
	}
}
"
core/src/main/java/org/apache/struts2/components/OptionTransferSelect.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.util.LinkedHashMap;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * 
 * Create a option transfer select component which is basically two &lt;select ...&gt;
 * tag with buttons in the middle of them allowing options in each of the 
 * &lt;select ...&gt; to be moved between themselves. Will auto-select all its 
 * elements upon its containing form submision.
 * 
 * <!-- END SNIPPET: javadoc -->
 * 
 * <p/>
 * 
 * 
 * <!-- START SNIPPET: notice -->
 * 
 * NOTE: The id and doubleId need not be supplied as they will generated provided
 * that the optiontransferselect tag is being used in a form tag. The generated id 
 * and doubleId will be &lt;form_id&gt;_&lt;optiontransferselect_doubleName&gt; and 
 * &lt;form_id&gt;_&lt;optiontransferselect_doubleName&gt; respectively.
 * 
 * <!-- END SNIPPET: notice -->
 * 
 * <p/>
 * 
 * <pre>
 * <!-- START SNIPPET: example -->
 * 
 * &lt;-- minimum configuration --&gt;
 * &lt;s:optiontransferselect
 *   	label="Favourite Cartoons Characters"
 *		name="leftSideCartoonCharacters" 
 *		list="{'Popeye', 'He-Man', 'Spiderman'}" 
 *		doubleName="rightSideCartoonCharacters"
 *		doubleList="{'Superman', 'Mickey Mouse', 'Donald Duck'}" 
 *	/&gt;
 *
 *  &lt;-- possible configuration --&gt;
 *  &lt;s:optiontransferselect
 *   	label="Favourite Cartoons Characters"
 *		name="leftSideCartoonCharacters" 
 *		leftTitle="Left Title"
 *		rightTitle="Right Title"
 *		list="{'Popeye', 'He-Man', 'Spiderman'}" 
 *		multiple="true"
 *		headerKey="headerKey"
 *		headerValue="--- Please Select ---"
 *		emptyOption="true"
 *		doubleList="{'Superman', 'Mickey Mouse', 'Donald Duck'}" 
 *		doubleName="rightSideCartoonCharacters"
 *		doubleHeaderKey="doubleHeaderKey"
 *		doubleHeaderValue="--- Please Select ---" 
 *		doubleEmptyOption="true"
 *		doubleMultiple="true"
 *	/&gt;
 * 
 * <!-- END SNIPPET: example -->
 * </pre>
 * 
 * @s.tag name="optiontransferselect" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.OptionTransferSelectTag"
 * description="Renders an input form"
 */
public class OptionTransferSelect extends DoubleListUIBean {
	
	private static final Log _log = LogFactory.getLog(OptionTransferSelect.class);

	private static final String TEMPLATE = "optiontransferselect";
	
	protected String allowAddToLeft;
	protected String allowAddToRight;
	protected String allowAddAllToLeft;
	protected String allowAddAllToRight;
	protected String allowSelectAll;
	protected String allowUpDownOnLeft;
	protected String allowUpDownOnRight;
	
	protected String leftTitle;
	protected String rightTitle;
	
	protected String buttonCssClass;
	protected String buttonCssStyle;

	protected String addToLeftLabel;
	protected String addToRightLabel;
	protected String addAllToLeftLabel;
	protected String addAllToRightLabel;
	protected String selectAllLabel;
	protected String leftUpLabel;
	protected String leftDownlabel;
	protected String rightUpLabel;
	protected String rightDownLabel;
	
	
	public OptionTransferSelect(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
		super(stack, request, response);
	}

	protected String getDefaultTemplate() {
		return TEMPLATE;
	}
	
	
	public void evaluateExtraParams() {
		super.evaluateExtraParams();
		
		Object doubleValue = null;
		
		// override DoubleListUIBean's 
        if (doubleList != null) {
            doubleValue = findValue(doubleList);
            addParameter("doubleList", doubleValue);
        }
        if (size == null || size.trim().length() <= 0) {
        	addParameter("size", "15");
        }
        if (doubleSize == null || doubleSize.trim().length() <= 0) {
        	addParameter("doubleSize", "15");
        }
        if (multiple == null || multiple.trim().length() <= 0) {
        	addParameter("multiple", Boolean.TRUE);
        }
        if (doubleMultiple == null || doubleMultiple.trim().length() <= 0) {
        	addParameter("doubleMultiple", Boolean.TRUE);
        }
        
        
        
        
        
        // buttonCssClass 
        if (buttonCssClass != null && buttonCssClass.trim().length() > 0) {
        	addParameter("buttonCssClass", buttonCssClass);
        }
        
        // buttonCssStyle
        if (buttonCssStyle != null && buttonCssStyle.trim().length() > 0) {
        	addParameter("buttonCssStyle", buttonCssStyle);
        }
        
        

        // allowSelectAll
        addParameter("allowSelectAll", 
        		allowSelectAll != null ? findValue(allowSelectAll, Boolean.class) : Boolean.TRUE);
		
		// allowAddToLeft
		addParameter("allowAddToLeft", 
				allowAddToLeft != null ? findValue(allowAddToLeft, Boolean.class) : Boolean.TRUE);
		
		// allowAddToRight
		addParameter("allowAddToRight",
				allowAddToRight != null ? findValue(allowAddToRight, Boolean.class) : Boolean.TRUE);
		
		// allowAddAllToLeft
		addParameter("allowAddAllToLeft",
				allowAddAllToLeft != null ? findValue(allowAddAllToLeft, Boolean.class) : Boolean.TRUE);
		
		// allowAddAllToRight
		addParameter("allowAddAllToRight", 
				allowAddAllToRight != null ? findValue(allowAddAllToRight, Boolean.class) : Boolean.TRUE);
		
		// allowUpDownOnLeft
		addParameter("allowUpDownOnLeft", 
				allowUpDownOnLeft != null ? findValue(allowUpDownOnLeft, Boolean.class) : Boolean.TRUE);
		
		// allowUpDownOnRight
		addParameter("allowUpDownOnRight", 
				allowUpDownOnRight != null ? findValue(allowUpDownOnRight, Boolean.class) : Boolean.TRUE);
		
		
		// leftTitle
		if (leftTitle != null) {
			addParameter("leftTitle", findValue(leftTitle, String.class));
		}
		
		// rightTitle
		if (rightTitle != null) {
			addParameter("rightTitle", findValue(rightTitle, String.class));
		}
		
		
		// addToLeftLabel
		addParameter("addToLeftLabel", 
				addToLeftLabel != null ? findValue(addToLeftLabel, String.class) : "<-" );
		
		// addToRightLabel
		addParameter("addToRightLabel", 
				addToRightLabel != null ? findValue(addToRightLabel, String.class) : "->");
		
		// addAllToLeftLabel
		addParameter("addAllToLeftLabel", 
				addAllToLeftLabel != null ? findValue(addAllToLeftLabel, String.class) : "<<--");
		
		// addAllToRightLabel
		addParameter("addAllToRightLabel", 
				addAllToRightLabel != null ? findValue(addAllToRightLabel, String.class) : "-->>");
		
		// selectAllLabel
		addParameter("selectAllLabel",
				selectAllLabel != null ? findValue(selectAllLabel, String.class) : "<*>");
		
		// leftUpLabel
		addParameter("leftUpLabel", 
				leftUpLabel != null ? findValue(leftUpLabel, String.class) : "^");
		
		
		// leftDownLabel
		addParameter("leftDownLabel", 
				leftDownlabel != null ? findValue(leftDownlabel, String.class) : "v");
		
		
		// rightUpLabel
		addParameter("rightUpLabel", 
				rightUpLabel != null ? findValue(rightUpLabel, String.class) : "^");
		
		
		// rightDownlabel
		addParameter("rightDownLabel", 
				rightDownLabel != null ? findValue(rightDownLabel, String.class) : "v");
		
		
		
		// inform the form component our select tag infos, so they know how to select 
		// its elements upon onsubmit
		Form formAncestor = (Form) findAncestor(Form.class);
		if (formAncestor != null) {
			
			// inform ancestor form that we are having a customOnsubmit (see form-close.ftl [simple theme])
			enableAncestorFormCustomOnsubmit();
			
			
			// key -> select tag id, value -> headerKey (if exists)
			Map formOptiontransferselectIds = (Map) formAncestor.getParameters().get("optiontransferselectIds");
			Map formOptiontransferselectDoubleIds = (Map) formAncestor.getParameters().get("optiontransferselectDoubleIds");

			// init lists
			if (formOptiontransferselectIds == null) {
				formOptiontransferselectIds = new LinkedHashMap();
			}
			if (formOptiontransferselectDoubleIds == null) {
				formOptiontransferselectDoubleIds = new LinkedHashMap();
			}
			
			
			// id
			String tmpId = (String) getParameters().get("id");
			String tmpHeaderKey = (String) getParameters().get("headerKey");
			if (tmpId != null && (! formOptiontransferselectIds.containsKey(tmpId))) {
				formOptiontransferselectIds.put(tmpId, tmpHeaderKey);
			}
			
			// doubleId
			String tmpDoubleId = (String) getParameters().get("doubleId");
			String tmpDoubleHeaderKey = (String) getParameters().get("doubleHeaderKey");
			if (tmpDoubleId != null && (! formOptiontransferselectDoubleIds.containsKey(tmpDoubleId))) {
				formOptiontransferselectDoubleIds.put(tmpDoubleId, tmpDoubleHeaderKey);
			}
			
			formAncestor.getParameters().put("optiontransferselectIds", formOptiontransferselectIds);
			formAncestor.getParameters().put("optiontransferselectDoubleIds", formOptiontransferselectDoubleIds);
			
		}
		else {
			_log.warn("form enclosing optiontransferselect "+this+" not found, auto select upon form submit of optiontransferselect will not work");
		}
	}
	
	
	
	public String getAddAllToLeftLabel() {
		return addAllToLeftLabel;
	}

	/**
     * set Add To Left button label
	 * @s.tagattribute required="false"
	 */
	public void setAddAllToLeftLabel(String addAllToLeftLabel) {
		this.addAllToLeftLabel = addAllToLeftLabel;
	}

	public String getAddAllToRightLabel() {
		return addAllToRightLabel;
	}

	/**
     * set Add All To Right button label
	 * @s.tagattribute required="false"
	 */
	public void setAddAllToRightLabel(String addAllToRightLabel) {
		this.addAllToRightLabel = addAllToRightLabel;
	}

	public String getAddToLeftLabel() {
		return addToLeftLabel;
	}

	/**
     * set Add To Left button label
	 * @s.tagattribute required="false"
	 */
	public void setAddToLeftLabel(String addToLeftLabel) {
		this.addToLeftLabel = addToLeftLabel;
	}

	public String getAddToRightLabel() {
		return addToRightLabel;
	}

	/**
     * set Add To Right button label
	 * @s.tagattribute required="false"
	 */
	public void setAddToRightLabel(String addToRightLabel) {
		this.addToRightLabel = addToRightLabel;
	}

	public String getAllowAddAllToLeft() {
		return allowAddAllToLeft;
	}

	/**
     * enable Add All To Left button
	 * @s.tagattribute required="false"
	 */
	public void setAllowAddAllToLeft(String allowAddAllToLeft) {
		this.allowAddAllToLeft = allowAddAllToLeft;
	}

	public String getAllowAddAllToRight() {
		return allowAddAllToRight;
	}

	/**
     * enable Add All To Right button
	 * @s.tagattribute required="false"
	 */
	public void setAllowAddAllToRight(String allowAddAllToRight) {
		this.allowAddAllToRight = allowAddAllToRight;
	}

	public String getAllowAddToLeft() {
		return allowAddToLeft;
	}

	/**
     * enable Add To Left button
	 * @s.tagattribute required="false"
	 */
	public void setAllowAddToLeft(String allowAddToLeft) {
		this.allowAddToLeft = allowAddToLeft;
	}

	public String getAllowAddToRight() {
		return allowAddToRight;
	}

	/**
     * enable Add To Right button
	 * @s.tagattribute required="false"
	 */
	public void setAllowAddToRight(String allowAddToRight) {
		this.allowAddToRight = allowAddToRight;
	}

	public String getLeftTitle() {
		return leftTitle;
	}
	
	
	/**
	 * enable up / down on the left side
	 * @a2 tagattribute required="false" 
	 */
	public void setAllowUpDownOnLeft(String allowUpDownOnLeft) {
		this.allowUpDownOnLeft = allowUpDownOnLeft;
	}
	
	public String getAllowUpDownOnLeft() {
		return this.allowUpDownOnLeft;
	}
	
	
	/**
	 * enable up / down on the right side
	 * @a2 tagattribute required="false"
	 */
	public void setAllowUpDownOnRight(String allowUpDownOnRight) {
		this.allowUpDownOnRight = allowUpDownOnRight;
	}
	
	public String getAllowUpDownOnRight() {
		return this.allowUpDownOnRight;
	}
	

	/**
     * set Left title
	 * @s.tagattribute required="false"
	 */
	public void setLeftTitle(String leftTitle) {
		this.leftTitle = leftTitle;
	}

	public String getRightTitle() {
		return rightTitle;
	}

	/**
     * set Right title
	 * @s.tagattribute required="false"
	 */
	public void setRightTitle(String rightTitle) {
		this.rightTitle = rightTitle;
	}
	
	
	/**
     * enable Select All button
	 * @s.tagattribute required="false"
	 */
	public void setAllowSelectAll(String allowSelectAll) {
		this.allowSelectAll = allowSelectAll;
	}

    public String getAllowSelectAll() {
		return this.allowSelectAll;
	}
	
	
	/**
     * set Select All button label
	 * @s.tagattribute required="false"
	 */
	public void setSelectAllLabel(String selectAllLabel) {
		this.selectAllLabel = selectAllLabel;
	}

    public String getSelectAllLabel() {
		return this.selectAllLabel;
	}


    /**
     * set buttons css class
	 * @s.tagattribute required="false"
	 */
	public void setButtonCssClass(String buttonCssClass) {
		this.buttonCssClass = buttonCssClass;
	}

    public String getButtonCssClass() {
		return buttonCssClass;
	}
	
	
	/**
     * set button css style
	 * @s.tagattribute required="false"
	 */
	public void setButtonCssStyle(String buttonCssStyle) {
		this.buttonCssStyle = buttonCssStyle;
	}

    public String getButtonCssStyle() {
		return this.buttonCssStyle;
	}
    
    
    /**
     * Up label for the left side
     * @a2 tagattribute required="false"
     */
    public void setLeftUpLabel(String leftUpLabel) {
    	this.leftUpLabel = leftUpLabel;
    }
    public String getLeftUpLabel() {
    	return this.leftUpLabel;
    }
    
    /**
     * Down label for the left side.
     * @a2 tagattribute required="false"
     */
    public void setLeftDownLabel(String leftDownLabel) {
    	this.leftDownlabel = leftDownLabel;
    }
    public String getLeftDownLabel() {
    	return this.leftDownlabel;
    }
    
    /**
     * Up label for the right side.
     * @a2 tagattribute required="false"
     */
    public void setRightUpLabel(String rightUpLabel) {
    	this.rightUpLabel = rightUpLabel;
    }
    public String getRightUpLabel() {
    	return this.rightUpLabel;
    }
    
    
    /**
     * Down label for the left side.
     * @a2 tagattribute required="false"
     */
    public void setRightDownLabel(String rightDownlabel) {
    	this.rightDownLabel = rightDownlabel;
    }
    public String getRightDownLabel() {
    	return rightDownLabel;
    }
    
    
}
"
core/src/main/java/org/apache/struts2/components/Panel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.io.Writer;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * Render a panel for tabbedPanel.</p>
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 * See the example in {@link TabbedPanel}.
 * <p/>
 *
 * @see TabbedPanel
 *
 * @s.tag name="panel" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.PanelTag"
 * description="Render a panel for tabbedPanel"
 */
public class Panel extends Div {

    public static final String TEMPLATE = "tab";
    public static final String TEMPLATE_CLOSE = "tab-close";
    public static final String COMPONENT_NAME = Panel.class.getName();

    protected String tabName;
    protected String subscribeTopicName;
    protected String remote;

    public Panel(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    public String getDefaultOpenTemplate() {
        return TEMPLATE;
    }

    protected String getDefaultTemplate() {
        return TEMPLATE_CLOSE;
    }

    public boolean end(Writer writer, String body) {
        TabbedPanel tabbedPanel = ((TabbedPanel) findAncestor(TabbedPanel.class));
        subscribeTopicName = tabbedPanel.getTopicName();
        tabbedPanel.addTab(this);

        return super.end(writer, body);
    }

    public void evaluateExtraParams() {
        super.evaluateExtraParams();

        if (tabName != null) {
            addParameter("tabName", findString(tabName));
        }

        if (subscribeTopicName != null) {
            addParameter("subscribeTopicName", subscribeTopicName);
        }

        if (remote != null && "true".equalsIgnoreCase(remote)) {
            addParameter("remote", "true");
        } else {
            addParameter("remote", "false");
        }
    }

    public String getTabName() {
        return findString(tabName);
    }

    public String getComponentName() {
        return COMPONENT_NAME;
    }

    /**
     * The text of the tab to display in the header tab list
     * @s.tagattribute required="true"
     */
    public void setTabName(String tabName) {
        this.tabName = tabName;
    }

    /**
     * Set subscribeTopicName attribute
     * @s.tagattribute required="false"
     */
    public void setSubscribeTopicName(String subscribeTopicName) {
        this.subscribeTopicName = subscribeTopicName;
    }

    /**
     * determines whether this is a remote panel (ajax) or a local panel (content loaded into visible/hidden containers)
     * @s.tagattribute required="false" type="Boolean" default="false"
     */
    public void setRemote(String remote) {
        this.remote = remote;
    }
}
"
core/src/main/java/org/apache/struts2/components/Param.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.io.Writer;

import org.apache.struts2.StrutsException;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * <p>This tag can be used to parameterize other tags.</p>
 * The include tag and bean tag are examples of such tags.
 * <p/>
 * The parameters can be added with or without a name as key.
 * If the tag provides a name attribute the parameters are added using the
 * {@link Component#addParameter(String, Object) addParamter} method.
 * For unnamed parameters the Tag must implement the {@link UnnamedParametric} interface defined in
 * this class (e.g. The TextTag does this).
 * <p/>
 * This tag has the following two paramters.
 * <!-- START SNIPPET: params -->
 * <ul>
 * 		<li>name (String) - the name of the parameter</li>
 *      <li>value (Object) - the value of the parameter</li>
 * </ul>
 * <!-- END SNIPPET: params -->
 * <p/>
 * <b>Note:</b>
 * When you declare the param tag, the value can be defined in either a <tt>value</tt> attribute or
 * as text between the start and end tag. Struts behaves a bit different according to these two situations.
 * This is best illustrated using an example:
 * <br/>&lt;param name="color"&gt;blue&lt;/param&gt; &lt;-- (A) --&gt;
 * <br/>&lt;param name="color" value="blue"/&gt; &lt;-- (B) --&gt;
 * <br/>In the first situation (A) the value would be evaluated to the stack as a <tt>java.lang.String</tt> object.
 * And in situation (B) the value would be evaluated to the stack as a <tt>java.lang.Object</tt> object.
 * <br/>For more information see <a href="http://jira.opensymphony.com/browse/WW-808">WW-808</a>.
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 * <!-- START SNIPPET: example -->
 * <pre>
 * &lt;ui:component&gt;
 *  &lt;ui:param name="key"     value="[0]"/&gt;
 *  &lt;ui:param name="value"   value="[1]"/&gt;
 *  &lt;ui:param name="context" value="[2]"/&gt;
 * &lt;/ui:component&gt;
 * </pre>
 * <!-- END SNIPPET: example -->
 * <p/>
 * <!-- START SNIPPET: exampledescription -->
 * where the key will be the identifier and the value the result of an OGNL expression run against the current
 * OgnlValueStack.
 * <!-- END SNIPPET: exampledescription -->
 * <p/>
 * This second example demonstrates how the text tag can use parameters from this param tag.
 * <!-- START SNIPPET: example2 -->
 * <pre>
 * &lt;s:text name="cart.total.cost"&gt;
 *     &lt;s:param value="#session.cartTotal"/&gt;
 * &lt;/s:text&gt;
 * </pre>
 * <!-- END SNIPPET: example2 -->
 * <p/>
 *
 * @see Include
 * @see Bean
 * @see Text
 *
 * @s.tag name="param" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ParamTag"
 * description="Parametrize other tags"
 */
public class Param extends Component {
    protected String name;
    protected String value;

    public Param(OgnlValueStack stack) {
        super(stack);
    }

    public boolean end(Writer writer, String body) {
        Component component = findAncestor(Component.class);
        if (value != null) {
            if (component instanceof UnnamedParametric) {
                ((UnnamedParametric) component).addParameter(findValue(value));
            } else {
                String name = findString(this.name);

                if (name == null) {
                    throw new StrutsException("No name found for following expression: " + name);
                }

                Object value = findValue(this.value);
                component.addParameter(name, value);
            }
        } else {
            if (component instanceof UnnamedParametric) {
                ((UnnamedParametric) component).addParameter(body);
            } else {
                component.addParameter(findString(name), body);
            }
        }

        return super.end(writer, "");
    }

    public boolean usesBody() {
        return true;
    }

    /**
     * Name of Parameter to set
     * @s.tagattribute required="false" type="String"
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * Value expression for Parameter to set
     * @s.tagattribute required="false" default="The value of evaluating provided name against stack"
     */
    public void setValue(String value) {
        this.value = value;
    }


    /**
     * Tags can implement this to support nested param tags without the <tt>name</tt> attribute.
     * <p/>
     * The {@link Text TextTag} uses this approach. For unnamed parameters an example is given in the class
     * javadoc for {@link Param ParamTag}.
     */
    public interface UnnamedParametric {

        /**
         * Adds the given value as a parameter to the outer tag.
         * @param value  the value
         */
        public void addParameter(Object value);
    }

}
"
core/src/main/java/org/apache/struts2/components/Password.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * Render an HTML input tag of type password.</p>
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 * <p/>
 * <!-- START SNIPPET: exdescription -->
 * In this example, a password control is displayed. For the label, we are calling ActionSupport's getText() to
 * retrieve password label from a resource bundle.<p/>
 * <!-- END SNIPPET: exdescription -->
 * <pre>
 * <!-- START SNIPPET: example -->
 * &lt;s:password label="%{text('password')}" name="password" size="10" maxlength="15" /&gt;
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @s.tag name="password" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.PasswordTag"
 * description="Render an HTML input tag of type password"
 */
public class Password extends TextField {
    final public static String TEMPLATE = "password";

    protected String showPassword;

    public Password(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }

    public void evaluateExtraParams() {
        super.evaluateExtraParams();

        if (showPassword != null) {
            addParameter("showPassword", findValue(showPassword, Boolean.class));
        }
    }

    /**
     * Whether to show input
     * @s.tagattribute required="false" type="Boolean" default="false"
     */
    public void setShowPassword(String showPassword) {
        this.showPassword = showPassword;
    }

}
"
core/src/main/java/org/apache/struts2/components/Property.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.io.IOException;
import java.io.Writer;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.opensymphony.xwork2.util.OgnlValueStack;
import com.opensymphony.xwork2.util.TextUtils;

/**
 * <!-- START SNIPPET: javadoc -->
 * 
 * Used to get the property of a <i>value</i>, which will default to the top of
 * the stack if none is specified.
 * 
 * <!-- END SNIPPET: javadoc -->
 * 
 * <p/>
 * 
 *
 * <!-- START SNIPPET: params -->
 * 
 * <ul>
 *      <li>default (String) - The default value to be used if <u>value</u> attribute is null</li>
 *      <li>escape (Boolean) - Escape HTML. Default to true</li>
 *      <li>value (Object) - value to be displayed</li>
 * </ul>
 * 
 * <!-- END SNIPPET: params -->
 *
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * 
 * <s:push value="myBean">
 *     <!-- Example 1: -->
 *     <s:property value="myBeanProperty" />
 *
 *     <!-- Example 2: -->TextUtils
 *     <s:property value="myBeanProperty" default="a default value" />
 * </s:push>
 * 
 * <!-- END SNIPPET: example -->
 * </pre>
 * 
 * <pre>
 * <!-- START SNIPPET: exampledescription -->
 * 
 * Example 1 prints the result of myBean's getMyBeanProperty() method.
 * Example 2 prints the result of myBean's getMyBeanProperty() method and if it is null, print 'a default value' instead.
 * 
 * <!-- END SNIPPET: exampledescription -->
 * </pre>
 * 
 * 
 * <pre>
 * <!-- START SNIPPET: i18nExample -->
 * 
 * &lt;s:property value="getText('some.key')" /&gt;
 * 
 * <!-- END SNIPPET: i18nExample -->
 * </pre>
 *
 * @s.tag name="property" tld-body-content="empty" tld-tag-class="org.apache.struts2.views.jsp.PropertyTag"
 * description="Print out expression which evaluates against the stack"
 */
public class Property extends Component {
    private static final Log LOG = LogFactory.getLog(Property.class);

    public Property(OgnlValueStack stack) {
        super(stack);
    }

    private String defaultValue;
    private String value;
    private boolean escape = true;

    /**
     * The default value to be used if <u>value</u> attribute is null
     * @s.tagattribute required="false" type="String"
     */
    public void setDefault(String defaultValue) {
        this.defaultValue = defaultValue;
    }

    /**
     * Whether to escape HTML
     * @s.tagattribute required="false" type="Boolean" default="true"
     */
    public void setEscape(boolean escape) {
        this.escape = escape;
    }

    /**
     * value to be displayed
     * @s.tagattribute required="false" type="Object" default="&lt;top of stack&gt;"
     */
    public void setValue(String value) {
        this.value = value;
    }

    public boolean start(Writer writer) {
        boolean result = super.start(writer);

        String actualValue = null;

        if (value == null) {
            value = "top";
        }
        else if (altSyntax()) {
            // the same logic as with findValue(String)
            // if value start with %{ and end with }, just cut it off!
            if (value.startsWith("%{") && value.endsWith("}")) {
                value = value.substring(2, value.length() - 1);
            }
        }

        // exception: don't call findString(), since we don't want the
        //            expression parsed in this one case. it really
        //            doesn't make sense, in fact.
        actualValue = (String) getStack().findValue(value, String.class);

        try {
            if (actualValue != null) {
                writer.write(prepare(actualValue));
            } else if (defaultValue != null) {
                writer.write(prepare(defaultValue));
            }
        } catch (IOException e) {
            LOG.info("Could not print out value '" + value + "'", e);
        }

        return result;
    }

    private String prepare(String value) {
        if (escape) {
            return TextUtils.htmlEncode(value);
        } else {
            return value;
        }
    }
}
"
core/src/main/java/org/apache/struts2/components/Push.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.io.Writer;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * <p>Push value on stack for simplified usage.</p>
 * <!-- END SNIPPET: javadoc -->
 *
 * <!-- START SNIPPET: params -->
 * <ul>
 * 		<li>value* (Object) - value to be pushed into the top of the stack</li>
 * </ul>
 * <!-- END SNIPPET: params -->
 *
 *
 * <p/> <b>Examples</b>
 * <pre>
 * <!-- START SNIPPET: example1 -->
 * &lt;s:push value="user"&gt;
 *     &lt;s:propery value="firstName" /&gt;
 *     &lt;s:propery value="lastName" /&gt;
 * &lt;/s:push&gt;
 * <!-- END SNIPPET: example1 -->
 * </pre>
 * 
 * <!-- START SNIPPET: example1description -->
 * Pushed user into the stack, and hence property tag could access user's properties 
 * (firstName, lastName etc) since user is not at the top of the stack
 * <!-- END SNIPPET: example1description -->
 * 
 * <pre>
 * <!-- START SNIPPET: example2 -->
 *  &lt;s:push value="myObject"&gt;                              ----- (1)
 *       &lt;s:bean name="jp.SomeBean" id="myBean"/&gt;        ----- (2)
 * 		    &lt;s:param name="myParam" value="top"/&gt;        ----- (3)
 *       &lt;/s:bean&gt;
 *   &lt;/s:push&gt;
 * <!-- END SNIPPET: example2 -->
 * </pre>
 * 
 * <pre>
 * <!-- START SNIPPET: example2description -->
 * when in (1), myObject is at the top of the stack
 * when in (2), jp.SomeBean is in the top of stack, also in stack's context with key myBean
 * when in (3), top will get the jp.SomeBean instance
 * <!-- END SNIPPET: example2description -->
 * </pre>
 * 
 * <pre>
 * <!-- START SNIPPET: example3 -->
 * &lt;s:push value="myObject"&gt;                                       ---(A)
 *    &lt;s:bean name="jp.SomeBean" id="myBean"/&gt;                   ---(B)
 *       &lt;s:param name="myParam" value="top.mySomeOtherValue"/&gt;  ---(C)
 *    &lt;/s:bean&gt;
 * &lt;/s:push&gt;
 * <!-- END SNIPPET: example3 -->
 * </pre>
 * 
 * <pre>
 * <!-- START SNIPPET: example3description -->
 * when in (A), myObject is at the top of the stack
 * when in (B), jp.SomeBean is at the top of the stack, also in context with key myBean
 * when in (C), top refers to jp.SomeBean instance. so top.mySomeOtherValue would invoke SomeBean's mySomeOtherValue() method
 * <!-- END SNIPPET: example3description -->
 * </pre>
 * 
 * <pre>
 * <!-- START SNIPPET: example4 -->       
 * &lt;s:push value="myObject"&gt;                                 ---- (i)
 *    &lt;s:bean name="jp.SomeBean" id="myBean"/&gt;             ---- (ii)
 *       &lt;s:param name="myParam" value="[1].top"/&gt;         -----(iii)
 *    &lt;/s:bean&gt;
 * &lt;/s:push&gt;
 * <!-- END SNIPPET: example4 -->
 * </pre>
 * 
 * <pre>
 * <!-- START SNIPPET: example4description -->
 * when in (i), myObject is at the top of the stack
 * when in (ii), jp.SomeBean is at the top of the stack, followed by myObject
 * when in (iii), [1].top will returned top of the cut of stack starting from myObject, namely myObject itself 
 * <!-- END SNIPPET: example4description -->
 * </pre>
 * 
 * @s.tag name="push" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.PushTag"
 * description="Push value on stack for simplified usage."
 */
public class Push extends Component {
    protected String value;
    protected boolean pushed;

    public Push(OgnlValueStack stack) {
        super(stack);
    }

    public boolean start(Writer writer) {
        boolean result = super.start(writer);

        OgnlValueStack stack = getStack();

        if (stack != null) {
            stack.push(findValue(value, "value", "You must specify a value to push on the stack. Example: person"));
            pushed = true;
        } else {
            pushed = false; // need to ensure push is assigned, otherwise we may have a leftover value
        }

        return result;
    }

    public boolean end(Writer writer, String body) {
        OgnlValueStack stack = getStack();

        if (pushed && (stack != null)) {
            stack.pop();
        }

        return super.end(writer, body);
    }

    /**
     * Value to push on stack
     * @s.tagattribute required="true"
     */
    public void setValue(String value) {
        this.value = value;
    }
}
"
core/src/main/java/org/apache/struts2/components/Radio.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * Render a radio button input field.</p>
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 * <p/>
 * <!-- START SNIPPET: exdescription -->
 * In this example, a radio control is displayed with a list of genders. The gender list is built from attribute
 * id=genders. The framework calls getGenders() which will return a Map. For examples using listKey and listValue attributes,
 * see the section select tag. The default selected one will be determined (in this case) by the getMale() method 
 * in the action class which should retun a value similar to the key of the getGenters() map if that particular 
 * gender is to be selected.<p/>
 * <!-- END SNIPPET: exdescription -->
 * <pre>
 * <!-- START SNIPPET: example -->
 * &lt;s:action name="GenderMap" id="genders"/&gt;
 * &lt;s:radio label="Gender" name="male" list="#genders.genders"/&gt;
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @s.tag name="radio" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.RadioTag"
 * description="Renders a radio button input field"
 */
public class Radio extends ListUIBean {
    final public static String TEMPLATE = "radiomap";

    public Radio(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }
}
"
core/src/main/java/org/apache/struts2/components/RemoteCallUIBean.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * RemoteCallUIBean is superclass for all components dealing with remote calls.
 *
 */
public abstract class RemoteCallUIBean extends ClosingUIBean {

    protected String href;
    protected String errorText;
    protected String showErrorTransportText;
    protected String afterLoading;

    public RemoteCallUIBean(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    public void evaluateExtraParams() {
        super.evaluateExtraParams();

        if (href != null) {
            addParameter("href", findString(href));
        }

        if (showErrorTransportText != null) {
            addParameter("showErrorTransportText", findValue(showErrorTransportText, Boolean.class));
        }

        if (errorText != null) {
            addParameter("errorText", findString(errorText));
        }

        if (afterLoading != null) {
            addParameter("afterLoading", findString(afterLoading));
        }
    }

    /**
     * The theme to use for the element. <b>This tag will usually use the ajax theme.</b>
     * @s.tagattribute required="false" type="String"
     */
    public void setTheme(String theme) {
        super.setTheme(theme);
    }

    /**
     * The URL to call to obtain the content
     * @s.tagattribute required="false" type="String"
     */
    public void setHref(String href) {
        this.href = href;
    }

    /**
     * The text to display to the user if the is an error fetching the content
     * @s.tagattribute required="false" type="String"
     */
    public void setErrorText(String errorText) {
        this.errorText = errorText;
    }

    /**
     * when to show the error message as content when the URL had problems
     * @s.tagattribute required="false" type="Boolean" default="false"
     */
    public void setShowErrorTransportText(String showErrorTransportText) {
        this.showErrorTransportText = showErrorTransportText;
    }

    /**
     * Javascript code that will be executed after the content has been fetched
     * @s.tagattribute required="false" type="String"
     */
    public void setAfterLoading(String afterLoading) {
        this.afterLoading = afterLoading;
    }
}
"
core/src/main/java/org/apache/struts2/components/Reset.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * Render a reset button. The reset tag is used together with the form tag to provide form resetting.
 * The reset can have two different types of rendering:
 * <ul>
 * <li>input: renders as html &lt;input type="reset"...&gt;</li>
 * <li>button: renders as html &lt;button type="reset"...&gt;</li>
 * </ul>
 * Please note that the button type has advantages by adding the possibility to seperate the submitted value from the
 * text shown on the button face, but has issues with Microsoft Internet Explorer at least up to 6.0
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * &lt;s:reset value="%{'Reset'}" /&gt;
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * <pre>
 * <!-- START SNIPPET: example2 -->
 * Render an button reset:
 * &lt;s:reset type="button" value="%{'Reset'}" label="Reset the form"/&gt;
 * <!-- END SNIPPET: example2 -->
 * </pre>
 *
 * @s.tag name="reset" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.ResetTag"
 * description="Render a reset button"
 */
public class Reset extends FormButton {
    final public static String TEMPLATE = "reset";

    protected String action;
    protected String method;
    protected String align;
    protected String type;

    public Reset(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    protected String getDefaultTemplate() {
        return Reset.TEMPLATE;
    }

    public void evaluateParams() {

        if (value == null) {
            value = "Reset";
        }

        super.evaluateParams();
    }

    /**
     * Indicate whether the concrete button supports the type "image".
     *
     * @return <tt>false</tt> to indicate type image is supported.
     */
    protected boolean supportsImageType() {
        return false;
    }

    /**
     * Supply a reset button text apart from reset value. Will have no effect for <i>input</i> type reset, since button
     * text will always be the value parameter.
     *
     * @s.tagattribute required="false"
     */
    public void setLabel(String label) {
        super.setLabel(label);
    }

}
"
core/src/main/java/org/apache/struts2/components/Select.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * 
 * Render an HTML input tag of type select. 
 * 
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 * <pre>
 * <!-- START SNIPPET: example -->
 * 
 * &lt;s:select label="Pets"
 *        name="petIds"
 *        list="petDao.pets"
 *        listKey="id"
 *        listValue="name"
 *        multiple="true"
 *        size="3"
 *        required="true"
 * /&gt;
 *
 * &lt;s:select label="Months"
 *        name="months"
 *        headerKey="-1" headerValue="Select Month"
 *        list="#{'01':'Jan', '02':'Feb', [...]}"
 *        value="selectedMonth"
 *        required="true"
 * /&gt;
 *
 * // The month id (01, 02, ...) returned by the getSelectedMonth() call
 * // against the stack will be auto-selected
 * 
 * <!-- END SNIPPET: example -->
 * </pre>
 * 
 * <p/>
 * 
 * <!-- START SNIPPET: exnote -->
 * 
 * Note: For any of the tags that use lists (select probably being the most ubiquitous), which uses the OGNL list
 * notation (see the "months" example above), it should be noted that the map key created (in the months example,
 * the '01', '02', etc.) is typed. '1' is a char, '01' is a String, "1" is a String. This is important since if
 * the value returned by your "value" attribute is NOT the same type as the key in the "list" attribute, they
 * WILL NOT MATCH, even though their String values may be equivalent. If they don't match, nothing in your list
 * will be auto-selected.<p/>
 * 
 * <!-- END SNIPPET: exnote -->
 *
 * @s.tag name="select" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.SelectTag"
 * description="Render a select element"
 */
public class Select extends ListUIBean {
    final public static String TEMPLATE = "select";

    protected String emptyOption;
    protected String headerKey;
    protected String headerValue;
    protected String multiple;
    protected String size;

    public Select(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }

    public void evaluateExtraParams() {
        super.evaluateExtraParams();

        if (emptyOption != null) {
            addParameter("emptyOption", findValue(emptyOption, Boolean.class));
        }

        if (multiple != null) {
            addParameter("multiple", findValue(multiple, Boolean.class));
        }

        if (size != null) {
            addParameter("size", findString(size));
        }

        if ((headerKey != null) && (headerValue != null)) {
            addParameter("headerKey", findString(headerKey));
            addParameter("headerValue", findString(headerValue));
        }
    }

    /**
     * Whether or not to add an empty (--) option after the header option
     * @s.tagattribute required="false" type="Boolean" default="false"
     */
    public void setEmptyOption(String emptyOption) {
        this.emptyOption = emptyOption;
    }

    /**
     * Key for first item in list. Must not be empty! "'-1'" and "''" is correct, "" is bad.
     * @s.tagattribute required="false"
     */
    public void setHeaderKey(String headerKey) {
        this.headerKey = headerKey;
    }

    /**
     * Value expression for first item in list
     * @s.tagattribute required="false"
     */
    public void setHeaderValue(String headerValue) {
        this.headerValue = headerValue;
    }

    /**
     * Creates a multiple select. The tag will pre-select multiple values if the values are passed as an Array (of appropriate types) via the value attribute. Passing a Collection may work too? Haven't tested this.
     * @s.tagattribute required="false"  type="Boolean" default="false"
     */
    public void setMultiple(String multiple) {
        this.multiple = multiple;
    }

    /**
     * Size of the element box (# of elements to show)
     * @s.tagattribute required="false" type="Integer"
     */
    public void setSize(String size) {
        this.size = size;
    }
}
"
core/src/main/java/org/apache/struts2/components/Set.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.io.Writer;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * <p>The set tag assigns a value to a variable in a specified scope. It is useful when you wish to assign a variable to a
 * complex expression and then simply reference that variable each time rather than the complex expression. This is
 * useful in both cases: when the complex expression takes time (performance improvement) or is hard to read (code
 * readability improvement).</P>
 * 
 * The scopes available are as follows :-
 * <ul>
 *   <li>application - the value will be set in application scope according to servlet spec. using the name as its key</li>
 *   <li>session - the value will be set in session scope according to servlet spec. using the name as key </li>
 *   <li>request - the value will be set in request scope according to servlet spec. using the name as key </li>
 *   <li>page - the value will be set in request scope according to servlet sepc. using the name as key</li>
 *   <li>action - the value will be set in the request scope and Struts' action context using the name as key</li>
 * </ul>
 * 
 * NOTE:<p/>
 * If no scope is specified, it will default to action scope.
 *
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Parameters</b>
 *
 * <!-- START SNIPPET: params -->
 *
 * <ul>
 *
 * <li>name* (String): The name of the new variable that is assigned the value of <i>value</i></li>
 *
 * <li>value (Object): The value that is assigned to the variable named <i>name</i></li>
 *
 * <li>scope (String): The scope in which to assign the variable. Can be <b>application</b>, <b>session</b>,
 * <b>request</b>, <b>page</b>, or <b>action</b>. By default it is <b>action</b>.</li>
 *
 * </ul>
 *
 * <!-- END SNIPPET: params -->
 *
 * <p/> <b>Examples</b>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * &lt;s:set name="personName" value="person.name"/&gt;
 * Hello, &lt;s:property value="#personName"/&gt;. How are you?
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @s.tag name="set" tld-body-content="empty" tld-tag-class="org.apache.struts2.views.jsp.SetTag"
 * description="Assigns a value to a variable in a specified scope"
 */
public class Set extends Component {
    protected String name;
    protected String scope;
    protected String value;

    public Set(OgnlValueStack stack) {
        super(stack);
    }

    public boolean end(Writer writer, String body) {
        OgnlValueStack stack = getStack();

        if (value == null) {
            value = "top";
        }

        Object o = findValue(value);

        String name;
        if (altSyntax()) {
            name = findString(this.name, "name", "Name is required");
        } else {
            name = this.name;

            if (this.name == null) {
                throw fieldError("name", "Name is required", null);
            }
        }

        if ("application".equalsIgnoreCase(scope)) {
            stack.setValue("#application['" + name + "']", o);
        } else if ("session".equalsIgnoreCase(scope)) {
            stack.setValue("#session['" + name + "']", o);
        } else if ("request".equalsIgnoreCase(scope)) {
            stack.setValue("#request['" + name + "']", o);
        } else if ("page".equalsIgnoreCase(scope)) {
            stack.setValue("#attr['" + name + "']", o, false);
        } else {
            stack.getContext().put(name, o);
            stack.setValue("#attr['" + name + "']", o, false);
        }

        return super.end(writer, body);
    }

    /**
     * The name of the new variable that is assigned the value of <i>value</i>
     * @s.tagattribute required="true" type="String"
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * The scope in which to assign the variable. Can be <b>application</b>, <b>session</b>, <b>request</b>, <b>page</b>, or <b>action</b>.
     * @s.tagattribute required="false" type="String" default="action"
     */
    public void setScope(String scope) {
        this.scope = scope;
    }

    /**
     * The value that is assigned to the variable named <i>name</i>
     * @s.tagattribute required="false"
     */
    public void setValue(String value) {
        this.value = value;
    }
}
"
core/src/main/java/org/apache/struts2/components/Submit.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * Render a submit button. The submit tag is used together with the form tag to provide asynchronous form submissions.
 * The submit can have three different types of rendering:
 * <ul>
 * <li>input: renders as html &lt;input type="submit"...&gt;</li>
 * <li>image: renders as html &lt;input type="image"...&gt;</li>
 * <li>button: renders as html &lt;button type="submit"...&gt;</li>
 * </ul>
 * Please note that the button type has advantages by adding the possibility to seperate the submitted value from the
 * text shown on the button face, but has issues with Microsoft Internet Explorer at least up to 6.0
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * &lt;s:submit value="%{'Submit'}" /&gt;
 * <!-- END SNIPPET: example -->
 * </pre>
 * 
 * <pre>
 * <!-- START SNIPPET: example2 -->
 * Render an image submit:
 * &lt;s:submit type="image" value="%{'Submit'}" label="Submit the form" src="submit.gif"/&gt;
 * <!-- END SNIPPET: example2 -->
 * </pre>
 *
 * <pre>
 * <!-- START SNIPPET: example3 -->
 * Render an button submit:
 * &lt;s:submit type="button" value="%{'Submit'}" label="Submit the form"/&gt;
 * <!-- END SNIPPET: example3 -->
 * </pre>
 *
 * <!-- START SNIPPET: ajaxJavadoc -->
 * <B>THE FOLLOWING IS ONLY VALID WHEN AJAX IS CONFIGURED</B>
 * <ul>
 * 		<li>resultDivId</li>
 * 		<li>notifyTopics</li>
 * 		<li>onLoadJS</li>
 * 		<li>preInvokeJS</li>
 * </ul>
 * The remote form has three basic modes of use, using the resultDivId, 
 * the notifyTopics, or the onLoadJS. You can mix and match any combination of 
 * them to get your desired result. All of these examples are contained in the 
 * Ajax example webapp. Lets go through some scenarios to see how you might use it:
 * <!-- END SNIPPET: ajaxJavadoc -->
 * 
 * <!-- START SNIPPET: ajxExDescription1 -->
 * Show the results in another div. If you want your results to be shown in 
 * a div, use the resultDivId where the id is the id of the div you want them 
 * shown in. This is an inner HTML approah. Your results get jammed into 
 * the div for you. Here is a sample of this approach:
 * <!-- END SNIPPET: ajxExDescription1 -->
 * 
 * <pre>
 * <!-- START SNIPPET: ajxExample1 -->
 * Remote form replacing another div:
 * &lt;div id='two' style="border: 1px solid yellow;"&gt;Initial content&lt;/div&gt;
 * &lt;s:form
 *       id='theForm2'
 *       cssStyle="border: 1px solid green;"
 *       action='/AjaxRemoteForm.action'
 *       method='post'
 *       theme="ajax"&gt;
 *
 *   &lt;input type='text' name='data' value='Struts User' /&gt;
 *   &lt;s:submit value="GO2" theme="ajax" resultDivId="two" /&gt;
 *
 * &lt;/s:form &gt;
 * <!-- END SNIPPET: ajxExample1 -->
 * </pre>
 * 
 * 
 * <!-- START SNIPPET: ajxExDescription2 -->
 * Notify other controls(divs) of a change. Using an pub-sub model you can 
 * notify others that your control changed and they can take the appropriate action. 
 * Most likely they will execute some action to refresh. The notifyTopics does this 
 * for you. You can have many topic names in a comma delimited list. 
 * eg: notifyTopics="newPerson, dataChanged" .
 * Here is an example of this approach:
 * <!-- END SNIPPET: ajxExDescription2 -->
 * 
 * <pre>
 * <!-- START SNIPPET: ajxExample2 -->
 * &lt;s:form id="frm1" action="newPersonWithXMLResult" theme="ajax"  &gt;
 *     &lt;s:textfield label="Name" name="person.name" value="person.name" size="20" required="true" /&gt;
 *     &lt;s:submit id="submitBtn" value="Save" theme="ajax"  cssClass="primary"  notifyTopics="personUpdated, systemWorking" /&gt;
 * &lt;/s:form &gt;
 * 
 * &lt;s:div href="/listPeople.action" theme="ajax" errorText="error opps"
 *         loadingText="loading..." id="cart-body" &gt;
 *     &lt;s:action namespace="" name="listPeople" executeResult="true" /&gt;
 * &lt;/s:div&gt;
 * <!-- END SNIPPET: ajxExample2 -->
 * </pre>
 *
 * <!-- START SNIPPET: ajxExDescription3 -->
 * Massage the results with JavaScript. Say that your result returns some h
 * appy XML and you want to parse it and do lots of cool things with it. 
 * The way to do this is with a onLoadJS handler. Here you provide the name of
 * a JavaScript function to be called back with the result and the event type.
 * The only key is that you must use the variable names 'data' and 'type' when 
 * defining the callback. For example: onLoadJS="myFancyDancyFunction(data, type)".
 * While I talked about XML in this example, your not limited to XML, the data in 
 * the callback will be exactly whats returned as your result.
 * Here is an example of this approach:
 * <!-- END SNIPPET: ajxExDescription3 -->
 *
 * <pre>
 * <!-- START SNIPPET: ajxExample3 -->
 * &lt;script language="JavaScript" type="text/javascript"&gt;
 *     function doGreatThings(data, type) {
 *         //Do whatever with your returned fragment... 
 *         //Perhapps.... if xml...
 *               var xml = dojo.xml.domUtil.createDocumentFromText(data);
 *               var people = xml.getElementsByTagName("person");
 *               for(var i = 0;i < people.length; i ++){
 *                   var person = people[i];
 *                   var name = person.getAttribute("name")
 *                   var id = person.getAttribute("id")
 *                   alert('Thanks dude. Person: ' + name + ' saved great!!!');
 *               }
 *
 *     }
 * &lt;/script&gt;
 *
 * &lt;s:form id="frm1" action="newPersonWithXMLResult" theme="ajax"  &gt;
 *     &lt;s:textfield label="Name" name="person.name" value="person.name" size="20" required="true" /&gt;
 *     &lt;s:submit id="submitBtn" value="Save" theme="ajax"  cssClass="primary"  onLoadJS="doGreatThings(data, type)" /&gt;
 * &lt;/s:form&gt;
 * <!-- END SNIPPET: ajxExample3 -->
 * </pre>
 *
 * @s.tag name="submit" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.SubmitTag"
 * description="Render a submit button"
 */
public class Submit extends FormButton {
    final public static String TEMPLATE = "submit";

    protected String resultDivId;
    protected String onLoadJS;
    protected String notifyTopics;
    protected String listenTopics;
    protected String preInvokeJS;
    protected String src;

    public Submit(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }

    public void evaluateParams() {
    	if (value == null) {
            value = "Submit";
        }
    	super.evaluateParams();
    }
    
    public void evaluateExtraParams() {
    	super.evaluateExtraParams();

       /* if (value == null) {
            value = "Submit";
        }*/

        //super.evaluateParams();

        if (null != src) {
            addParameter("src", findString(src));
        }

        if (null != resultDivId) {
            addParameter("resultDivId", findString(resultDivId));
        }

        if (null != onLoadJS) {
            addParameter("onLoadJS", findString(onLoadJS));
        }

        if (null != notifyTopics) {
            addParameter("notifyTopics", findString(notifyTopics));
        }

        if (null != listenTopics) {
            addParameter("listenTopics", findString(listenTopics));
        }

        if (preInvokeJS != null) {
            addParameter("preInvokeJS", findString(preInvokeJS));
        }

    }

    /**
     * Indicate whether the concrete button supports the type "image".
     *
     * @return <tt>true</tt> to indicate type image is supported.
     */
    protected boolean supportsImageType() {
        return true;
    }

    /**
     * The id of the HTML element to place the result (this can the the form's id or any id on the page.
     * @s.tagattribute required="false"  type="String"
     */
    public void setResultDivId(String resultDivId) {
        this.resultDivId = resultDivId;
    }

    /**
     * Javascript code that will be executed after the form has been submitted. The format is onLoadJS='yourMethodName(data,type)'. NOTE: the words data and type must be left like that if you want the event type and the returned data.
     * @s.tagattribute required="false" type="String"
     */
    public void setOnLoadJS(String onLoadJS) {
        this.onLoadJS = onLoadJS;
    }

    /**
     * Topic names to post an event to after the form has been submitted.
     * @s.tagattribute required="false" type="String"
     */
    public void setNotifyTopics(String notifyTopics) {
        this.notifyTopics = notifyTopics;
    }

    /**
     * Set listenTopics attribute.
     * @s.tagattribute required="false" type="String"
     */
    public void setListenTopics(String listenTopics) {
        this.listenTopics = listenTopics;
    }

    /**
     * Javascript code that will be executed before invokation. The format is preInvokeJS='yourMethodName(data,type)'.
     * @s.tagattribute required="false" type="String"
     */
    public void setPreInvokeJS(String preInvokeJS) {
        this.preInvokeJS = preInvokeJS;
    }

    /**
     * Supply a submit button text apart from submit value. Will have no effect for <i>input</i> type submit, since button text will always be the value parameter. For the type <i>image</i>, alt parameter will be set to this value.
     * @s.tagattribute required="false"
     */
    public void setLabel(String label) {
        super.setLabel(label);
    }

    /**
     * Supply an image src for <i>image</i> type submit button. Will have no effect for types <i>input</i> and <i>button</i>.
     * @s.tagattribute required="false"
     */
    public void setSrc(String src) {
        this.src = src;
    }
}
"
core/src/main/java/org/apache/struts2/components/TabbedPanel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.util.ArrayList;
import java.util.List;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * The tabbedpanel widget is primarily an AJAX component, where each tab can either be local content or remote
 * content (refreshed each time the user selects that tab).</p>
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 * <p/>
 * <!-- START SNIPPET: exdesc -->
 * The following is an example of a tabbedpanel and panel tag utilizing local and remote content.<p/>
 * <!-- END SNIPPET: exdesc -->
 * <pre>
 * <!-- START SNIPPET: example -->
 * &lt;s:tabbedPanel id="test2" theme="simple" &gt;
 *     &lt;s:panel id="left" tabName="left" theme="ajax"&gt;
 *         This is the left pane&lt;br/&gt;
 *         &lt;s:form &gt;
 *             &lt;s:textfield name="tt" label="Test Text" /&gt;  &lt;br/&gt;
 *             &lt;s:textfield name="tt2" label="Test Text2" /&gt;
 *         &lt;/s:form&gt;
 *     &lt;/s:panel&gt;
 *     &lt;s:panel remote="true" href="/AjaxTest.action" id="ryh1" theme="ajax" tabName="remote one" /&gt;
 *     &lt;s:panel id="middle" tabName="middle" theme="ajax"&gt;
 *         middle tab&lt;br/&gt;
 *         &lt;s:form &gt;
 *             &lt;s:textfield name="tt" label="Test Text44" /&gt;  &lt;br/&gt;
 *             &lt;s:textfield name="tt2" label="Test Text442" /&gt;
 *         &lt;/s:form&gt;
 *     &lt;/s:panel&gt;
 *     &lt;s:panel remote="true" href="/AjaxTest.action"  id="ryh21" theme="ajax" tabName="remote right" /&gt;
 * &lt;/s:tabbedPanel&gt;
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * <p/> <b>Additional Configuration</b>
 *
 * <!-- START SNIPPET: exdesc2 -->
 * If you are looking for the "nifty" rounded corner look, there is additional configuration. This assumes
 * that the background color of the tabs is white. If you are using a different color, please modify the
 * parameter in the Rounded() method.<p/>
 * <!-- END SNIPPET: exdesc2 -->
 *
 * <pre>
 * <!-- START SNIPPET: example2 -->
 * &lt;link rel="stylesheet" type="text/css" href="&lt;s:url value="/struts/tabs.css"/&gt;"&gt;
 * &lt;link rel="stylesheet" type="text/css" href="&lt;s:url value="/struts/niftycorners/niftyCorners.css"/&gt;"&gt;
 * &lt;link rel="stylesheet" type="text/css" href="&lt;s:url value="/struts/niftycorners/niftyPrint.css"/&gt;" media="print"&gt;
 * &lt;script type="text/javascript" src="&lt;s:url value="/struts/niftycorners/nifty.js"/&gt;"&gt;&lt;/script&gt;
 * &lt;script type="text/javascript"&gt;
 *     dojo.event.connect(window, "onload", function() {
 *         if (!NiftyCheck())
 *             return;
 *         Rounded("li.tab_selected", "top", "white", "transparent", "border #ffffffS");
 *         Rounded("li.tab_unselected", "top", "white", "transparent", "border #ffffffS");
 *         // "white" needs to be replaced with the background color
 *     });
 * &lt;/script&gt;
 * <!-- END SNIPPET: example2 -->
 * </pre>
 *
 * <b>Important:</b> Be sure to setup the page containing this tag to be Configured for AJAX
 *
 * @see Panel
 *
 * @s.tag name="tabbedPanel" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.TabbedPanelTag"
 * description="Render a tabbedPanel widget."
 */
public class TabbedPanel extends ClosingUIBean {
    public static final String TEMPLATE = "tabbedpanel";
    public static final String TEMPLATE_CLOSE = "tabbedpanel-close";
    final private static String COMPONENT_NAME = TabbedPanel.class.getName();

    protected List tabs = new ArrayList();

    public TabbedPanel(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    /**
     * Add a new panel to be rendered.
     *
     * @param pane a new panel to be rendered
     */
    public void addTab(Panel pane) {
        tabs.add(pane);
    }

    /**
     * Get the list of panel tabs for this tab panel.
     *
     * @return the list of panel tabs for this tab panel
     */
    public List getTabs() {
        return tabs;
    }

    public String getTopicName() {
        return "topic_tab_" + id + "_selected";
    }

    protected void evaluateExtraParams() {
        super.evaluateExtraParams();

        addParameter("topicName", "topic_tab_" + id + "_selected");
        addParameter("tabs", tabs);

    }

    public String getDefaultOpenTemplate() {
        return TEMPLATE;
    }

    protected String getDefaultTemplate() {
        return TEMPLATE_CLOSE;
    }

    public String getComponentName() {
        return COMPONENT_NAME;
    }

    /**
     * The id to assign to the component.
     * @s.tagattribute required="true" type="String"
     */
    public void setId(String id) {
        // This is required to override tld generation attributes to required=true
        super.setId(id);
    }
}
"
core/src/main/java/org/apache/struts2/components/Text.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.opensymphony.xwork2.util.TextUtils;
import com.opensymphony.xwork2.TextProvider;
import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * Render a I18n text message. 
 * 
 * <p/>
 *
 * The message must be in a resource bundle
 * with the same name as the action that it is associated with. In practice
 * this means that you should create a properties file in the same package
 * as your Java class with the same name as your class, but with .properties
 * extension.
 *
 * <p/>
 *
 * If the named message is not found, then the body of the tag will be used as default message.
 * If no body is used, then the name of the message will be used.
 * 
 * <!-- END SNIPPET: javadoc -->
 *
 *
 *
 * <!-- START SNIPPET: params -->
 * 
 * <ul>
 *      <li>name* (String) - the i18n message key</li>
 * </ul>
 * 
 * <!-- END SNIPPET: params -->
 *
 * <p/>
 *
 * Example:
 * <pre>
 * <!-- START SNIPPET: exdescription -->
 * 
 * Accessing messages from a given bundle (the i18n Shop example bundle in the first example) and using bundle defined through the framework in the second example.</p>
 * 
 * <!-- END SNIPPET: exdescription -->
 * </pre>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * 
 * &lt;!-- First Example --&gt;
 * &lt;s:i18n name="struts.action.test.i18n.Shop"&gt;
 *     &lt;s:text name="main.title"/&gt;
 * &lt;/s:i18n&gt;
 *
 * &lt;!-- Second Example --&gt;
 * &lt;s:text name="main.title" /&gt;
 * 
 * &lt;!-- Third Examlpe --&gt;
 * &lt;s:text name="i18n.label.greetings"&gt;
 *    &lt;s:param &gt;Mr Smith&lt;/s:param&gt;
 * &lt;/s:text&gt;
 * 
 * <!-- END SNIPPET: example -->
 * </pre>
 * 
 * 
 * <pre>
 * <!-- START SNIPPET: i18nExample -->
 * 
 * &lt;-- Fourth Example --&gt;
 * &lt;s:text name="some.key" /&gt;
 * 
 * &lt;-- Fifth Example --&gt;
 * &lt;s:text name="some.invalid.key" &gt;
 *    The Default Message That Will Be Displayed
 * &lt;/s:text&gt;
 * 
 * <!-- END SNIPPET: i18nExample -->
 * </pre>
 * 
 * @see Param
 *
 * @s.tag name="text" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.TextTag"
 * description="Render a I18n text message."
 */
public class Text extends Component implements Param.UnnamedParametric {
    private static final Log LOG = LogFactory.getLog(Text.class);

    protected List values = Collections.EMPTY_LIST;
    protected String actualName;
    protected String name;

    public Text(OgnlValueStack stack) {
        super(stack);
    }

    /**
     *  Name of resource property to fetch
     * @s.tagattribute required="true"
     */
    public void setName(String name) {
        this.name = name;
    }
    
    
    public boolean usesBody() {
    	// overriding this to true such that EVAL_BODY_BUFFERED is return and 
    	// bodyContent will be valid hence, text between start & end tag will
    	// be honoured as default message (WW-1268)
    	return true;
    }

    public boolean end(Writer writer, String body) {
        actualName = findString(name, "name", "You must specify the i18n key. Example: welcome.header");
        String defaultMessage;
        if (TextUtils.stringSet(body)) {
            defaultMessage = body;
        } else {
            defaultMessage = actualName;
        }
        String msg = null;
        OgnlValueStack stack = getStack();

        for (Iterator iterator = getStack().getRoot().iterator();
             iterator.hasNext();) {
            Object o = iterator.next();

            if (o instanceof TextProvider) {
                TextProvider tp = (TextProvider) o;
                msg = tp.getText(actualName, defaultMessage, values, stack);

                break;
            }
        }

        if (msg != null) {
            try {
                if (getId() == null) {
                    writer.write(msg);
                } else {
                    stack.getContext().put(getId(), msg);
                }
            } catch (IOException e) {
                LOG.error("Could not write out Text tag", e);
            }
        }

        return super.end(writer, "");
    }

    public void addParameter(String key, Object value) {
        addParameter(value);
    }

    public void addParameter(Object value) {
        if (values.isEmpty()) {
            values = new ArrayList(4);
        }

        values.add(value);
    }
}
"
core/src/main/java/org/apache/struts2/components/TextArea.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * Render HTML textarea tag.</p>
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * &lt;s:textarea label="Comments" name="comments" cols="30" rows="8"/&gt;
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @see TabbedPanel
 *
 * @s.tag name="textarea" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.TextareaTag"
 * description="Render HTML textarea tag."
 */
public class TextArea extends UIBean {
    final public static String TEMPLATE = "textarea";

    protected String cols;
    protected String readonly;
    protected String rows;
    protected String wrap;

    public TextArea(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }

    public void evaluateExtraParams() {
        super.evaluateExtraParams();

        if (readonly != null) {
            addParameter("readonly", findValue(readonly, Boolean.class));
        }

        if (cols != null) {
            addParameter("cols", findString(cols));
        }

        if (rows != null) {
            addParameter("rows", findString(rows));
        }

        if (wrap != null) {
            addParameter("wrap", findString(wrap));
        }
    }

    /**
     * HTML cols attribute
     * @s.tagattribute required="false" type="Integer"
     */
    public void setCols(String cols) {
        this.cols = cols;
    }

    /**
     * Whether the textarea is readonly
     * @s.tagattribute required="false" type="Boolean" default="false"
     */
    public void setReadonly(String readonly) {
        this.readonly = readonly;
    }

    /**
     * HTML rows attribute
     * @s.tagattribute required="false" type="Integer"
     */
    public void setRows(String rows) {
        this.rows = rows;
    }

    /**
     * HTML wrap attribute
     * @s.tagattribute required="false" type="String"
     */
    public void setWrap(String wrap) {
        this.wrap = wrap;
    }
}
"
core/src/main/java/org/apache/struts2/components/TextField.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * Render an HTML input field of type text</p>
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 * <p/>
 * <!-- START SNIPPET: exdescription -->
 * In this example, a text control is rendered. The label is retrieved from a ResourceBundle by calling
 * ActionSupport's getText() method.<p/>
 * <!-- END SNIPPET: exdescription -->
 * <pre>
 * <!-- START SNIPPET: example -->
 * &lt;s:textfield label="%{text('user_name')}" name="user" /&gt;
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @s.tag name="textfield" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.TextFieldTag"
 * description="Render an HTML input field of type text"
 */
public class TextField extends UIBean {
    /**
     * The name of the default template for the TextFieldTag
     */
    final public static String TEMPLATE = "text";


    protected String maxlength;
    protected String readonly;
    protected String size;

    public TextField(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }

    protected void evaluateExtraParams() {
        super.evaluateExtraParams();

        if (size != null) {
            addParameter("size", findString(size));
        }

        if (maxlength != null) {
            addParameter("maxlength", findString(maxlength));
        }

        if (readonly != null) {
            addParameter("readonly", findValue(readonly, Boolean.class));
        }
    }

    /**
     * HTML maxlength attribute
     * @s.tagattribute required="false" type="Integer"
     */
    public void setMaxlength(String maxlength) {
        this.maxlength = maxlength;
    }

    /**
     * Deprecated. Use maxlength instead.
     * @s.tagattribute required="false"
     */
    public void setMaxLength(String maxlength) {
        this.maxlength = maxlength;
    }

    /**
     * Whether the input is readonly
     * @s.tagattribute required="false" type="Boolean" default="false"
     */
    public void setReadonly(String readonly) {
        this.readonly = readonly;
    }

    /**
     * HTML size attribute
     * @s.tagattribute required="false" type="Integer"
     */
    public void setSize(String size) {
        this.size = size;
    }
}
"
core/src/main/java/org/apache/struts2/components/TimePicker.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * Renders timepicker element.</p>
 * Format supported by this component are:-
 * <table border="1">
 *   <tr>
 *   	<td>Format</td>
 *    	<td>Description</td>
 *   </tr>
 *   <tr>
 *   	<td>#HH</td>
 *   	<td>Display hour in two digit format</td>
 *   </tr>
 *   <tr>
 *   	<td>#H</td>
 *    	<td>Try to display hour in one digit format, if cannot use 2 digits</td>
 *   </tr>
 *   <tr>
 *   	<td>#hh</td>
 *   	<td>Display hour in two digit format</td>
 *   </tr>
 *   <tr>
 *   	<td>#h</td>
 *      <td>Try to display hour in one digit format, if cannot use 2 digits</td>
 *   </tr>
 *   <tr>
 *      <td>#mm</td>
 *      <td>Display minutes in 2 digits format</td>
 *   </tr>
 *   <tr>
 *   	<td>#m</td>
 *      <td>Try to display minutes in 2 digits fomrat, if cannot use 2 digits</td>
 *   </tr>
 * </table>
 * 
 * <!-- END SNIPPET: javadoc -->
 * 
 * 
 * <pre>
 * <!-- START SNIPPET: example -->
 * 
 * &lt;s:timepicker label="Show Time" name="showTime" value="05:00" format="#hh:#mm" /&gt;
 * 
 * &lt;s:timepicker label="Dinner Time" name="dinnerTime" format="#hh-#mm" /&gt;
 * 
 * <!-- END SNIPPET: example -->
 * </pre>
 * 
 * @version $Date$ $Id$
 */
public class TimePicker extends TextField {

	final public static String TEMPLATE = "timepicker";
	
	protected String format;
	protected String templatePath;
	protected String templateCssPath;
	protected String timeIconPath;
	protected String size;
	
	public TimePicker(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
		super(stack, request, response);
	}

	protected void evaluateExtraParams() {
		super.evaluateExtraParams();
		
		if (format != null) {
            addParameter("format", findString(format));
        }
        if (timeIconPath != null) {
        	addParameter("timeIconPath", timeIconPath);
        }
        if (templatePath != null) {
        	addParameter("templatePath", templatePath);
        }
        if (templateCssPath != null) {
        	addParameter("templateCssPath", templateCssPath);
        }
        if (size != null) {
        	addParameter("size", findValue(size, Integer.class));
        }
	}
	
	protected String getDefaultTemplate() {
        return TEMPLATE;
    }
	
	/**
     * The format to use for time field.
     * @s.tagattribute required="false" type="String" default="Dateformat specified by language preset (%Y/%m/%d for en)"
     */
    public void setFormat(String format) {
        this.format = format;
    }
    
    /**
     * The time picker icon path
     * @s.tagattribute required="false" type="String" default="/struts/dojo/struts/widgets/dateIcon.gif"
     */
    public void setTimeIconPath(String timeIconPath) {
    	this.timeIconPath = timeIconPath;
    }
    
    /**
     * The time picker template path.
     * @s.tagattribute required="false" type="String"
     */
    public void setTemplatePath(String templatePath) {
    	this.templatePath = templatePath;
    }
    
    /**
     * The time picker template css path.
     * @s.tagattribute required="false" type="String"
     */
    public void setTemplateCssPath(String templateCssPath) {
    	this.templateCssPath = templateCssPath;
    }
    
    /**
     * The time picker text field size.
     * @s.tagattribute required="false" type="String"
     */
    public void setSize(String size) {
    	this.size = size;
    }
	
}
"
core/src/main/java/org/apache/struts2/components/Token.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.util.TokenHelper;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * Stop double-submission of forms.</p>
 *
 * The token tag is used to help with the "double click" submission problem. It is needed if you are using the
 * TokenInterceptor or the TokenSessionInterceptor. The s:token tag merely places a hidden element that contains
 * the unique token.</p>
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * &lt;s:token /&gt;
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @see org.apache.struts2.interceptor.TokenInterceptor
 * @see org.apache.struts2.interceptor.TokenSessionStoreInterceptor
 *
 * @s.tag name="token" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.TokenTag"
 * description="Stop double-submission of forms"
 */
public class Token extends UIBean {
    
    public static final String TEMPLATE = "token";

    public Token(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }

    /**
     * First looks for the token in the PageContext using the supplied name (or {@link org.apache.struts2.util.TokenHelper#DEFAULT_TOKEN_NAME}
     * if no name is provided) so that the same token can be re-used for the scope of a request for the same name. If
     * the token is not in the PageContext, a new Token is created and set into the Session and the PageContext with
     * the name.
     */
    protected void evaluateExtraParams() {
        super.evaluateExtraParams();

        String tokenName;
        Map parameters = getParameters();

        if (parameters.containsKey("name")) {
            tokenName = (String) parameters.get("name");
        } else {
            if (name == null) {
                tokenName = TokenHelper.DEFAULT_TOKEN_NAME;
            } else {
                tokenName = findString(name);

                if (tokenName == null) {
                    tokenName = name;
                }
            }

            addParameter("name", tokenName);
        }

        String token = buildToken(tokenName);
        addParameter("token", token);
        addParameter("tokenNameField", TokenHelper.TOKEN_NAME_FIELD);
    }

    /**
     * This will be removed in a future version of Struts.
     * @deprecated Templates should use $parameters from now on, not $tag.
     */
    public String getTokenNameField() {
        return TokenHelper.TOKEN_NAME_FIELD;
    }

    private String buildToken(String name) {
        Map context = stack.getContext();
        Object myToken = context.get(name);

        if (myToken == null) {
            myToken = TokenHelper.setToken(name);
            context.put(name, myToken);
        }

        return myToken.toString();
    }
}
"
core/src/main/java/org/apache/struts2/components/Tree.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.io.Writer;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 *
 * Renders a tree widget with AJAX support.<p/>
 * 
 * The id attribute is normally specified, such that it could be looked up using
 * javascript if necessary.<p/>
 *
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * 
 * &lt-- statically --&gt;
 * &lt;s:tree id="..." label="..."&gt;
 *    &lt;s:treenode id="..." label="..." /&gt;
 *    &lt;s:treenode id="..." label="..."&gt;
 *        &lt;s:treenode id="..." label="..." /&gt;
 *        &lt;s:treenode id="..." label="..." /&gt;
 *    &;lt;/s:treenode&gt;
 *    &lt;s:treenode id="..." label="..." /&gt;
 * &lt;/s:tree&gt;
 * 
 * &lt;-- dynamically --&gt;
 * &lt;s:tree
 * 			id="..."
 *          rootNode="..."
 *          nodeIdProperty="..."
 *          nodeTitleProperty="..."
 *          childCollectionProperty="..." /&gt;
 * 
 * <!-- END SNIPPET: example -->
 * </pre>
 * 
 *
 * @s.tag name="tree" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.TreeTag"
 * description="Render a tree widget."
 */
public class Tree extends ClosingUIBean {
    
	private static final String TEMPLATE = "tree-close";
    private static final String OPEN_TEMPLATE = "tree";
    
    private String toggle = "fade";
    private String treeSelectedTopic;
    private String treeExpandedTopic;
    private String treeCollapsedTopic;
    protected String rootNodeAttr;
    protected String childCollectionProperty;
    protected String nodeTitleProperty;
    protected String nodeIdProperty;
    private String showRootGrid;
    
    private String showGrid;
    private String blankIconSrc;
	private String gridIconSrcL;
	private String gridIconSrcV;
	private String gridIconSrcP;
	private String gridIconSrcC;
	private String gridIconSrcX;
	private String gridIconSrcY;
	private String expandIconSrcPlus;
	private String expandIconSrcMinus;
	private String iconWidth;
	private String iconHeight;
	private String toggleDuration;
    private String templateCssPath;

    public Tree(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    public boolean start(Writer writer) {
        boolean result = super.start(writer);

        if (this.label == null) {
            if ((rootNodeAttr == null)
                    || (childCollectionProperty == null)
                    || (nodeTitleProperty == null)
                    || (nodeIdProperty == null)) {
                fieldError("label","The TreeTag requires either a value for 'label' or ALL of 'rootNode', " +
                        "'childCollectionProperty', 'nodeTitleProperty', and 'nodeIdProperty'", null);
            }
        }
        return result;
    }

    protected void evaluateExtraParams() {
        super.evaluateExtraParams();

        if (toggle != null) {
            addParameter("toggle", findString(toggle));
        }

        if (treeSelectedTopic != null) {
            addParameter("treeSelectedTopic", findString(treeSelectedTopic));
        }

        if (treeExpandedTopic != null) {
            addParameter("treeExpandedTopic", findString(treeExpandedTopic));
        }

        if (treeCollapsedTopic != null) {
            addParameter("treeCollapsedTopic", findString(treeCollapsedTopic));
        }

        if (rootNodeAttr != null) {
            addParameter("rootNode", findValue(rootNodeAttr));
        }

        if (childCollectionProperty != null) {
            addParameter("childCollectionProperty", findString(childCollectionProperty));
        }

        if (nodeTitleProperty != null) {
            addParameter("nodeTitleProperty", findString(nodeTitleProperty));
        }

        if (nodeIdProperty != null) {
            addParameter("nodeIdProperty", findString(nodeIdProperty));
        }
        
        if (showRootGrid != null) {
        	addParameter("showRootGrid", findValue(showRootGrid, Boolean.class));
        }
        
        
        if (showGrid != null) {
        	addParameter("showGrid", findValue(showGrid, Boolean.class));
        }
        
        if (blankIconSrc != null) {
        	addParameter("blankIconSrc", findString(blankIconSrc));
        }
        
    	if (gridIconSrcL != null) {
    		addParameter("gridIconSrcL", findString(gridIconSrcL));
    	}
    	
    	if (gridIconSrcV != null) {
    		addParameter("gridIconSrcV", findString(gridIconSrcV));
    	}
    	
    	if (gridIconSrcP != null)  {
    		addParameter("gridIconSrcP", findString(gridIconSrcP));
    	}
    	
    	if (gridIconSrcC != null) {
    		addParameter("gridIconSrcC", findString(gridIconSrcC));
    	}
    	
    	if (gridIconSrcX != null) {
    		addParameter("gridIconSrcX", findString(gridIconSrcX));
    	}
    	
    	if (gridIconSrcY != null) {
    		addParameter("gridIconSrcY", findString(gridIconSrcY));
    	}
    	
    	if (expandIconSrcPlus != null) {
    		addParameter("expandIconSrcPlus", findString(expandIconSrcPlus));
    	}
    	
    	if (expandIconSrcMinus != null) {
    		addParameter("expandIconSrcMinus", findString(expandIconSrcMinus));
    	}
    	
    	if (iconWidth != null) {
    		addParameter("iconWidth", findValue(iconWidth, Integer.class));
    	}
    	if (iconHeight != null) {
    		addParameter("iconHeight", findValue(iconHeight, Integer.class));
    	}
    	if (toggleDuration != null) {
    		addParameter("toggleDuration", findValue(toggleDuration, Integer.class));
    	}
        if (templateCssPath != null) {
        	addParameter("templateCssPath", findString(templateCssPath));
        }
    }

    public String getDefaultOpenTemplate() {
        return OPEN_TEMPLATE;
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }

    public String getToggle() {
        return toggle;
    }

    /**
     * The toggle property (either 'explode' or 'fade'). Default is 'fade'.
     * @s.tagattribute required="false"
     */
    public void setToggle(String toggle) {
        this.toggle = toggle;
    }

    public String getTreeSelectedTopic() {
        return treeSelectedTopic;
    }

    /**
     * The treeSelectedTopic property.
     * @s.tagattribute required="false"
     */
    public void setTreeSelectedTopic(String treeSelectedTopic) {
        this.treeSelectedTopic = treeSelectedTopic;
    }

    public String getTreeExpandedTopic() {
        return treeExpandedTopic;
    }

    /**
     * The treeExpandedTopic property.
     * @s.tagattribute required="false"
     */
    public void setTreeExpandedTopic(String treeExpandedTopic) {
        this.treeExpandedTopic = treeExpandedTopic;
    }

    public String getTreeCollapsedTopic() {
        return treeCollapsedTopic;
    }

    /**
     * The treeCollapsedTopic property.
     * @s.tagattribute required="false"
     */
    public void setTreeCollapsedTopic(String treeCollapsedTopic) {
        this.treeCollapsedTopic = treeCollapsedTopic;
    }

    public String getRootNode() {
        return rootNodeAttr;
    }

    /**
     * The rootNode property.
     * @s.tagattribute required="false"
     */
    public void setRootNode(String rootNode) {
        this.rootNodeAttr = rootNode;
    }

    public String getChildCollectionProperty() {
        return childCollectionProperty;
    }

    /**
     * The childCollectionProperty property.
     * @s.tagattribute required="false"
     */
    public void setChildCollectionProperty(String childCollectionProperty) {
        this.childCollectionProperty = childCollectionProperty;
    }

    public String getNodeTitleProperty() {
        return nodeTitleProperty;
    }

    /**
     * The nodeTitleProperty property.
     * @s.tagattribute required="false"
     */
    public void setNodeTitleProperty(String nodeTitleProperty) {
        this.nodeTitleProperty = nodeTitleProperty;
    }

    public String getNodeIdProperty() {
        return nodeIdProperty;
    }

    /**
     * The nodeIdProperty property.
     * @s.tagattribute required="false"
     */
    public void setNodeIdProperty(String nodeIdProperty) {
        this.nodeIdProperty = nodeIdProperty;
    }
    
    /**
     * The showRootGrid property (default true).
     * @s.tagattribute required="false"
     */
    public void setShowRootGrid(String showRootGrid) {
    	this.showRootGrid = showRootGrid;
    }
    
    public String getShowRootGrid() {
    	return showRootGrid;
    }

	public String getBlankIconSrc() {
		return blankIconSrc;
	}

	/**
	 * Blank icon image source.
	 * @s.tagattribute required="false"
	 */
	public void setBlankIconSrc(String blankIconSrc) {
		this.blankIconSrc = blankIconSrc;
	}

	public String getExpandIconSrcMinus() {
		return expandIconSrcMinus;
	}

	/**
	 * Expand icon (-) image source.
	 * @s.tagattribute required="false"
	 */
	public void setExpandIconSrcMinus(String expandIconSrcMinus) {
		this.expandIconSrcMinus = expandIconSrcMinus;
	}

	public String getExpandIconSrcPlus() {
		return expandIconSrcPlus;
	}

	/**
	 * Expand Icon (+) image source.
	 * @s.tagattribute required="false"
	 */
	public void setExpandIconSrcPlus(String expandIconSrcPlus) {
		this.expandIconSrcPlus = expandIconSrcPlus;
	}

	public String getGridIconSrcC() {
		return gridIconSrcC;
	}

	/**
	 * Image source for under child item child icons.
	 * @s.tagattribute required="false"
	 */
	public void setGridIconSrcC(String gridIconSrcC) {
		this.gridIconSrcC = gridIconSrcC;
	}

	public String getGridIconSrcL() {
		return gridIconSrcL;
	}

	
	/**
	 * Image source for last child grid.
	 * @s.tagattribute required="false"
	 */
	public void setGridIconSrcL(String gridIconSrcL) {
		this.gridIconSrcL = gridIconSrcL;
	}

	public String getGridIconSrcP() {
		return gridIconSrcP;
	}

	/**
	 * Image source for under parent item child icons.
	 * @s.tagattribute required="false"
	 */
	public void setGridIconSrcP(String gridIconSrcP) {
		this.gridIconSrcP = gridIconSrcP;
	}

	public String getGridIconSrcV() {
		return gridIconSrcV;
	}

	/**
	 * Image source for vertical line.
	 * @s.tagattribute required="false"
	 */
	public void setGridIconSrcV(String gridIconSrcV) {
		this.gridIconSrcV = gridIconSrcV;
	}

	public String getGridIconSrcX() {
		return gridIconSrcX;
	}

	/**
	 * Image source for grid for sole root item.
	 * @s.tagattribute required="false"
	 */
	public void setGridIconSrcX(String gridIconSrcX) {
		this.gridIconSrcX = gridIconSrcX;
	}

	public String getGridIconSrcY() {
		return gridIconSrcY;
	}

	/**
	 * Image source for grid for last root item.
	 * @s.tagattribute required="false"
	 */
	public void setGridIconSrcY(String gridIconSrcY) {
		this.gridIconSrcY = gridIconSrcY;
	}

	public String getIconHeight() {
		return iconHeight;
	}

	
	/**
	 * Icon height (default 18 pixels).
	 * @s.tagattribute required="false"
	 */
	public void setIconHeight(String iconHeight) {
		this.iconHeight = iconHeight;
	}

	public String getIconWidth() {
		return iconWidth;
	}

	/**
	 * Icon width (default 19 pixels).
	 * @s.tagattribute required="false"
	 */
	public void setIconWidth(String iconWidth) {
		this.iconWidth = iconWidth;
	}

	

	public String getTemplateCssPath() {
		return templateCssPath;
	}

	/**
	 * Template css path (default {contextPath}/struts/tree.css.
	 * @s.tagattribute required="false"
	 */
	public void setTemplateCssPath(String templateCssPath) {
		this.templateCssPath = templateCssPath;
	}

	public String getToggleDuration() {
		return toggleDuration;
	}

	/**
	 * Toggle duration (default 150 ms)
	 * @s.tagattribute required="false"
	 */
	public void setToggleDuration(String toggleDuration) {
		this.toggleDuration = toggleDuration;
	}

	public String getShowGrid() {
		return showGrid;
	}

	/**
	 * Show grid (default true).
	 * @s.tagattribute required="false"
	 */
	public void setShowGrid(String showGrid) {
		this.showGrid = showGrid;
	}
}

"
core/src/main/java/org/apache/struts2/components/TreeNode.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 *
 * Renders a tree node within a tree widget with AJAX support.<p/>
 *
 * Either of the following combinations should be used depending on if the tree 
 * is to be constrcted dynamically or statically. <p/>
 * 
 * <b>Dynamically</b>
 * <ul>
 * 		<li>id - id of this tree node</li>
 * 		<li>title - label to be displayed for this tree node</li>
 * </ul>
 * 
 * <b>Statically</b>
 * <ul>
 * 		<li>rootNode - the parent node of which this tree is derived from</li>
 * 		<li>nodeIdProperty - property to obtained this current tree node's id</li>
 * 		<li>nodeTitleProperty - property to obtained this current tree node's title</li>
 * 		<li>childCollectionProperty - property that returnds this current tree node's children</li>
 * </ul>
 *
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Examples</b>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * 
 * &lt-- statically --&gt;
 * &lt;s:tree id="..." label="..."&gt;
 *    &lt;s:treenode id="..." label="..." /&gt;
 *    &lt;s:treenode id="..." label="..."&gt;
 *        &lt;s:treenode id="..." label="..." /&gt;
 *        &lt;s:treenode id="..." label="..." /&gt;
 *    &;lt;/s:treenode&gt;
 *    &lt;s:treenode id="..." label="..." /&gt;
 * &lt;/s:tree&gt;
 * 
 * &lt;-- dynamically --&gt;
 * &lt;s:tree
 *          id="..."
 *          rootNode="..."
 *          nodeIdProperty="..."
 *          nodeTitleProperty="..."
 *          childCollectionProperty="..." /&gt;
 * 
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 *
 * @s.tag name="treenode" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.TreeNodeTag"
 * description="Render a tree node within a tree widget."
 */
public class TreeNode extends ClosingUIBean {
    private static final String TEMPLATE = "treenode-close";
    private static final String OPEN_TEMPLATE = "treenode";

    public TreeNode(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    public String getDefaultOpenTemplate() {
        return OPEN_TEMPLATE;
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }

    /**
     * Label expression used for rendering tree node label.
     * @s.tagattribute required="true"
     */
    public void setLabel(String label) {
        super.setLabel(label);
    }
}
"
core/src/main/java/org/apache/struts2/components/UIBean.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.io.Writer;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.StrutsConstants;
import org.apache.struts2.components.template.Template;
import org.apache.struts2.components.template.TemplateEngine;
import org.apache.struts2.components.template.TemplateEngineManager;
import org.apache.struts2.components.template.TemplateRenderingContext;
import org.apache.struts2.config.Settings;
import org.apache.struts2.views.util.ContextUtil;

import com.opensymphony.xwork2.config.ConfigurationException;
import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * UIBean is the standard superclass of all Struts UI componentns.
 * It defines common Struts and html properties all UI components should present for usage.
 *
 * <!-- START SNIPPET: templateRelatedAttributes -->
 *
 * <table border="1">
 *    <thead>
 *       <tr>
 *          <td>Attribute</td>
 *          <td>Theme</td>
 *          <td>Data Types</td>
 *          <td>Description</td>
 *       </tr>
 *    </thead>
 *    <tbody>
 *       <tr>
 *          <td>templateDir</td>
 *          <td>n/a</td>
 *          <td>String</td>
 *          <td>define the template directory</td>
 *       </td>
 *       <tr>
 *          <td>theme</td>
 *          <td>n/a</td>
 *          <td>String</td>
 *          <td>define the theme name</td>
 *       </td>
 *       <tr>
 *          <td>template</td>
 *          <td>n/a</td>
 *          <td>String</td>
 *          <td>define the template name</td>
 *       </td>
 *    </tbody>
 * </table>
 *
 * <!-- END SNIPPET: templateRelatedAttributes -->
 *
 * <p/>
 *
 * <!-- START SNIPPET: generalAttributes -->
 *
 * <table border="1">
 *    <thead>
 *       <tr>
 *          <td>Attribute</td>
 *          <td>Theme</td>
 *          <td>Data Types</td>
 *          <td>Description</td>
 *       </tr>
 *    </thead>
 *    <tbody>
 *       <tr>
 *          <td>cssClass</td>
 *          <td>simple</td>
 *          <td>String</td>
 *          <td>define html class attribute</td>
 *       </tr>
 *       <tr>
 *          <td>cssStyle</td>
 *          <td>simple</td>
 *          <td>String</td>
 *          <td>define html style attribute</td>
 *       </tr>
 *       <tr>
 *          <td>title</td>
 *          <td>simple</td>
 *          <td>String</td>
 *          <td>define html title attribute</td>
 *       </tr>
 *       <tr>
 *          <td>disabled</td>
 *          <td>simple</td>
 *          <td>String</td>
 *          <td>define html disabled attribute</td>
 *       </tr>
 *       <tr>
 *          <td>label</td>
 *          <td>xhtml</td>
 *          <td>String</td>
 *          <td>define label of form element</td>
 *       </tr>
 *       <tr>
 *          <td>labelPosition</td>
 *          <td>xhtml</td>
 *          <td>String</td>
 *          <td>define label position of form element (top/left), default to left</td>
 *       </tr>
 *       <tr>
 *          <td>requiredposition</td>
 *          <td>xhtml</td>
 *          <td>String</td>
 *          <td>define required label position of form element (left/right), default to right</td>
 *       </tr>
 *       <tr>
 *          <td>name</td>
 *          <td>simple</td>
 *          <td>String</td>
 *          <td>Form Element's field name mapping</td>
 *       </tr>
 *       <tr>
 *          <td>required</td>
 *          <td>xhtml</td>
 *          <td>Boolean</td>
 *          <td>add * to label (true to add false otherwise)</td>
 *       </tr>
 *       <tr>
 *          <td>tabIndex</td>
 *          <td>simple</td>
 *          <td>String</td>
 *          <td>define html tabindex attribute</td>
 *       </tr>
 *       <tr>
 *          <td>value</td>
 *          <td>simple</td>
 *          <td>Object</td>
 *          <td>define value of form element</td>
 *       </tr>
 *    </tbody>
 * </table>
 *
 * <!-- END SNIPPET: generalAttributes -->
 *
 * <p/>
 *
 * <!-- START SNIPPET: javascriptRelatedAttributes -->
 *
 * <table border="1">
 *    <thead>
 *       <tr>
 *          <td>Attribute</td>
 *          <td>Theme</td>
 *          <td>Data Types</td>
 *          <td>Description</td>
 *       </tr>
 *    </thead>
 *    <tbody>
 *       <tr>
 *          <td>onclick</td>
 *          <td>simple</td>
 *          <td>String</td>
 *          <td>html javascript onclick attribute</td>
 *       </tr>
 *       <tr>
 *          <td>ondbclick</td>
 *          <td>simple</td>
 *          <td>String</td>
 *          <td>html javascript ondbclick attribute</td>
 *       </tr>
 *       <tr>
 *          <td>onmousedown</td>
 *          <td>simple</td>
 *          <td>String</td>
 *          <td>html javascript onmousedown attribute</td>
 *       </tr>
 *       <tr>
 *          <td>onmouseup</td>
 *          <td>simple</td>
 *          <td>String</td>
 *          <td>html javascript onmouseup attribute</td>
 *       </tr>
 *       <tr>
 *          <td>onmouseover</td>
 *          <td>simple</td>
 *          <td>String</td>
 *          <td>html javascript onmouseover attribute</td>
 *       </tr>
 *       <tr>
 *          <td>onmouseout</td>
 *          <td>simple</td>
 *          <td>String</td>
 *          <td>html javascript onmouseout attribute</td>
 *       </tr>
 *       <tr>
 *          <td>onfocus</td>
 *          <td>simple</td>
 *          <td>String</td>
 *          <td>html javascript onfocus attribute</td>
 *       </tr>
 *       <tr>
 *          <td>onblur</td>
 *          <td>simple</td>
 *          <td>String</td>
 *          <td>html javascript onblur attribute</td>
 *       </tr>
 *       <tr>
 *          <td>onkeypress</td>
 *          <td>simple</td>
 *          <td>String</td>
 *          <td>html javascript onkeypress attribute</td>
 *       </tr>
 *       <tr>
 *          <td>onkeyup</td>
 *          <td>simple</td>
 *          <td>String</td>
 *          <td>html javascript onkeyup attribute</td>
 *       </tr>
 *       <tr>
 *          <td>onkeydown</td>
 *          <td>simple</td>
 *          <td>String</td>
 *          <td>html javascript onkeydown attribute</td>
 *       </tr>
 *       <tr>
 *          <td>onselect</td>
 *          <td>simple</td>
 *          <td>String</td>
 *          <td>html javascript onselect attribute</td>
 *       </tr>
 *       <tr>
 *          <td>onchange</td>
 *          <td>simple</td>
 *          <td>String</td>
 *          <td>html javascript onchange attribute</td>
 *       </tr>
 *    </tbody>
 * </table>
 *
 * <!-- END SNIPPET: javascriptRelatedAttributes -->
 *
 * <p/>
 *
 * <!-- START SNIPPET: tooltipattributes -->
 *
 * <table border="1">
 *  <tr>
 *     <td>Attribute</td>
 *     <td>Data Type</td>
 *     <td>Default</td>
 *     <td>Description</td>
 *  </tr>
 *  <tr>
 *  	<td>tooltip</td>
 *  	<td>String</td>
 *  	<td>none</td>
 *  	<td>Set the tooltip of this particular component</td>
 *  </tr>
 *  <tr>
 *      <td>jsTooltipEnabled</td>
 *      <td>String</td>
 *      <td>false</td>
 *      <td>Enable js tooltip rendering</td>
 *  </tr>
 *    <tr>
 *   	<td>tooltipIcon</td>
 *   	<td>String</td>
 *   	<td>/struts/static/tooltip/tooltip.gif</td>
 *   	<td>The url to the tooltip icon</td>
 *   <tr>
 *   	<td>tooltipDelay</td>
 *   	<td>String</td>
 *   	<td>500</td>
 *   	<td>Tooltip shows up after the specified timeout (miliseconds). A behavior similar to that of OS based tooltips.</td>
 *   </tr>
 * </table>
 *
 * <!-- END SNIPPET: tooltipattributes -->
 *
 *
 * <!-- START SNIPPET: tooltipdescription -->
 *
 * Every Form UI component (in xhtml / css_xhtml or any others that extends of them) could
 * have tooltip assigned to a them. The Form component's tooltip related attribute once
 * defined will be applicable to all form UI component that is created under it unless
 * explicitly overriden by having the Form UI component itself defined that tooltip attribute.
 *
 * <p/>
 *
 * In Example 1, the textfield will inherit the tooltipDelay adn tooltipIcon attribte from
 * its containing form. In other words, although it doesn't defined a tooltipAboveMousePointer
 * attribute, it will have that attributes inherited from its containing form.
 *
 * <p/>
 *
 * In Example 2, the the textfield will inherite both the tooltipDelay and
 * tooltipIcon attribute from its containing form but tooltipDelay
 * attribute is overriden at the textfield itself. Hence, the textfield actually will
 * have tooltipIcon defined as /myImages/myIcon.gif, inherited from its containing form and
 * tooltipDelay defined as 5000, due to overriden at the textfield itself.
 *
 * <p/>
 *
 * Example 3, 4 and 5 shows different way of setting the tooltipConfig attribute.<br/>
 * <b>Example 3:</b>Set tooltip config through body of param tag<br/>
 * <b>Example 4:</b>Set tooltip config through value attribute of param tag<br/>
 * <b>Example 5:</b>Set tooltip config through tooltipConfig attribute of component tag<br/>
 *
 * <!-- END SNIPPET: tooltipdescription -->
 *
 *
 * <pre>
 * <!-- START SNIPPET: tooltipexample -->
 *
 * &lt;!-- Example 1: --&gt;
 * &lt;s:form
 * 			tooltipConfig="#{'tooltipDelay':'500',
 *                           'tooltipIcon='/myImages/myIcon.gif'}" .... &gt;
 *   ....
 *     &lt;s:textfield label="Customer Name" tooltip="Enter the customer name" .... /&gt;
 *   ....
 * &lt;/s:form&gt;
 *
 * &lt;!-- Example 2: --&gt;
 * &lt;s:form
 *         tooltipConfig="#{'tooltipDelay':'500',
 *          				'tooltipIcon':'/myImages/myIcon.gif'}" ... &gt;
 *   ....
 *     &lt;s:textfield label="Address"
 *          tooltip="Enter your address"
 *          tooltipConfig="#{'tooltipDelay':'5000'}" /&gt;
 *   ....
 * &lt;/s:form&gt;
 *
 *
 * &lt;-- Example 3: --&gt;
 * &lt;s:textfield
 *        label="Customer Name"
 *	      tooltip="One of our customer Details'"&gt;
 *        &lt;s:param name="tooltipConfig"&gt;
 *             tooltipDelay = 500 |
 *             tooltipIcon = /myImages/myIcon.gif 
 *        &lt;/s:param&gt;
 * &lt;/s:textfield&gt;
 *
 *
 * &lt;-- Example 4: --&gt;
 * &lt;s:textfield
 *	        label="Customer Address"
 *	        tooltip="Enter The Customer Address" &gt;
 *	        &lt;s:param
 *              name="tooltipConfig"
 *              value="#{'tooltipDelay':'500',
 *                       'tooltipIcon':'/myImages/myIcon.gif'}" /&gt;
 * &lt;/s:textfield&gt;
 *
 *
 * &lt;-- Example 5: --&gt;
 * &lt;s:textfield
 *          label="Customer Telephone Number"
 *          tooltip="Enter customer Telephone Number"
 *          tooltipConfig="#{'tooltipDelay':'500',
 *                           'tooltipIcon':'/myImages/myIcon.gif'}" /&gt;
 *
 * <!-- END SNIPPET: tooltipexample -->
 * </pre>
 *
 */
public abstract class UIBean extends Component {
    private static final Log LOG = LogFactory.getLog(UIBean.class);

    protected HttpServletRequest request;
    protected HttpServletResponse response;

    public UIBean(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack);
        this.request = request;
        this.response = response;
        this.templateSuffix = ContextUtil.getTemplateSuffix(stack.getContext());
    }

    // The templateSuffic to use, overrides the default one if not null.
    protected String templateSuffix;

    // The template to use, overrides the default one.
    protected String template;

    // templateDir and theme attributes
    protected String templateDir;
    protected String theme;

    protected String cssClass;
    protected String cssStyle;
    protected String disabled;
    protected String label;
    protected String labelPosition;
    protected String requiredposition;
    protected String name;
    protected String required;
    protected String tabindex;
    protected String value;
    protected String title;

    // HTML scripting events attributes
    protected String onclick;
    protected String ondblclick;
    protected String onmousedown;
    protected String onmouseup;
    protected String onmouseover;
    protected String onmousemove;
    protected String onmouseout;
    protected String onfocus;
    protected String onblur;
    protected String onkeypress;
    protected String onkeydown;
    protected String onkeyup;
    protected String onselect;
    protected String onchange;
    
    // common html attributes
    protected String accesskey;

    // javascript tooltip attribute
    protected String tooltip;
    protected String tooltipConfig;


    public boolean end(Writer writer, String body) {
        evaluateParams();
        try {
            super.end(writer, body, false);
            mergeTemplate(writer, buildTemplateName(template, getDefaultTemplate()));
        } catch (Exception e) {
            LOG.error("error when rendering", e);
        }
        finally {
        	popComponentStack();
        }

        return false;
    }

    /**
     * A contract that requires each concrete UI Tag to specify which template should be used as a default.  For
     * example, the CheckboxTab might return "checkbox.vm" while the RadioTag might return "radio.vm".  This value
     * <strong>not</strong> begin with a '/' unless you intend to make the path absolute rather than relative to the
     * current theme.
     *
     * @return The name of the template to be used as the default.
     */
    protected abstract String getDefaultTemplate();

    protected Template buildTemplateName(String myTemplate, String myDefaultTemplate) {
        String template = myDefaultTemplate;

        if (myTemplate != null) {
            template = findString(myTemplate);
        }

        String templateDir = getTemplateDir();
        String theme = getTheme();

        return new Template(templateDir, theme, template);

    }

    protected void mergeTemplate(Writer writer, Template template) throws Exception {
        final TemplateEngine engine = TemplateEngineManager.getTemplateEngine(template, templateSuffix);
        if (engine == null) {
            throw new ConfigurationException("Unable to find a TemplateEngine for template " + template);
        }

        if (LOG.isDebugEnabled()) {
            LOG.debug("Rendering template " + template);
        }

        final TemplateRenderingContext context = new TemplateRenderingContext(template, writer, getStack(), getParameters(), this);
        engine.renderTemplate(context);
    }

    public String getTemplateDir() {
        String templateDir = null;

        if (this.templateDir != null) {
            templateDir = findString(this.templateDir);
        }

        // If templateDir is not explicitly given,
        // try to find attribute which states the dir set to use
        if ((templateDir == null) || (templateDir.equals(""))) {
            templateDir = (String) stack.findValue("#attr.templateDir");
        }

        // Default template set
        if ((templateDir == null) || (templateDir.equals(""))) {
            templateDir = Settings.get(StrutsConstants.STRUTS_UI_TEMPLATEDIR);
        }

        // Defaults to 'template'
        if ((templateDir == null) || (templateDir.equals(""))) {
            templateDir = "template";
        }

        return templateDir;
    }

    public String getTheme() {
        String theme = null;

        if (this.theme != null) {
            theme = findString(this.theme);
        }

        if ( theme == null || theme.equals("") ) {
            Form form = (Form) findAncestor(Form.class);
            if (form != null) {
                theme = form.getTheme();
            }
        }

        // If theme set is not explicitly given,
        // try to find attribute which states the theme set to use
        if ((theme == null) || (theme.equals(""))) {
            theme = (String) stack.findValue("#attr.theme");
        }

        // Default theme set
        if ((theme == null) || (theme.equals(""))) {
            theme = Settings.get(StrutsConstants.STRUTS_UI_THEME);
        }

        return theme;
    }

    public void evaluateParams() {
        addParameter("templateDir", getTemplateDir());
        addParameter("theme", getTheme());

        String name = null;

        if (this.name != null) {
            name = findString(this.name);
            addParameter("name", name);
        }

        if (label != null) {
            addParameter("label", findString(label));
        }

        if (labelPosition != null) {
            addParameter("labelposition", findString(labelPosition));
        }

        if (requiredposition != null) {
            addParameter("requiredposition", findString(requiredposition));
        }

        if (required != null) {
            addParameter("required", findValue(required, Boolean.class));
        }

        if (disabled != null) {
            addParameter("disabled", findValue(disabled, Boolean.class));
        }

        if (tabindex != null) {
            addParameter("tabindex", findString(tabindex));
        }

        if (onclick != null) {
            addParameter("onclick", findString(onclick));
        }

        if (ondblclick != null) {
            addParameter("ondblclick", findString(ondblclick));
        }

        if (onmousedown != null) {
            addParameter("onmousedown", findString(onmousedown));
        }

        if (onmouseup != null) {
            addParameter("onmouseup", findString(onmouseup));
        }

        if (onmouseover != null) {
            addParameter("onmouseover", findString(onmouseover));
        }

        if (onmousemove != null) {
            addParameter("onmousemove", findString(onmousemove));
        }

        if (onmouseout != null) {
            addParameter("onmouseout", findString(onmouseout));
        }

        if (onfocus != null) {
            addParameter("onfocus", findString(onfocus));
        }

        if (onblur != null) {
            addParameter("onblur", findString(onblur));
        }

        if (onkeypress != null) {
            addParameter("onkeypress", findString(onkeypress));
        }

        if (onkeydown != null) {
            addParameter("onkeydown", findString(onkeydown));
        }

        if (onkeyup != null) {
            addParameter("onkeyup", findString(onkeyup));
        }

        if (onselect != null) {
            addParameter("onselect", findString(onselect));
        }

        if (onchange != null) {
            addParameter("onchange", findString(onchange));
        }

        if (accesskey != null) {
        	addParameter("accesskey", findString(accesskey));
        }
        
        if (cssClass != null) {
            addParameter("cssClass", findString(cssClass));
        }

        if (cssStyle != null) {
            addParameter("cssStyle", findString(cssStyle));
        }

        if (title != null) {
            addParameter("title", findString(title));
        }


        // see if the value was specified as a parameter already
        if (parameters.containsKey("value")) {
            parameters.put("nameValue", parameters.get("value"));
        } else {
            if (evaluateNameValue()) {
                final Class valueClazz = getValueClassType();

                if (valueClazz != null) {
                    if (value != null) {
                        addParameter("nameValue", findValue(value, valueClazz));
                    } else if (name != null) {
                        String expr = name;
                        if (altSyntax()) {
                            expr = "%{" + expr + "}";
                        }

                        addParameter("nameValue", findValue(expr, valueClazz));
                    }
                } else {
                    if (value != null) {
                        addParameter("nameValue", findValue(value));
                    } else if (name != null) {
                        addParameter("nameValue", findValue(name));
                    }
                }
            }
        }

        final Form form = (Form) findAncestor(Form.class);

        // create HTML id element
        populateComponentHtmlId(form);

        if (form != null ) {
            addParameter("form", form.getParameters());

            if ( name != null ) {
            	// list should have been created by the form component
                List tags = (List) form.getParameters().get("tagNames");
                tags.add(name);
            }
        }





        // tooltip & tooltipConfig
        if (tooltipConfig != null) {
    		addParameter("tooltipConfig", findValue(tooltipConfig));
    	}
        if (tooltip != null) {
        	addParameter("tooltip", findString(tooltip));

        	Map tooltipConfigMap = getTooltipConfig(this);

        	if (form != null) { // inform the containing form that we need tooltip javascript included
        		form.addParameter("hasTooltip", Boolean.TRUE);

        		// tooltipConfig defined in component itseilf will take precedence
        		// over those defined in the containing form
        		Map overallTooltipConfigMap = getTooltipConfig(form);
        		overallTooltipConfigMap.putAll(tooltipConfigMap); // override parent form's tooltip config

        		for (Iterator i = overallTooltipConfigMap.entrySet().iterator(); i.hasNext(); ) {
        			Map.Entry entry = (Map.Entry) i.next();
        			addParameter((String) entry.getKey(), entry.getValue());
        		}
        	}
        	else {
        		LOG.warn("No ancestor Form found, javascript based tooltip will not work, however standard HTML tooltip using alt and title attribute will still work ");
        	}
        }
        evaluateExtraParams();

    }

    protected String escape(String name) {
        // escape any possible values that can make the ID painful to work with in JavaScript
        if (name != null) {
            return name.replaceAll("[\\.\\[\\]]", "_");
        } else {
            return "";
        }
    }

    protected void evaluateExtraParams() {
    }

    protected boolean evaluateNameValue() {
        return true;
    }

    protected Class getValueClassType() {
        return String.class;
    }

    public void addFormParameter(String key, Object value) {
        Form form = (Form) findAncestor(Form.class);
        if (form != null) {
            form.addParameter(key, value);
        }
    }

    protected void enableAncestorFormCustomOnsubmit() {
    	Form form = (Form) findAncestor(Form.class);
    	if (form != null) {
    		form.addParameter("customOnsubmitEnabled", Boolean.TRUE);
    	} else {
    		LOG.warn("Cannot find an Ancestor form, custom onsubmit is NOT enabled");
    	}
    }

    protected Map getTooltipConfig(UIBean component) {
    	Object tooltipConfigObj = component.getParameters().get("tooltipConfig");
    	Map tooltipConfig = new LinkedHashMap();

    	if (tooltipConfigObj instanceof Map) {
    		// we get this if its configured using
    		// 1] UI component's tooltipConfig attribute  OR
    		// 2] <param name="tooltip" value="" /> param tag value attribute

    		tooltipConfig = new LinkedHashMap((Map)tooltipConfigObj);
    	} else if (tooltipConfigObj instanceof String) {

    		// we get this if its configured using
    		// <param name="tooltipConfig"> ... </param> tag's body
    		String tooltipConfigStr = (String) tooltipConfigObj;
    		String[] tooltipConfigArray = tooltipConfigStr.split("\\|");

    		for (int a=0; a<tooltipConfigArray.length; a++) {
    			String[] configEntry = ((String)tooltipConfigArray[a].trim()).split("=");
    			String key = configEntry[0].trim();
    			String value = null;
    			if (configEntry.length > 1) {
    				value = configEntry[1].trim();
    				tooltipConfig.put(key, value.toString());
    			}
    			else {
    				LOG.warn("component "+component+" tooltip config param "+key+" has no value defined, skipped");
    			}
    		}
    	}
    	return tooltipConfig;
    }

    /**
     * Create HTML id element for the component and populate this component parmaeter
     * map.
     * 
     * The order is as follows :-
     * <ol>
     *   <li>This component id attribute</li>
     *   <li>[containing_form_id]_[this_component_name]</li>
     *   <li>[this_component_name]</li>
     * </ol>
     * 
     * @param form
     */
    protected void populateComponentHtmlId(Form form) {
    	if (id != null) {
            // this check is needed for backwards compatibility with 2.1.x
            if (altSyntax()) {
                addParameter("id", findString(id));
            } else {
                addParameter("id", id);
            }
        } else if (form != null) {
            addParameter("id", form.getParameters().get("id") + "_" + escape(name));
        } else {
            addParameter("id", escape(name));
        }
    }
    

    /**
     * The template directory.
     * @s.tagattribute required="false"
     */
    public void setTemplateDir(String templateDir) {
    	this.templateDir = templateDir;
    }

    /**
     * The theme (other than default) to use for rendering the element
     * @s.tagattribute required="false"
      */
    public void setTheme(String theme) {
        this.theme = theme;
    }

    public String getTemplate() {
        return template;
    }

    /**
     * The template (other than default) to use for rendering the element
     * @s.tagattribute required="false"
     */
    public void setTemplate(String template) {
        this.template = template;
    }

    /**
     * The css class to use for element
     * @s.tagattribute required="false"
     */
    public void setCssClass(String cssClass) {
        this.cssClass = cssClass;
    }

    /**
     * The css style definitions for element ro use
     * @s.tagattribute required="false"
     */
    public void setCssStyle(String cssStyle) {
        this.cssStyle = cssStyle;
    }

    /**
     * Set the html title attribute on rendered html element
     * @s.tagattribute required="false"
     */
    public void setTitle(String title) {
        this.title = title;
    }

    /**
     * Set the html disabled attribute on rendered html element
     * @s.tagattribute required="false"
     */
    public void setDisabled(String disabled) {
        this.disabled = disabled;
    }

    /**
     * Label expression used for rendering a element specific label
     * @s.tagattribute required="false"
     */
    public void setLabel(String label) {
        this.label = label;
    }

    /**
     * define label position of form element (top/left)
     * @s.tagattribute required="false"
     */
    public void setLabelposition(String labelPosition) {
        this.labelPosition = labelPosition;
    }

    /**
     * define required position of required form element (left|right)
     * @s.tagattribute required="false"
     */
    public void setRequiredposition(String requiredposition) {
        this.requiredposition = requiredposition;
    }

    /**
     * The name to set for element
     * @s.tagattribute required="false"
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * If set to true, the rendered element will indicate that input is required
     * @s.tagattribute  required="false" type="Boolean" default="false"
     */
    public void setRequired(String required) {
        this.required = required;
    }

    /**
     * Set the html tabindex attribute on rendered html element
     * @s.tagattribute required="false"
     */
    public void setTabindex(String tabindex) {
        this.tabindex = tabindex;
    }

    /**
     * Preset the value of input element.
     * @s.tagattribute required="false"
     */
    public void setValue(String value) {
        this.value = value;
    }

    /**
     * Set the html onclick attribute on rendered html element
     * @s.tagattribute required="false"
     */
    public void setOnclick(String onclick) {
        this.onclick = onclick;
    }

    /**
     * Set the html ondblclick attribute on rendered html element
     * @s.tagattribute required="false"
     */
    public void setOndblclick(String ondblclick) {
        this.ondblclick = ondblclick;
    }

    /**
     * Set the html onmousedown attribute on rendered html element
     * @s.tagattribute required="false"
     */
    public void setOnmousedown(String onmousedown) {
        this.onmousedown = onmousedown;
    }

    /**
     * Set the html onmouseup attribute on rendered html element
     * @s.tagattribute required="false"
     */
    public void setOnmouseup(String onmouseup) {
        this.onmouseup = onmouseup;
    }

    /**
     * Set the html onmouseover attribute on rendered html element
     * @s.tagattribute required="false"
     */
    public void setOnmouseover(String onmouseover) {
        this.onmouseover = onmouseover;
    }

    /**
     * Set the html onmousemove attribute on rendered html element
     * @s.tagattribute required="false"
     */
    public void setOnmousemove(String onmousemove) {
        this.onmousemove = onmousemove;
    }

    /**
     * Set the html onmouseout attribute on rendered html element
     * @s.tagattribute required="false"
     */
    public void setOnmouseout(String onmouseout) {
        this.onmouseout = onmouseout;
    }

    /**
     * Set the html onfocus attribute on rendered html element
     * @s.tagattribute required="false"
     */
    public void setOnfocus(String onfocus) {
        this.onfocus = onfocus;
    }

    /**
     * Set the html onblur attribute on rendered html element
     * @s.tagattribute required="false"
     */
    public void setOnblur(String onblur) {
        this.onblur = onblur;
    }

    /**
     * Set the html onkeypress attribute on rendered html element
     * @s.tagattribute required="false"
     */
    public void setOnkeypress(String onkeypress) {
        this.onkeypress = onkeypress;
    }

    /**
     * Set the html onkeydown attribute on rendered html element
     * @s.tagattribute required="false"
     */
    public void setOnkeydown(String onkeydown) {
        this.onkeydown = onkeydown;
    }

    /**
     * Set the html onkeyup attribute on rendered html element
     * @s.tagattribute required="false"
     */
    public void setOnkeyup(String onkeyup) {
        this.onkeyup = onkeyup;
    }

    /**
     * Set the html onselect attribute on rendered html element
     * @s.tagattribute required="false"
     */
    public void setOnselect(String onselect) {
        this.onselect = onselect;
    }

    /**
     * Set the html onchange attribute on rendered html element
     * @s.tagattribute required="false"
     */
    public void setOnchange(String onchange) {
        this.onchange = onchange;
    }
    
    /**
     * Set the html accesskey attribute on rendered html element
     * @s.tagattribute required="false"
     */
    public void setAccesskey(String accesskey) {
    	this.accesskey = accesskey;
    }

    /**
     * Set the tooltip of this particular component
     * @s.tagattribute required="false" type="String" default=""
     */
    public void setTooltip(String tooltip) {
    	this.tooltip = tooltip;
    }

    /**
     * Set the tooltip configuration
     * @s.tagattribute required="false" type="String" default=""
     */
    public void setTooltipConfig(String tooltipConfig) {
    	this.tooltipConfig = tooltipConfig;
    }
}
"
core/src/main/java/org/apache/struts2/components/UpDownSelect.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.util.LinkedHashMap;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * 
 * Create a Select component with buttons to move the elements in the select component
 * up and down. When the containing form is submited, its elements will be submitted in 
 * the order they are arranged (top to bottom).
 * 
 * <!-- END SNIPPET: javadoc -->
 * 
 * <p/>
 * 
 * <pre>
 * <!-- START SNIPPET: example -->
 * 
 * &lt;!-- Example 1: simple example --&gt;
 * &lt;s:updownselect
 * list="#{'england':'England', 'america':'America', 'germany':'Germany'}" 
 * name="prioritisedFavouriteCountries" 
 * headerKey="-1" 
 * headerValue="--- Please Order Them Accordingly ---" 
 * emptyOption="true" /&gt;
 *
 * &lt;!-- Example 2: more complex example --&gt;
 * &lt;s:updownselect
 * list="defaultFavouriteCartoonCharacters" 
 * name="prioritisedFavouriteCartoonCharacters" 
 * headerKey="-1" 
 * headerValue="--- Please Order ---" 
 * emptyOption="true" 
 * allowMoveUp="true" 
 * allowMoveDown="true" 
 * allowSelectAll="true" 
 * moveUpLabel="Move Up"
 * moveDownLabel="Move Down" 
 * selectAllLabel="Select All" /&gt;
 * 
 * <!-- END SNIPPET: example -->
 * </pre>
 * 
 * @version $Date$ $Id$
 * 
 * @s.tag name="updownselect" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.UpDownSelectTag"
 * description="Render a up down select element"
 */
public class UpDownSelect extends Select {
	
	private static final Log _log = LogFactory.getLog(UpDownSelect.class);
	

	final public static String TEMPLATE = "updownselect";
	
	protected String allowMoveUp;
	protected String allowMoveDown;
	protected String allowSelectAll;
	
	protected String moveUpLabel;
	protected String moveDownLabel;
	protected String selectAllLabel;
	
	
	public String getDefaultTemplate() {
		return TEMPLATE;
	}
	
	public UpDownSelect(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
		super(stack, request, response);
	}
	
	public void evaluateParams() {
		super.evaluateParams();
		
		
		// override Select's default
		if (size == null || size.trim().length() <= 0) {
			addParameter("size", "5");
		}
		if (multiple == null || multiple.trim().length() <= 0) {
			addParameter("multiple", Boolean.TRUE);
		}
		
		
		
		if (allowMoveUp != null) {
			addParameter("allowMoveUp", findValue(allowMoveUp, Boolean.class));
		}
		if (allowMoveDown != null) {
			addParameter("allowMoveDown", findValue(allowMoveDown, Boolean.class));
		}
		if (allowSelectAll != null) {
			addParameter("allowSelectAll", findValue(allowSelectAll, Boolean.class));
		}
		
		if (moveUpLabel != null) {
			addParameter("moveUpLabel", findString(moveUpLabel));
		}
		if (moveDownLabel != null) {
			addParameter("moveDownLabel", findString(moveDownLabel));
		}
		if (selectAllLabel != null) {
			addParameter("selectAllLabel", findString(selectAllLabel));
		}
		
		
		// inform our form ancestor about this UpDownSelect so the form knows how to 
		// auto select all options upon it submission
		Form ancestorForm = (Form) findAncestor(Form.class);
		if (ancestorForm != null) {
			
			// inform form ancestor that we are using a custom onsubmit
			enableAncestorFormCustomOnsubmit();
			
			Map m = (Map) ancestorForm.getParameters().get("updownselectIds");
			if (m == null) {
				// map with key -> id ,  value -> headerKey
				m = new LinkedHashMap();
			}
			m.put(getParameters().get("id"), getParameters().get("headerKey"));
			ancestorForm.getParameters().put("updownselectIds", m);
		}
		else {
			_log.warn("no ancestor form found for updownselect "+this+", therefore autoselect of all elements upon form submission will not work ");
		}
	}

	
	public String getAllowMoveUp() { 
		return allowMoveUp;
	}
	/**
     * Whether move up button should be displayed
	 * @s.tagattribute required="false" type="Boolean" default="true"
	 */
	public void setAllowMoveUp(String allowMoveUp) {
		this.allowMoveUp = allowMoveUp;
	}
	
	
	
	public String getAllowMoveDown() {
		return allowMoveDown;
	}
	/**
     * Whether move down button should be displayed
	 * @s.tagattribute required="false" type="Boolean" default="true"
	 */
	public void setAllowMoveDown(String allowMoveDown) {
		this.allowMoveDown = allowMoveDown;
	}
	
	
	
	public String getAllowSelectAll() {
		return allowSelectAll;
	}
	/**
     * Whether or not select all button should be displayed
	 * @s.tagattribute required="false" type="Boolean" default="true"
	 */
	public void setAllowSelectAll(String allowSelectAll) {
		this.allowSelectAll = allowSelectAll;
	}
	
	
	public String getMoveUpLabel() {
		return moveUpLabel;
	}
	/**
     * Text to display on the move up button
	 * @s.tagattribute required="false" type="String" default="^"
	 */
	public void setMoveUpLabel(String moveUpLabel) {
		this.moveUpLabel = moveUpLabel;
	}
	
	
	
	public String getMoveDownLabel() {
		return moveDownLabel;
	}
	/**
     * Text to display on the move down button
	 * @s.tagattribute required="false" type="String" default="v"
	 */
	public void setMoveDownLabel(String moveDownLabel) {
		this.moveDownLabel = moveDownLabel;
	}
	

	
	public String getSelectAllLabel() {
		return selectAllLabel;
	}
	/**
     * Text to display on the select all button
	 * @s.tagattribute required="false" type="String" default="*"
	 */
	public void setSelectAllLabel(String selectAllLabel) {
		this.selectAllLabel = selectAllLabel;
	}
}
"
core/src/main/java/org/apache/struts2/components/URL.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components;

import java.io.IOException;
import java.io.Writer;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.StrutsException;
import org.apache.struts2.StrutsConstants;
import org.apache.struts2.config.Settings;
import org.apache.struts2.dispatcher.Dispatcher;
import org.apache.struts2.portlet.context.PortletActionContext;
import org.apache.struts2.portlet.util.PortletUrlHelper;
import org.apache.struts2.views.util.UrlHelper;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.util.OgnlValueStack;
import com.opensymphony.xwork2.util.XWorkContinuationConfig;

/**
 * <!-- START SNIPPET: javadoc -->
 * 
 * <p>This tag is used to create a URL.</p>
 *
 * <p>You can use the "param" tag inside the body to provide
 * additional request parameters.</p>
 * 
 * <b>NOTE:</b>
 * <p>When includeParams is 'all' or 'get', the parameter defined in param tag will take
 * precedence and will not be overriden if they exists in the parameter submitted. For 
 * example, in Example 3 below, if there is a id parameter in the url where the page this
 * tag is included like http://<host>:<port>/<context>/editUser.action?id=3333&name=John
 * the generated url will be http://<host>:<port>/context>/editUser.action?id=22&name=John
 * cause the parameter defined in the param tag will take precedence.</p>
 * 
 * <!-- END SNIPPET: javadoc -->
 *
 *
 * <!-- START SNIPPET: params -->
 * 
 * <ul>
 *      <li>action (String) - (value or action choose either one, if both exist value takes precedence) action's name (alias) <li>
 *      <li>value (String) - (value or action choose either one, if both exist value takes precedence) the url itself</li>
 *      <li>scheme (String) - http scheme (http, https) default to the scheme this request is in</li>
 *      <li>namespace - action's namespace</li>
 *      <li>method (String) - action's method, default to execute() </li>
 *      <li>encode (Boolean) - url encode the generated url. Default is true</li>
 *      <li>includeParams (String) - The includeParams attribute may have the value 'none', 'get' or 'all'. Default is 'get'.
 *                                   none - include no parameters in the URL
 *                                   get  - include only GET parameters in the URL (default)
 *                                   all  - include both GET and POST parameters in the URL
 *      </li>
 *      <li>includeContext (Boolean) - determine wheather to include the web app context path. Default is true.</li>
 * </ul>
 * 
 * <!-- END SNIPPET: params -->
 *
 * <p/> <b>Examples</b>
 * <pre>
 * <!-- START SNIPPET: example -->
 * 
 * &lt;-- Example 1 --&gt;
 * &lt;s:url value="editGadget.action"&gt;
 *     &lt;s:param name="id" value="%{selected}" /&gt;
 * &lt;/s:url&gt;
 *
 * &lt;-- Example 2 --&gt;
 * &lt;s:url action="editGadget"&gt;
 *     &lt;s:param name="id" value="%{selected}" /&gt;
 * &lt;/s:url&gt;
 * 
 * &lt;-- Example 3--&gt;
 * &lt;s:url includeParams="get"  &gt;
 *     &lt:param name="id" value="%{'22'}" /&gt;
 * &lt;/s:url&gt;
 * 
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @see Param
 *
 * @s.tag name="url" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.URLTag"
 * description="This tag is used to create a URL"
 */
public class URL extends Component {
    private static final Log LOG = LogFactory.getLog(URL.class);

    /**
     * The includeParams attribute may have the value 'none', 'get' or 'all'.
     * It is used when the url tag is used without a value attribute.
     * Its value is looked up on the ValueStack
     * If no includeParams is specified then 'get' is used.
     * none - include no parameters in the URL
     * get  - include only GET parameters in the URL (default)
     * all  - include both GET and POST parameters in the URL
     */
    public static final String NONE = "none";
    public static final String GET = "get";
    public static final String ALL = "all";

    private HttpServletRequest req;
    private HttpServletResponse res;

    protected String includeParams;
    protected String scheme;
    protected String value;
    protected String action;
    protected String namespace;
    protected String method;
    protected boolean encode = true;
    protected boolean includeContext = true;
    protected String portletMode;
    protected String windowState;
    protected String portletUrlType;
    protected String anchor;

    public URL(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack);
        this.req = req;
        this.res = res;
    }

    public boolean start(Writer writer) {
        boolean result = super.start(writer);

        if (value != null) {
            value = findString(value);
        }

        // no explicit url set so attach params from current url, do
        // this at start so body params can override any of these they wish.
        try {
        	// ww-1266
            String includeParams =
                    Settings.isSet(StrutsConstants.STRUTS_URL_INCLUDEPARAMS) ?
                    Settings.get(StrutsConstants.STRUTS_URL_INCLUDEPARAMS).toLowerCase() : GET;


            if (this.includeParams != null) {
                includeParams = findString(this.includeParams);
            }

            if (NONE.equalsIgnoreCase(includeParams)) {
            	mergeRequestParameters(value, parameters, Collections.EMPTY_MAP);
                ActionContext.getContext().put(XWorkContinuationConfig.CONTINUE_KEY, null);
            } else if (ALL.equalsIgnoreCase(includeParams)) {
                mergeRequestParameters(value, parameters, req.getParameterMap());

                // for ALL also include GET parameters
                includeGetParameters();
            } else if (GET.equalsIgnoreCase(includeParams) || (includeParams == null && value == null && action == null)) {
                includeGetParameters();
            } else if (includeParams != null) {
                LOG.warn("Unknown value for includeParams parameter to URL tag: " + includeParams);
            }
        } catch (Exception e) {
            LOG.warn("Unable to put request parameters (" + req.getQueryString() + ") into parameter map.", e);
        }


        return result;
    }

    private void includeGetParameters() {
        if(!(Dispatcher.getInstance().isPortletSupportActive() && PortletActionContext.isPortletRequest())) {
            String query = extractQueryString();
            mergeRequestParameters(value, parameters, UrlHelper.parseQueryString(query));
        }
    }

    private String extractQueryString() {
        // Parse the query string to make sure that the parameters come from the query, and not some posted data
        String query = req.getQueryString();

        if (query != null) {
            // Remove possible #foobar suffix
            int idx = query.lastIndexOf('#');

            if (idx != -1) {
                query = query.substring(0, idx);
            }
        }
        return query;
    }

    public boolean end(Writer writer, String body) {
        String scheme = req.getScheme();

        if (this.scheme != null) {
            scheme = this.scheme;
        }

        String result;
        if (value == null && action != null) {
            if(Dispatcher.getInstance().isPortletSupportActive() && PortletActionContext.isPortletRequest()) {
                result = PortletUrlHelper.buildUrl(action, namespace, parameters, portletUrlType, portletMode, windowState);
            }
            else {
                result = determineActionURL(action, namespace, method, req, res, parameters, scheme, includeContext, encode);
            }
        } else {
            if(Dispatcher.getInstance().isPortletSupportActive() && PortletActionContext.isPortletRequest()) {
                result = PortletUrlHelper.buildResourceUrl(value, parameters);
            }
            else {
            	String _value = value;
            	
            	// We don't include the request parameters cause they would have been 
            	// prioritised before this [in start(Writer) method]
            	if (_value != null && _value.indexOf("?") > 0) {
            		_value = _value.substring(0, _value.indexOf("?"));
            	}
                result = UrlHelper.buildUrl(_value, req, res, parameters, scheme, includeContext, encode);
            }
        }
        if ( anchor != null && anchor.length() > 0 ) {
            result += '#' + anchor;
        }

        String id = getId();

        if (id != null) {
            getStack().getContext().put(id, result);

            // add to the request and page scopes as well
            req.setAttribute(id, result);
        } else {
            try {
                writer.write(result);
            } catch (IOException e) {
                throw new StrutsException("IOError: " + e.getMessage(), e);
            }
        }
        return super.end(writer, body);
    }

    /**
     * The includeParams attribute may have the value 'none', 'get' or 'all'.
     * @s.tagattribute required="false" default="get"
     */
    public void setIncludeParams(String includeParams) {
        this.includeParams = includeParams;
    }

    /**
     * Set scheme attribute
     * @s.tagattribute required="false"
     */
    public void setScheme(String scheme) {
        this.scheme = scheme;
    }

    /**
     * The target value to use, if not using action
     * @s.tagattribute required="false"
     */
    public void setValue(String value) {
        this.value = value;
    }

    /**
     * The action generate url for, if not using value
     * @s.tagattribute required="false"
     */
    public void setAction(String action) {
        this.action = action;
    }

    /**
     * The namespace to use
     * @s.tagattribute required="false"
     */
    public void setNamespace(String namespace) {
        this.namespace = namespace;
    }

    /**
     * The method of action to use
     * @s.tagattribute required="false"
     */
    public void setMethod(String method) {
        this.method = method;
    }

    /**
     * whether to encode parameters
     * @s.tagattribute required="false" type="Boolean" default="true"
     */
    public void setEncode(boolean encode) {
        this.encode = encode;
    }

    /**
     * whether actual context should be included in url
     * @s.tagattribute required="false" type="Boolean" default="true"
     */
    public void setIncludeContext(boolean includeContext) {
        this.includeContext = includeContext;
    }
    
    /**
     * The resulting portlet mode
     * @s.tagattribute required="false"
     */
    public void setPortletMode(String portletMode) {
        this.portletMode = portletMode;
    }

    /**
     * The resulting portlet window state
     * @s.tagattribute required="false"
     */
    public void setWindowState(String windowState) {
        this.windowState = windowState;
    }

    /**
     * Specifies if this should be a portlet render or action url
     * @s.tagattribute required="false"
     */
    public void setPortletUrlType(String portletUrlType) {
        this.portletUrlType = portletUrlType;
    }

    /**
     * The anchor for this URL
     * @s.tagattribute required="false"
     */
    public void setAnchor(String anchor) {
        this.anchor = anchor;
    }


    /**
     * Merge request parameters into current parameters. If a parameter is
     * already present, than the request parameter in the current request and value atrribute 
     * will not override its value.
     * 
     * The priority is as follows:-
     * <ul>
     * 	<li>parameter from the current request (least priority)</li>
     *  <li>parameter form the value attribute (more priority)</li>
     *  <li>parameter from the param tag (most priority)</li>
     * </ul>
     * 
     * @param value the value attribute (url to be generated by this component)
     * @param parameters component parameters
     * @param contextParameters request parameters
     */
    protected void mergeRequestParameters(String value, Map parameters, Map contextParameters){
    	
    	Map mergedParams = new LinkedHashMap(contextParameters);
    	
    	// Merge contextParameters (from current request) with parameters specified in value attribute
    	// eg. value="someAction.action?id=someId&venue=someVenue" 
    	// where the parameters specified in value attribute takes priority.
    	
    	if (value != null && value.trim().length() > 0 && value.indexOf("?") > 0) {
    		mergedParams = new LinkedHashMap();
    		
    		String queryString = value.substring(value.indexOf("?")+1);
    		
    		mergedParams = UrlHelper.parseQueryString(queryString);
    		for (Iterator iterator = contextParameters.entrySet().iterator(); iterator.hasNext();) {
    			Map.Entry entry = (Map.Entry) iterator.next();
    			Object key = entry.getKey();
    			
    			if (!mergedParams.containsKey(key)) {
    				mergedParams.put(key, entry.getValue());
    			}
    		}
    	}
    	
    	
    	// Merge parameters specified in value attribute 
    	// eg. value="someAction.action?id=someId&venue=someVenue" 
    	// with parameters specified though param tag 
    	// eg. <param name="id" value="%{'someId'}" />
    	// where parameters specified through param tag takes priority.
    	
        for (Iterator iterator = mergedParams.entrySet().iterator(); iterator.hasNext();) {
            Map.Entry entry = (Map.Entry) iterator.next();
            Object key = entry.getKey();
            
            if (!parameters.containsKey(key)) {
                parameters.put(key, entry.getValue());
            }
        }
    }
}
"
core/src/main/java/org/apache/struts2/components/table/AbstractFilterModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components.table;

import java.util.Vector;

import javax.swing.table.AbstractTableModel;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableModel;


/**
 */
abstract public class AbstractFilterModel extends AbstractTableModel {

    protected TableModel model;


    public AbstractFilterModel(TableModel tm) {
        model = tm;
    }


    public boolean isCellEditable(int par1, int par2) {
        return model.isCellEditable(par1, par2);
    }

    public Class getColumnClass(int par1) {
        return model.getColumnClass(par1);
    }

    public int getColumnCount() {
        return model.getColumnCount();
    }

    public String getColumnName(int par1) {
        return model.getColumnName(par1);
    }

    public void setModel(TableModel model) {
        this.model = model;
        this.fireTableDataChanged();
    }

    public TableModel getModel() {
        return model;
    }

    public int getRowCount() {
        return model.getRowCount();
    }

    public void setValueAt(Object par1, int par2, int par3) {
        model.setValueAt(par1, par2, par3);
    }

    public Object getValueAt(int par1, int par2) {
        return model.getValueAt(par1, par2);
    }

    public void addRow(Vector data) throws IllegalStateException {
        if (model instanceof DefaultTableModel) {
            ((DefaultTableModel) model).addRow(data);
        } else if (model instanceof AbstractFilterModel) {
            ((AbstractFilterModel) model).addRow(data);
        } else {
            throw (new IllegalStateException("Error attempting to add a row to an underlying model that is not a DefaultTableModel."));
        }
    }

    public void removeAllRows() throws ArrayIndexOutOfBoundsException, IllegalStateException {
        while (this.getRowCount() > 0) {
            this.removeRow(0);
        }
    }

    public void removeRow(int rowNum) throws ArrayIndexOutOfBoundsException, IllegalStateException {
        if (model instanceof DefaultTableModel) {
            ((DefaultTableModel) model).removeRow(rowNum);
        } else if (model instanceof AbstractFilterModel) {
            ((AbstractFilterModel) model).removeRow(rowNum);
        } else {
            throw (new IllegalStateException("Error attempting to remove a row from an underlying model that is not a DefaultTableModel."));
        }
    }
}
"
core/src/main/java/org/apache/struts2/components/table/RenderFilterModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components.table;

import javax.swing.table.TableModel;


/**
 */
public class RenderFilterModel extends AbstractFilterModel {

	private static final long serialVersionUID = -2501708467650344057L;
	
	private boolean rendered;


    public RenderFilterModel(TableModel tm) {
        super(tm);
    }


    public void setRendered(boolean rendered) {
        this.rendered = rendered;
    }

    public boolean isRendered() {
        return rendered;
    }
}
"
core/src/main/java/org/apache/struts2/components/table/SortableTableModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components.table;

import javax.swing.table.TableModel;


/**
 */
public interface SortableTableModel extends TableModel {

    final static public String NONE = "NONE";
    final static public String ASC = "ASC";
    final static public String DESC = "DESC";


    public int getSortedColumnNumber();

    public String getSortedDirection(int columnNumber);

    public void sort(int columnNumber, String direction);
}
"
core/src/main/java/org/apache/struts2/components/table/SortFilterModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components.table;

import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Collections;

import javax.swing.JTable;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.table.TableModel;


/**
 */
public class SortFilterModel extends AbstractFilterModel implements TableModelListener, SortableTableModel {

	private static final long serialVersionUID = 2214225803442793597L;

	private ArrayList rows = new ArrayList();

    /**
     * These are just here to implement the interface
     */
    private String _sortDirection = NONE;
    private boolean dirty = true;
    private int sortColumn = -1;


    public SortFilterModel(TableModel tm) {
        super(tm);
        setModel(tm);
    }


    public boolean isCellEditable(int r, int c) {
        if ((rows.size() > 0) && (r < rows.size())) {
            return model.isCellEditable(((Row) rows.get(r)).index, c);
        }

        return false;
    }

    public void setModel(TableModel tm) {
        super.setModel(tm);
        rows.ensureCapacity(model.getRowCount());
        model.addTableModelListener(this);
        sortColumn = -1;
        dirty = true;
        refresh();
    }

    public int getSortedColumnNumber() {
        return sortColumn;
    }

    public String getSortedDirection(int columnNumber) {
        if (getSortedColumnNumber() < 0) {
            return NONE;
        }

        return _sortDirection;
    }

    public void setValueAt(Object aValue, int r, int c) {
        if ((rows.size() > 0) && (r < rows.size())) {
            model.setValueAt(aValue, ((Row) rows.get(r)).index, c);
        }
    }

    /* compute the moved row for the three methods that access
       model elements
    */
    public Object getValueAt(int r, int c) {
        if ((rows.size() > 0) && (r < rows.size())) {
            return model.getValueAt(((Row) rows.get(r)).index, c);
        }

        return null;
    }

    public void addMouseListener(final JTable table) {
        table.getTableHeader().addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent event) {
                // check for double click
                if (event.getClickCount() < 2) {
                    return;
                }

                // find column of click and
                int tableColumn = table.columnAtPoint(event.getPoint());

                // translate to table model index and sort
                int modelColumn = table.convertColumnIndexToModel(tableColumn);
                sort(modelColumn);
            }
        });
    }

    public void removeRow(int rowNum) throws ArrayIndexOutOfBoundsException, IllegalStateException {
        int mappedRow = ((Row) rows.get(rowNum)).index;
        super.removeRow(mappedRow);
    }

    public void sort(int columnNumber, String direction) {
        _sortDirection = ASC;
        dirty = true;
        sort(columnNumber);

        if (DESC.equals(direction)) {
            sort(columnNumber);
            _sortDirection = DESC;
        }
    }

    /**
     * Implements the TableModelListener interface to receive
     * notifications of * changes to the table model. SortFilterModel needs
     * to receive events for adding and removing rows.
     */
    public void tableChanged(TableModelEvent e) {
        dirty = true;
        refresh();
        fireTableChanged(e);
    }

    protected void refresh() {
        rows.clear();

        for (int i = 0; i < model.getRowCount(); i++) {
            rows.add(new Row(i));
        }

        if (dirty && (sortColumn > -1)) {
            sort(sortColumn);
        }
    }

    protected void sort(int c) {
        boolean sorted = (sortColumn == c);
        sortColumn = c;

        if (dirty || !sorted) {
            Collections.sort(rows);
            dirty = false;
        } else {
            Collections.reverse(rows);
        }

        fireTableDataChanged();
    }


    /* this inner class holds the index of the model row
     * Rows are compared by looking at the model row entries
     * in the sort column
     */
    private class Row implements Comparable {
        public int index;

        public Row(int index) {
            this.index = index;
        }

        public int compareTo(Object other) {
            Row otherRow = (Row) other;
            Object a = model.getValueAt(index, sortColumn);
            Object b = model.getValueAt(otherRow.index, sortColumn);

            boolean areTheyCompareable = (a instanceof Comparable && b instanceof Comparable && (a.getClass() == b.getClass()));

            if (areTheyCompareable) {
                return ((Comparable) a).compareTo((Comparable) b);
            } else {
                return a.toString().compareTo(b.toString());
            }
        }
    }
}
"
core/src/main/java/org/apache/struts2/components/table/WebTable.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components.table;

import java.io.Writer;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.NoSuchElementException;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.swing.table.TableModel;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.StrutsException;
import org.apache.struts2.components.GenericUIBean;
import org.apache.struts2.components.table.renderer.CellRenderer;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @s.tag name="table" tld-body-content="JSP" tld-tag-class="org.apache.struts2.views.jsp.ui.table.WebTableTag"
 * description="Instantiate a JavaBean and place it in the context."
 */
public class WebTable extends GenericUIBean {
    private static final Log LOG = LogFactory.getLog(WebTable.class);

    final public static String TEMPLATE = "table";

    protected String sortOrder = SortableTableModel.NONE;
    protected String modelName = null;
    protected TableModel model = null;
    protected WebTableColumn[] columns = null;
    protected boolean sortableAttr = false;
    protected int sortColumn = -1;
    protected int curRow = 0;

    public WebTable(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
    }

    protected String getDefaultTemplate() {
        return TEMPLATE;
    }

    public boolean end(Writer writer, String body) {
        if (sortableAttr && model instanceof SortableTableModel) {
            LOG.debug("we are looking for " + getSortColumnLinkName());

            String sortColumn = request.getParameter(getSortColumnLinkName());
            String sortOrder = request.getParameter(getSortOrderLinkName());

            try {
                if ((sortColumn != null) || (sortOrder != null)) {
                    if (sortColumn != null) {
                        try {
                            this.sortColumn = Integer.parseInt(sortColumn);
                        } catch (Exception ex) {
                            if (LOG.isDebugEnabled()) {
                                LOG.debug("coudn't convert column, take default");
                            }
                        }
                    }

                    if (sortOrder != null) {
                        this.sortOrder = sortOrder;
                    }
                } else {
                    LOG.debug("no sorting info in the request");
                }

                if (this.sortColumn >= 0) {
                    LOG.debug("we have the sortColumn " + Integer.toString(this.sortColumn));
                    LOG.debug("we have the sortOrder " + this.sortOrder);

                    try {
                        ((SortableTableModel) model).sort(this.sortColumn, this.sortOrder);
                    } catch (Exception ex) {
                        if (LOG.isDebugEnabled()) {
                            LOG.debug("couldn't sort the data");
                        }
                    }

                    LOG.debug("we just sorted the data");
                }
            } catch (Exception e) {
                throw new StrutsException("Error with WebTable: " + toString(e), e);
            }
        }

        return super.end(writer, body);
    }

    public WebTableColumn getColumn(int index) {
        try {
            return (columns[index]);
        } catch (Exception E) {
            //blank
        }

        return null;
    }

    protected void evaluateExtraParams() {
        if (modelName != null) {
            modelName = findString(modelName);

            Object obj = stack.findValue(this.modelName);

            if (obj instanceof TableModel) {
                setModel((TableModel) obj);
            }
        }

        super.evaluateExtraParams();
    }

    protected int getNumberOfVisibleColumns() {
        int count = 0;

        for (int i = 0; i < columns.length; ++i) {
            if (!columns[i].isHidden()) {
                ++count;
            }
        }

        return count;
    }

    public int getColumnCount() {
        return (columns.length);
    }

    public void setColumnDisplayName(int column, String displayName) {
        columns[column].setDisplayName(displayName);
    }

    public void getColumnDisplayName(int column) {
        columns[column].getDisplayName();
    }

    public void setColumnHidden(int column, boolean hide) {
        columns[column].setHidden(hide);
    }

    public boolean isColumnHidden(int column) {
        return columns[column].isHidden();
    }

    public void setColumnRenderer(int column, CellRenderer renderer) {
        columns[column].setRenderer(renderer);
    }

    public CellRenderer getColumnRenderer(int column) {
        return columns[column].getRenderer();
    }

    public WebTableColumn[] getColumns() {
        return columns;
    }

    public String[] getFormattedRow(int row) {
        ArrayList data = new ArrayList(getNumberOfVisibleColumns());

        for (int i = 0; i < getColumnCount(); ++i) {
            if (columns[i].isVisible()) {
                data.add(columns[i].getRenderer().renderCell(this, model.getValueAt(row, i), row, i));
            }
        }

        return (String[]) data.toArray(new String[0]);
    }

    public void setModel(TableModel model) {
        this.model = model;
        columns = new WebTableColumn[this.model.getColumnCount()];

        for (int i = 0; i < columns.length; ++i) {
            columns[i] = new WebTableColumn(this.model.getColumnName(i), i);
        }

        if ((sortableAttr) && !(this.model instanceof SortableTableModel)) {
            this.model = new SortFilterModel(this.model);
        }
    }

    public TableModel getModel() {
        return (model);
    }

    /**
     * The name of model to use
     * @s.tagattribute required="true" type="String"
     */
    public void setModelName(String modelName) {
        this.modelName = modelName;
    }

    public String getModelName() {
        return modelName;
    }

    public Object getRawData(int row, int column) {
        return model.getValueAt(row, column);
    }

    public Iterator getRawDataRowIterator() {
        return new WebTableRowIterator(this, WebTableRowIterator.RAW_DATA);
    }

    public Object[] getRow(int row) {
        ArrayList data = new ArrayList(getNumberOfVisibleColumns());

        for (int i = 0; i < getColumnCount(); ++i) {
            if (columns[i].isVisible()) {
                data.add(model.getValueAt(row, i));
            }
        }

        return data.toArray(new Object[0]);
    }

    public int getRowCount() {
        return model.getRowCount();
    }

    public Iterator getRowIterator() {
        return new WebTableRowIterator(this);
    }

    /**
     * Index of column to sort data by
     * @s.tagattribute required="false" type="Integer"
     */
    public void setSortColumn(int sortColumn) {
        this.sortColumn = sortColumn;
    }

    public int getSortColumn() {
        if (model instanceof SortableTableModel) {
            return ((SortableTableModel) model).getSortedColumnNumber();
        }

        return -1;
    }

    public String getSortColumnLinkName() {
        return "WEBTABLE_" + modelName + "_SORT_COLUMN";
    }

    /**
     * Set sort order. Allowed values are NONE, ASC and DESC
     * @s.tagattribute required="false" type="String" default="NONE"
     */
    public void setSortOrder(String sortOrder) {
        if (sortOrder.equals(SortableTableModel.NONE)) {
            this.sortOrder = SortableTableModel.NONE;
        } else if (sortOrder.equals(SortableTableModel.DESC)) {
            this.sortOrder = SortableTableModel.DESC;
        } else if (sortOrder.equals(SortableTableModel.ASC)) {
            this.sortOrder = SortableTableModel.ASC;
        } else {
            this.sortOrder = SortableTableModel.NONE;
        }
    }

    public String getSortOrder() {
        if ((model instanceof SortableTableModel) && (getSortColumn() >= 0)) {
            return ((SortableTableModel) model).getSortedDirection(getSortColumn());
        }

        return SortableTableModel.NONE;
    }

    public String getSortOrderLinkName() {
        return "WEBTABLE_" + modelName + "_SORT_ORDER";
    }

    /**
     * Whether the table should be sortable. Requires that model implements org.apache.struts2.components.table.SortableTableModel if set to true.
     * @s.tagattribute required="false" type="Boolean" default="false"
     */
    public void setSortable(boolean sortable) {
        sortableAttr = sortable;

        if ((sortableAttr) && (model != null) && !(model instanceof SortableTableModel)) {
            model = new SortFilterModel(model);
        }
    }

    public boolean isSortable() {
        return sortableAttr;
    }

    /**
     * inner class to iteratoe over a row of the table.
     * It can return formatted data, using the columnRenderer
     * for the column or it can return the raw data.
     */
    public class WebTableRowIterator implements Iterator {
        public static final int FORMATTED_DATA = 0;
        public static final int RAW_DATA = 1;
        protected WebTable _table;
        protected int _curRow = 0;
        protected int _mode = 0;

        protected WebTableRowIterator(WebTable table) {
            this(table, FORMATTED_DATA);
        }

        protected WebTableRowIterator(WebTable table, int mode) {
            _table = table;
            _mode = mode;
        }

        public boolean hasNext() {
            if (_table == null) {
                return false;
            }

            return (_table.getRowCount() > _curRow);
        }

        public Object next() throws NoSuchElementException {
            if (_table == null) {
                throw new NoSuchElementException("WebTable is null");
            }

            if (!hasNext()) {
                throw new NoSuchElementException("Beyond end of WebTable");
            }

            if (_mode == RAW_DATA) {
                return _table.getRow(_curRow++);
            }

            return _table.getFormattedRow(_curRow++);
        }

        public void remove() throws UnsupportedOperationException, IllegalStateException {
            throw new UnsupportedOperationException("Remove not supported in WebTable");
        }
    }
}
"
core/src/main/java/org/apache/struts2/components/table/WebTableColumn.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components.table;

import org.apache.struts2.components.table.renderer.CellRenderer;
import org.apache.struts2.components.table.renderer.DefaultCellRenderer;


/**
 */
public class WebTableColumn {

    static final private CellRenderer DEFAULT_RENDERER = new DefaultCellRenderer();


    CellRenderer _renderer = null;
    String _displayName = null;
    String _name = null;
    boolean _hidden = false;
    int _offset = -1;


    public WebTableColumn(String name, int offset) {
        _name = name;
        _offset = offset;
        _displayName = name;
        _renderer = DEFAULT_RENDERER;
    }


    public void setDisplayName(String displayName) {
        _displayName = displayName;
    }

    public String getDisplayName() {
        return (_displayName);
    }

    public void setHidden(boolean hidden) {
        _hidden = hidden;
    }

    public boolean isHidden() {
        return _hidden;
    }

    public String getName() {
        return (_name);
    }

    public int getOffset() {
        return (_offset);
    }

    public void setRenderer(CellRenderer renderer) {
        _renderer = renderer;
    }

    public CellRenderer getRenderer() {
        return (_renderer);
    }

    public boolean isVisible() {
        return !isHidden();
    }
}
"
core/src/main/java/org/apache/struts2/components/table/renderer/AbstractCellRenderer.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components.table.renderer;

import org.apache.struts2.components.table.WebTable;


/**
 * this is the base class that most renderers will be derived from.
 * It allows setting the alignment.  Subclasses should set there actuall
 * content by implementing getCellValue
 */
abstract public class AbstractCellRenderer implements CellRenderer {

    /**
     * used for horizontal cell alignmnet
     */
    protected String _alignment = null;


    public void setAlignment(String alignment) {
        _alignment = alignment;
    }

    public String getAlignment() {
        return _alignment;
    }

    /**
     * implememnts CellRenderer renderCell.  It sets the alignment.  gets the actual
     * data from getCellValue
     */
    public String renderCell(WebTable table, Object data, int row, int col) {
        if (isAligned()) {
            StringBuffer buf = new StringBuffer(256);
            buf.append("<div align='").append(_alignment).append("'>");
            buf.append(getCellValue(table, data, row, col));
            buf.append("</div>");

            return buf.toString();
        }

        return getCellValue(table, data, row, col);
    }

    protected boolean isAligned() {
        return _alignment != null;
    }

    /**
     * this is the method that subclasses need to implement to set their value.
     * they should not override renderCell unless they want to change the alignmnent
     * renderering
     */
    abstract protected String getCellValue(WebTable table, Object data, int row, int col);
}
"
core/src/main/java/org/apache/struts2/components/table/renderer/BooleanCellRenderer.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components.table.renderer;

import org.apache.struts2.components.table.WebTable;


/**
 */
public class BooleanCellRenderer extends AbstractCellRenderer {

    /**
     * value used if the boolean object is false
     */
    protected String _falseValue = "false";

    /**
     * value used if the boolean object is true
     */
    protected String _trueValue = "true";


    public BooleanCellRenderer() {
        super();
    }


    public String getCellValue(WebTable table, Object data, int row, int col) {
        if (data == null) {
            return "";
        }

        if (data instanceof Boolean) {
            return ((Boolean) data).booleanValue() ? _trueValue : _falseValue;
        }

        return data.toString(); //if here then not a boolean
    }

    public void setFalseValue(String falseValue) {
        _falseValue = falseValue;
    }

    public void setTrueValue(String trueValue) {
        _trueValue = trueValue;
    }
}
"
core/src/main/java/org/apache/struts2/components/table/renderer/CellRenderer.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components.table.renderer;

import org.apache.struts2.components.table.WebTable;

/**
 */
public interface CellRenderer {

    public String renderCell(WebTable table, Object data, int row, int col);
}
"
core/src/main/java/org/apache/struts2/components/table/renderer/DateCellRenderer.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components.table.renderer;

import java.text.SimpleDateFormat;

import org.apache.struts2.components.table.WebTable;


/**
 */
public class DateCellRenderer extends AbstractCellRenderer {

    SimpleDateFormat _formater = new SimpleDateFormat();

    /**
     * this is the string that  SimpleDateFormat needs to display the date
     *
     * @see SimpleDateFormat
     */
    String _formatString = null;


    public DateCellRenderer() {
        super();
    }


    public String getCellValue(WebTable table, Object data, int row, int col) {

        if (data == null) {
            return "";
        }

        if (data instanceof java.util.Date) {
            return _formater.format((java.util.Date) data);
        }

        return data.toString();
    }

    public void setFormatString(String format) {
        _formatString = format;
        _formater.applyPattern(_formatString);
    }
}
"
core/src/main/java/org/apache/struts2/components/table/renderer/DefaultCellRenderer.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components.table.renderer;

import org.apache.struts2.components.table.WebTable;


/**
 */
public class DefaultCellRenderer extends AbstractCellRenderer {

    public DefaultCellRenderer() {
        super();
    }


    public String getCellValue(WebTable table, Object data, int row, int col) {
        if (data != null) {
            return data.toString();
        }

        return "null";
    }
}
"
core/src/main/java/org/apache/struts2/components/table/renderer/FixedTextCellRenderer.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components.table.renderer;

import org.apache.struts2.components.table.WebTable;


/**
 * usefull if a column has an embeded ID number needed for a link but you want it to
 * say something else.
 */
public class FixedTextCellRenderer extends AbstractCellRenderer {

    /**
     * this is the text that will be shown in the column
     */
    protected String _text = "";


    public String getCellValue(WebTable table, Object data, int row, int col) {
        return _text;
    }

    public void setText(String text) {
        _text = text;
    }

    public String getText() {
        return _text;
    }
}
"
core/src/main/java/org/apache/struts2/components/table/renderer/LinkCellRenderer.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components.table.renderer;

import org.apache.struts2.components.table.WebTable;


/**
 */
public class LinkCellRenderer extends AbstractCellRenderer {

    /**
     * this is the actual renderer tha will be used to display the text
     */
    protected CellRenderer _delegateRenderer = new DefaultCellRenderer();

    /**
     * the CSS class this link belongs to. Optional
     */
    protected String _cssClass = null;

    /**
     * the id attribute this link belongs to. Optional
     */
    protected String _cssId = null;

    /**
     * this is the link we are setting (required)
     */
    protected String _link = null;

    /**
     * the (Java)script/ function to execute when the link is clicked. Optional
     */
    protected String _onclick = null;

    /**
     * the (Java)script/ function to execute when the link is clicked twice. Optional
     */
    protected String _ondblclick = null;

    /**
     * the (Java)script/ function to execute when cursor is away from the link. Optional
     */
    protected String _onmouseout = null;

    /**
     * the (Java)script/ function to execute when cursor is over the link. Optional
     */
    protected String _onmouseover = null;

    /**
     * if set there will be a parameter attached to link.  (optional)
     * This should be extended to allow multiple parameters
     */
    protected String _param = null;

    /**
     * directly set the value for the param.  Will overide paramColumn if set.
     * optional.  Either this or paramColumn must be set if param is used.
     * Will be ignored if param not used
     */
    protected String _paramValue = null;

    /**
     * the target frame to open in. Optional
     */
    protected String _target = null;

    /**
     * the title attribute this link belongs to. Optional
     */
    protected String _title = null;

    /**
     * additional parameters after the above parameter is generated. Optional
     */
    protected String _trailParams = null;

    /**
     * if used the param value will be taken from another column in the table.  Useful if each row
     * needs a different paramter.  The paramter can be taken from a hidden cell.
     * if paramValue is also set it will overrid this.  (option either this or paramValue must be set
     * if param is used. Will be ignored if param not used
     */
    protected int _paramColumn = -1;


    public LinkCellRenderer() {
    }


    /**
     * should the link data be encodeed?
     */
    public String getCellValue(WebTable table, Object data, int row, int col) {
        String value = _delegateRenderer.renderCell(table, data, row, col);

        StringBuffer cell = new StringBuffer(256);
        cell.append("<a href='").append(_link);

        if (_param != null) {
            cell.append("?").append(_param).append("=");

            if (_paramValue != null) {
                cell.append(_paramValue);
            } else if (_paramColumn >= 0) {
                cell.append(table.getModel().getValueAt(row, _paramColumn).toString());
            }
        }

        if ((_trailParams != null) && !"".equals(_trailParams)) {
            if (_param == null) {
                cell.append("?");
            } else {
                cell.append("&");
            }

            cell.append(_trailParams);
        }

        cell.append("'");

        if ((_target != null) && (!"".equals(_target))) {
            cell.append(" target='").append(_target).append("'");
        }

        if ((_cssClass != null) && (!"".equals(_cssClass))) {
            cell.append(" class='").append(_cssClass).append("'");
        }

        if ((_cssId != null) && (!"".equals(_cssId))) {
            cell.append(" id='").append(_cssId).append("'");
        }

        if ((_title != null) && (!"".equals(_title))) {
            cell.append(" title='").append(_title).append("'");
        }

        if ((_onclick != null) && (!"".equals(_onclick))) {
            cell.append(" onclick='").append(_onclick).append("'");
        }

        if ((_ondblclick != null) && (!"".equals(_ondblclick))) {
            cell.append(" ondblclick='").append(_ondblclick).append("'");
        }

        if ((_onmouseover != null) && (!"".equals(_onmouseover))) {
            cell.append(" onmouseover='").append(_onmouseover).append("'");
        }

        if ((_onmouseout != null) && (!"".equals(_onmouseout))) {
            cell.append(" onmouseout='").append(_onmouseout).append("'");
        }

        cell.append(">").append(value).append("</a>");

        return cell.toString();
    }

    public void setCssClass(String cssClass) {
        _cssClass = cssClass;
    }

    public void setCssId(String cssId) {
        _cssId = cssId;
    }

    public void setLink(String link) {
        _link = link;
    }

    public void setOnclick(String onclick) {
        _onclick = onclick;
    }

    public void setOndblclick(String ondblclick) {
        _ondblclick = ondblclick;
    }

    public void setOnmouseout(String onmouseout) {
        _onmouseout = onmouseout;
    }

    public void setOnmouseover(String onmouseover) {
        _onmouseover = onmouseover;
    }

    public void setParam(String param) {
        _param = param;
    }

    public void setParamColumn(int paramColumn) {
        _paramColumn = paramColumn;
    }

    public void setParamValue(String paramValue) {
        _paramValue = paramValue;
    }

    /**
     * used to set the renderer to delgate to.
     * if the render is an AbstractCellRenderer then it will take the alignment from
     * the delegate renderer and set it that way.
     */
    public void setRenderer(CellRenderer delegateRenderer) {
        _delegateRenderer = delegateRenderer;

        if (_delegateRenderer instanceof AbstractCellRenderer) {
            setAlignment(((AbstractCellRenderer) _delegateRenderer).getAlignment());
        }
    }

    public void setTarget(String target) {
        _target = target;
    }

    public void setTitle(String title) {
        _title = title;
    }

    public void setTrailParams(String trailParams) {
        _trailParams = trailParams;
    }
}
"
core/src/main/java/org/apache/struts2/components/table/renderer/NumericCellRenderer.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components.table.renderer;

import java.text.DecimalFormat;

import org.apache.struts2.components.table.WebTable;


/**
 */
public class NumericCellRenderer extends AbstractCellRenderer {

    DecimalFormat _formater = new DecimalFormat();

    /**
     * this is the format string that DecimalFormat would use.
     *
     * @see DecimalFormat
     */
    String _formatString = null;

    /**
     * if set the is the color to use if Number is negative.
     */
    String _negativeColor = null;

    /**
     * if set this is the color to render if number is positive
     */
    String _positiveColor = null;


    public NumericCellRenderer() {
        super();
    }


    public String getCellValue(WebTable table, Object data, int row, int col) {
        StringBuffer retVal = new StringBuffer(128);

        if (data == null) {
            return "";
        }

        if (data instanceof Number) {
            double cellValue = ((Number) data).doubleValue();

            if (cellValue >= 0) {
                processNumber(retVal, _positiveColor, cellValue);
            } else {
                processNumber(retVal, _negativeColor, cellValue);
            }

            return retVal.toString();
        }

        return data.toString();
    }

    public void setFormatString(String format) {
        _formatString = format;
        _formater.applyPattern(_formatString);
    }

    public void setNegativeColor(String color) {
        _negativeColor = color;
    }

    public void setPositiveColor(String color) {
        _positiveColor = color;
    }

    protected void processNumber(StringBuffer buf, String color, double cellValue) {
        if (color != null) {
            buf.append(" <font color='").append(color).append("'>");
        }

        buf.append(_formater.format(cellValue));

        if (color != null) {
            buf.append("</font>");
        }
    }
}
"
core/src/main/java/org/apache/struts2/components/template/BaseTemplateEngine.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components.template;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.opensymphony.xwork2.util.ClassLoaderUtil;

/**
 * Base class for template engines.
 */
public abstract class BaseTemplateEngine implements TemplateEngine {
	
    private static final Log LOG = LogFactory.getLog(BaseTemplateEngine.class);
    
    /** The default theme properties file name. Default is 'theme.properties' */
    public static final String DEFAULT_THEME_PROPERTIES_FILE_NAME = "theme.properties";

    final Map<String, Properties> themeProps = new HashMap<String, Properties>();

    public Map getThemeProps(Template template) {
        synchronized (themeProps) {
            Properties props = (Properties) themeProps.get(template.getTheme());
            if (props == null) {
                String propName = template.getDir() + "/" + template.getTheme() + "/"+getThemePropertiesFileName();
                
//              WW-1292
                // let's try getting it from the filesystem
                File propFile = new File(propName);
                InputStream is = null;
                try {
                	if (propFile.exists()) {
                		is = new FileInputStream(propFile);
                	}
                }
                catch(FileNotFoundException e) {
                	LOG.warn("Unable to find file in filesystem ["+propFile.getAbsolutePath()+"]");
                }
                
                if (is == null) {
                	// if its not in filesystem. let's try the classpath
                	is = ClassLoaderUtil.getResourceAsStream(propName, getClass());
                }
                
                props = new Properties();

                if (is != null) {
                    try {
                        props.load(is);
                    } catch (IOException e) {
                        LOG.error("Could not load " + propName, e);
                    }
                }

                themeProps.put(template.getTheme(), props);
            }

            return props;
        }
    }

    protected String getFinalTemplateName(Template template) {
        String t = template.toString();
        if (t.indexOf(".") <= 0) {
            return t + "." + getSuffix();
        }

        return t;
    }
    
    protected String getThemePropertiesFileName() {
    	return DEFAULT_THEME_PROPERTIES_FILE_NAME;
    }

    protected abstract String getSuffix();
}
"
core/src/main/java/org/apache/struts2/components/template/FreemarkerTemplateEngine.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components.template;

import java.io.IOException;
import java.io.Writer;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.ServletActionContext;
import org.apache.struts2.views.freemarker.FreemarkerManager;

import com.opensymphony.xwork2.util.ClassLoaderUtil;
import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.util.OgnlValueStack;

import freemarker.template.Configuration;
import freemarker.template.SimpleHash;

/**
 * Freemarker based template engine.
 */
public class FreemarkerTemplateEngine extends BaseTemplateEngine {
    static Class bodyContent = null;

    static {
        try {
            bodyContent = ClassLoaderUtil.loadClass("javax.servlet.jsp.tagext.BodyContent",
                    FreemarkerTemplateEngine.class);
        } catch (ClassNotFoundException e) {
            // this is OK -- this just means JSP isn't even being used here, which is perfectly fine.
            // we need this class in environments that use JSP to know when to wrap the writer
            // and ignore flush() calls. In JSP, it is illegal for a BodyContent writer to be flushed(),
            // so we have to take caution here.
        }
    }

    private static final Log LOG = LogFactory.getLog(FreemarkerTemplateEngine.class);

    public void renderTemplate(TemplateRenderingContext templateContext) throws Exception {
        // get the various items required from the stack
        OgnlValueStack stack = templateContext.getStack();
        Map context = stack.getContext();
        ServletContext servletContext = (ServletContext) context.get(ServletActionContext.SERVLET_CONTEXT);
        HttpServletRequest req = (HttpServletRequest) context.get(ServletActionContext.HTTP_REQUEST);
        HttpServletResponse res = (HttpServletResponse) context.get(ServletActionContext.HTTP_RESPONSE);

        // prepare freemarker
        FreemarkerManager freemarkerManager = FreemarkerManager.getInstance();
        Configuration config = freemarkerManager.getConfiguration(servletContext);

        // get the list of templates we can use
        List templates = templateContext.getTemplate().getPossibleTemplates(this);

        // find the right template
        freemarker.template.Template template = null;
        String templateName = null;
        Exception exception = null;
        for (Iterator iterator = templates.iterator(); iterator.hasNext();) {
            Template t = (Template) iterator.next();
            templateName = getFinalTemplateName(t);
            try {
                // try to load, and if it works, stop at the first one
                template = config.getTemplate(templateName);
                break;
            } catch (IOException e) {
                if (exception == null) {
                    exception = e;
                }
            }
        }

        if (template == null) {
            LOG.error("Could not load template " + templateContext.getTemplate());
            if (exception != null) {
                throw exception;
            } else {
                return;
            }
        }

        if (LOG.isDebugEnabled()) {
            LOG.debug("Rendering template " + templateName);
        }

        ActionInvocation ai = ActionContext.getContext().getActionInvocation();

        Object action = (ai == null) ? null : ai.getAction();
        SimpleHash model = freemarkerManager.buildTemplateModel(stack, action, servletContext, req, res, config.getObjectWrapper());

        model.put("tag", templateContext.getTag());
        model.put("themeProperties", getThemeProps(templateContext.getTemplate()));

        // the BodyContent JSP writer doesn't like it when FM flushes automatically --
        // so let's just not do it (it will be flushed eventually anyway)
        Writer writer = templateContext.getWriter();
        if (bodyContent != null && bodyContent.isAssignableFrom(writer.getClass())) {
            final Writer wrapped = writer;
            writer = new Writer() {
                public void write(char cbuf[], int off, int len) throws IOException {
                    wrapped.write(cbuf, off, len);
                }

                public void flush() throws IOException {
                    // nothing!
                }

                public void close() throws IOException {
                    wrapped.close();
                }
            };
        }

        try {
            stack.push(templateContext.getTag());
            template.process(model, writer);
        } finally {
            stack.pop();
        }
    }

    protected String getSuffix() {
        return "ftl";
    }
}
"
core/src/main/java/org/apache/struts2/components/template/JspTemplateEngine.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components.template;

import java.util.Iterator;
import java.util.List;

import javax.servlet.http.HttpServletResponse;
import javax.servlet.jsp.PageContext;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.ServletActionContext;
import org.apache.struts2.components.Include;
import org.apache.struts2.components.UIBean;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * JSP based template engine.
 */
public class JspTemplateEngine extends BaseTemplateEngine {
    private static final Log LOG = LogFactory.getLog(JspTemplateEngine.class);

    public void renderTemplate(TemplateRenderingContext templateContext) throws Exception {
        Template template = templateContext.getTemplate();

        if (LOG.isDebugEnabled()) {
            LOG.debug("Trying to render template " + template + ", repeating through parents until we succeed");
        }
        UIBean tag = templateContext.getTag();
        OgnlValueStack stack = templateContext.getStack();
        stack.push(tag);
        PageContext pageContext = (PageContext) stack.getContext().get(ServletActionContext.PAGE_CONTEXT);
        List templates = template.getPossibleTemplates(this);
        Exception exception = null;
        boolean success = false;
        for (Iterator iterator = templates.iterator(); iterator.hasNext();) {
            Template t = (Template) iterator.next();
            try {
                Include.include(getFinalTemplateName(t), pageContext.getOut(),
                        pageContext.getRequest(), (HttpServletResponse) pageContext.getResponse());
                success = true;
                break;
            } catch (Exception e) {
                if (exception == null) {
                    exception = e;
                }
            }
        }

        if (!success) {
            LOG.error("Could not render JSP template " + templateContext.getTemplate());

            if (exception != null) {
                throw exception;
            } else {
                return;
            }
        }

        stack.pop();
    }

    protected String getSuffix() {
        return "jsp";
    }
}
"
core/src/main/java/org/apache/struts2/components/template/Template.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components.template;

import java.util.ArrayList;
import java.util.List;

/**
 * A template.
 * <p/>
 * A template is used as a model for rendering output.
 * This object contains basic common template information
 */
public class Template implements Cloneable {
    String dir;
    String theme;
    String name;

    /**
     * Constructor.
     *
     * @param dir  base folder where the template is stored.
     * @param theme  the theme of the template
     * @param name   the name of the template.
     */
    public Template(String dir, String theme, String name) {
        this.dir = dir;
        this.theme = theme;
        this.name = name;
    }

    public String getDir() {
        return dir;
    }

    public String getTheme() {
        return theme;
    }

    public String getName() {
        return name;
    }

    public List getPossibleTemplates(TemplateEngine engine) {
        List list = new ArrayList(3);
        Template template = this;
        String parentTheme;
        list.add(template);
        while ((parentTheme = (String) engine.getThemeProps(template).get("parent")) != null) {
            try {
                template = (Template) template.clone();
                template.theme = parentTheme;
                list.add(template);
            } catch (CloneNotSupportedException e) {
                // do nothing
            }
        }

        return list;
    }

    /**
     * Constructs a string in the format <code>/dir/theme/name</code>.
     * @return a string in the format <code>/dir/theme/name</code>.
     */
    public String toString() {
        return "/" + dir + "/" + theme + "/" + name;
    }

    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
"
core/src/main/java/org/apache/struts2/components/template/TemplateEngine.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components.template;

import java.util.Map;

/**
 * Any template language which wants to support UI tag templating needs to provide an implementation of this interface
 * to handle rendering the template
 */
public interface TemplateEngine {

    /**
     * Renders the template
     * @param templateContext  context for the given template.
     * @throws Exception is thrown if there is a failure when rendering.
     */
    void renderTemplate(TemplateRenderingContext templateContext) throws Exception;

    /**
     * Get's the properties for the given template.
     *
     * @param template   the template.
     * @return  the properties as key value pairs.
     */
    Map getThemeProps(Template template);
    
}
"
core/src/main/java/org/apache/struts2/components/template/TemplateEngineManager.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components.template;

import java.util.HashMap;
import java.util.Map;

import org.apache.struts2.config.Settings;

/**
 * The TemplateEngineManager will return a template engine for the template
 */
public class TemplateEngineManager {
    public static final String DEFAULT_TEMPLATE_TYPE_CONFIG_KEY = "struts.ui.templateSuffix";

    private static final TemplateEngineManager MANAGER = new TemplateEngineManager();

    /** The default template extenstion is <code>ftl</code>. */
    public static final String DEFAULT_TEMPLATE_TYPE = "ftl";

    Map templateEngines = new HashMap();

    private TemplateEngineManager() {
        templateEngines.put("ftl", new FreemarkerTemplateEngine());
        templateEngines.put("vm", new VelocityTemplateEngine());
        templateEngines.put("jsp", new JspTemplateEngine());
    }

    /**
     * Registers the given template engine.
     * <p/>
     * Will add the engine to the existing list of known engines.
     * @param templateExtension  filename extension (eg. .jsp, .ftl, .vm).
     * @param templateEngine     the engine.
     */
    public static void registerTemplateEngine(String templateExtension, TemplateEngine templateEngine) {
        MANAGER.templateEngines.put(templateExtension, templateEngine);
    }

    /**
     * Gets the TemplateEngine for the template name. If the template name has an extension (for instance foo.jsp), then
     * this extension will be used to look up the appropriate TemplateEngine. If it does not have an extension, it will
     * look for a Configuration setting "struts.ui.templateSuffix" for the extension, and if that is not set, it
     * will fall back to "ftl" as the default.
     *
     * @param template               Template used to determine which TemplateEngine to return
     * @param templateTypeOverride Overrides the default template type
     * @return the engine.
     */
    public static TemplateEngine getTemplateEngine(Template template, String templateTypeOverride) {
        String templateType = DEFAULT_TEMPLATE_TYPE;
        String templateName = template.toString();
        if (templateName.indexOf(".") > 0) {
            templateType = templateName.substring(templateName.indexOf(".") + 1);
        } else if (templateTypeOverride !=null && templateTypeOverride.length() > 0) {
            templateType = templateTypeOverride;
        } else if (Settings.isSet(DEFAULT_TEMPLATE_TYPE_CONFIG_KEY)) {
            templateType = (String) Settings.get(DEFAULT_TEMPLATE_TYPE_CONFIG_KEY);
        }
        return (TemplateEngine) MANAGER.templateEngines.get(templateType);
    }


}
"
core/src/main/java/org/apache/struts2/components/template/TemplateRenderingContext.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components.template;

import java.io.Writer;
import java.util.Map;

import org.apache.struts2.components.UIBean;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * Context used when rendering templates.
 */
public class TemplateRenderingContext {
    Template template;
    OgnlValueStack stack;
    Map parameters;
    UIBean tag;
    Writer writer;

    /**
     * Constructor
     *
     * @param template  the template.
     * @param writer    the writer.
     * @param stack     OGNL value stack.
     * @param params    parameters to this template.
     * @param tag       the tag UI component.
     */
    public TemplateRenderingContext(Template template, Writer writer, OgnlValueStack stack, Map params, UIBean tag) {
        this.template = template;
        this.writer = writer;
        this.stack = stack;
        this.parameters = params;
        this.tag = tag;
    }

    public Template getTemplate() {
        return template;
    }

    public OgnlValueStack getStack() {
        return stack;
    }

    public Map getParameters() {
        return parameters;
    }

    public UIBean getTag() {
        return tag;
    }

    public Writer getWriter() {
        return writer;
    }
}
"
core/src/main/java/org/apache/struts2/components/template/VelocityTemplateEngine.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.components.template;

import java.io.IOException;
import java.io.Writer;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.ServletActionContext;
import org.apache.struts2.views.velocity.VelocityManager;
import org.apache.velocity.app.VelocityEngine;
import org.apache.velocity.context.Context;

/**
 * Velocity based template engine.
 */
public class VelocityTemplateEngine extends BaseTemplateEngine {
    private static final Log LOG = LogFactory.getLog(VelocityTemplateEngine.class);

    public void renderTemplate(TemplateRenderingContext templateContext) throws Exception {
        // get the various items required from the stack
        Map actionContext = templateContext.getStack().getContext();
        ServletContext servletContext = (ServletContext) actionContext.get(ServletActionContext.SERVLET_CONTEXT);
        HttpServletRequest req = (HttpServletRequest) actionContext.get(ServletActionContext.HTTP_REQUEST);
        HttpServletResponse res = (HttpServletResponse) actionContext.get(ServletActionContext.HTTP_RESPONSE);

        // prepare velocity
        VelocityManager velocityManager = VelocityManager.getInstance();
        velocityManager.init(servletContext);
        VelocityEngine velocityEngine = velocityManager.getVelocityEngine();

        // get the list of templates we can use
        List templates = templateContext.getTemplate().getPossibleTemplates(this);

        // find the right template
        org.apache.velocity.Template template = null;
        String templateName = null;
        Exception exception = null;
        for (Iterator iterator = templates.iterator(); iterator.hasNext();) {
            Template t = (Template) iterator.next();
            templateName = getFinalTemplateName(t);
            try {
                // try to load, and if it works, stop at the first one
                template = velocityEngine.getTemplate(templateName);
                break;
            } catch (IOException e) {
                if (exception == null) {
                    exception = e;
                }
            }
        }

        if (template == null) {
            LOG.error("Could not load template " + templateContext.getTemplate());
            if (exception != null) {
                throw exception;
            } else {
                return;
            }
        }

        if (LOG.isDebugEnabled()) {
            LOG.debug("Rendering template " + templateName);
        }

        Context context = velocityManager.createContext(templateContext.getStack(), req, res);

        Writer outputWriter = templateContext.getWriter();
        context.put("tag", templateContext.getTag());
        context.put("parameters", templateContext.getParameters());

        template.merge(context, outputWriter);
    }

    protected String getSuffix() {
        return "vm";
    }
}
"
core/src/main/java/org/apache/struts2/config/DefaultSettings.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.config;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.StringTokenizer;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.StrutsConstants;

import com.opensymphony.xwork2.util.LocalizedTextUtil;


/**
 * Default implementation of Settings - creates and delegates to other settingss by using an internal
 * {@link DelegatingSettings}.
 */
public class DefaultSettings extends Settings {

    protected Log log = LogFactory.getLog(this.getClass());
    Settings config;


    /**
     * Creates a new DefaultSettings object by loading all property files
     * and creating an internal {@link DelegatingSettings} object. All calls to get and set
     * in this class will call that settings object.
     */
    public DefaultSettings() {
        // Create default implementations 
        // Use default properties and struts.properties
        ArrayList<Settings> list = new ArrayList<Settings>();

        try {
            list.add(new PropertiesSettings("struts"));
        } catch (Exception e) {
            log.warn("Could not find or error in struts.properties", e);
        }

        try {
            list.add(new PropertiesSettings("org/apache/struts2/default"));
        } catch (Exception e) {
            log.error("Could not find org/apache/struts2/default.properties", e);
        }

        Settings[] configList = new Settings[list.size()];
        config = new DelegatingSettings((Settings[]) list.toArray(configList));

        // Add list of additional properties settingss
        try {
            StringTokenizer configFiles = new StringTokenizer((String) config.getImpl(StrutsConstants.STRUTS_CUSTOM_PROPERTIES), ",");

            while (configFiles.hasMoreTokens()) {
                String name = configFiles.nextToken();

                try {
                    list.add(new PropertiesSettings(name));
                } catch (Exception e) {
                    log.error("Could not find " + name + ".properties. Skipping");
                }
            }

            configList = new Settings[list.size()];
            config = new DelegatingSettings((Settings[]) list.toArray(configList));
        } catch (IllegalArgumentException e) {
            // thrown when Settings is unable to find a certain property
            // eg. struts.custom.properties in default.properties which is commented
            // out
        }

        // Add additional list of i18n global resource bundles
        try {

            LocalizedTextUtil.addDefaultResourceBundle("org/apache/struts2/struts-messages");
            StringTokenizer bundleFiles = new StringTokenizer((String) config.getImpl(StrutsConstants.STRUTS_CUSTOM_I18N_RESOURCES), ", ");

            while (bundleFiles.hasMoreTokens()) {
                String name = bundleFiles.nextToken();
                try {
                    log.info("Loading global messages from " + name);
                    LocalizedTextUtil.addDefaultResourceBundle(name);
                } catch (Exception e) {
                    log.error("Could not find " + name + ".properties. Skipping");
                }
            }
        } catch (IllegalArgumentException e) {
            // struts.custom.i18n.resources wasn't provided
        }
    }


    /**
     * Sets the given property - delegates to the internal config implementation.
     *
     * @see #set(String, String)
     */
    public void setImpl(String aName, String aValue) throws IllegalArgumentException, UnsupportedOperationException {
        config.setImpl(aName, aValue);
    }

    /**
     * Gets the specified property - delegates to the internal config implementation.
     *
     * @see #get(String)
     */
    public String getImpl(String aName) throws IllegalArgumentException {
        // Delegate
        return config.getImpl(aName);
    }

    /**
     * Determines whether or not a value has been set - delegates to the internal config implementation.
     *
     * @see #isSet(String)
     */
    public boolean isSetImpl(String aName) {
        return config.isSetImpl(aName);
    }

    /**
     * Returns a list of all property names - delegates to the internal config implementation.
     *
     * @see #list()
     */
    public Iterator listImpl() {
        return config.listImpl();
    }
}
"
core/src/main/java/org/apache/struts2/config/DelegatingSettings.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.config;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;


/**
 * A Settings implementation which stores an internal list of settings objects. Each time
 * a config method is called (get, set, list, etc..) this class will go through the list of settingss
 * and call the method until successful.
 *
 */
public class DelegatingSettings extends Settings {

    Settings[] configList;


    /**
     * Creates a new DelegatingSettings object given a list of {@link Settings} implementations.
     *
     * @param aConfigList a list of Settings implementations.
     */
    public DelegatingSettings(Settings[] aConfigList) {
        configList = aConfigList;
    }


    /**
     * Sets the given property - calls setImpl(String, Object) method on config objects in the config
     * list until successful.
     *
     * @see #set(String, String)
     */
    public void setImpl(String name, String value) throws IllegalArgumentException, UnsupportedOperationException {
        // Determine which config to use by using get
        // Delegate to the other settingss
        IllegalArgumentException e = null;

        for (int i = 0; i < configList.length; i++) {
            try {
                configList[i].getImpl(name);

                // Found it, now try setting
                configList[i].setImpl(name, value);

                // Worked, now return
                return;
            } catch (IllegalArgumentException ex) {
                e = ex;

                // Try next config
            }
        }

        throw e;
    }

    /**
     * Gets the specified property - calls getImpl(String) method on config objects in config list
     * until successful.
     *
     * @see #get(String)
     */
    public String getImpl(String name) throws IllegalArgumentException {
        // Delegate to the other settings
        IllegalArgumentException e = null;

        for (int i = 0; i < configList.length; i++) {
            try {
                return configList[i].getImpl(name);
            } catch (IllegalArgumentException ex) {
                e = ex;

                // Try next config
            }
        }

        throw e;
    }

    /**
     * Determines if a paramter has been set - calls the isSetImpl(String) method on each config object
     * in config list. Returns <tt>true</tt> when one of the config implementations returns true. Returns
     * <tt>false</tt> otherwise.
     *
     * @see #isSet(String)
     */
    public boolean isSetImpl(String aName) {
        for (int i = 0; i < configList.length; i++) {
            if (configList[i].isSetImpl(aName)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns a list of all property names - returns a list of all property names in all config
     * objects in config list.
     *
     * @see #list()
     */
    public Iterator listImpl() {
        boolean workedAtAll = false;

        Set<Object> settingList = new HashSet<Object>();
        UnsupportedOperationException e = null;

        for (int i = 0; i < configList.length; i++) {
            try {
                Iterator list = configList[i].listImpl();

                while (list.hasNext()) {
                    settingList.add(list.next());
                }

                workedAtAll = true;
            } catch (UnsupportedOperationException ex) {
                e = ex;

                // Try next config
            }
        }

        if (!workedAtAll) {
            throw (e == null) ? new UnsupportedOperationException() : e;
        } else {
            return settingList.iterator();
        }
    }
}
"
core/src/main/java/org/apache/struts2/config/PropertiesSettings.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.config;

import java.io.IOException;
import java.net.URL;
import java.util.Iterator;
import java.util.Properties;

import org.apache.struts2.StrutsException;


/**
 * A class to handle settings via a properties file.
 */
public class PropertiesSettings extends Settings {

    Properties settings;


    /**
     * Creates a new properties config given the name of a properties file. The name is expected to NOT have
     * the ".properties" file extension.  So when <tt>new PropertiesSettings("foo")</tt> is called
     * this class will look in the classpath for the <tt>foo.properties</tt> file.
     *
     * @param name the name of the properties file, excluding the ".properties" extension.
     */
    public PropertiesSettings(String name) {
        settings = new Properties();

        URL settingsUrl = Thread.currentThread().getContextClassLoader().getResource(name + ".properties");

        if (settingsUrl == null) {
            throw new IllegalStateException(name + ".properties missing");
        }

        // Load settings
        try {
            settings.load(settingsUrl.openStream());
        } catch (IOException e) {
            throw new StrutsException("Could not load " + name + ".properties:" + e, e);
        }
    }


    /**
     * Sets a property in the properties file.
     *
     * @see #set(String, String)
     */
    public void setImpl(String aName, String aValue) {
        settings.setProperty(aName, aValue);
    }

    /**
     * Gets a property from the properties file.
     *
     * @see #get(String)
     */
    public String getImpl(String aName) throws IllegalArgumentException {
        String setting = settings.getProperty(aName);

        if (setting == null) {
            throw new IllegalArgumentException("No such setting:" + aName);
        }

        return setting;
    }

    /**
     * Tests to see if a property exists in the properties file.
     *
     * @see #isSet(String)
     */
    public boolean isSetImpl(String aName) {
        if (settings.get(aName) != null) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Lists all keys in the properties file.
     *
     * @see #list()
     */
    public Iterator listImpl() {
        return settings.keySet().iterator();
    }
}
"
core/src/main/java/org/apache/struts2/config/ServletContextSingleton.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.config;

import javax.servlet.ServletContext;

/**
 * This singleton holds an instance of the web servlet context.
 * <p/>
 * This is needed for running Struts on Weblogic Server 6.1
 * because there is no provision to retrieve the servlet context
 * from the web session object.
 * <p/>
 * This class is created to bet that this singleton can be set by
 * {@link org.apache.struts2.dispatcher.FilterDispatcherCompatWeblogic61}
 * before the servlet context is needed by
 * {@link org.apache.struts2.lifecycle.SessionLifecycleListener}
 * which will use this object to get it.
 *
 */
public class ServletContextSingleton {
    /**
     * The web servlet context.  Holding this is the
     * purpose of this singleton.
     */
    private ServletContext servletContext;

    /**
     * The sole instance of this class.
     */
    private static ServletContextSingleton singleton;

    /**
     * Constructor which cannot be called
     * publicly.
     */
    private ServletContextSingleton() {
    }

    /**
     * Answers the singleton.
     * <p/>
     * At some point, the caller must populate the web servlet
     * context.
     *
     * @return Answers the singleton instance of this class
     */
    public static ServletContextSingleton getInstance() {
        if (singleton == null) {
            singleton = new ServletContextSingleton();
        }
        return singleton;
    }

    /**
     * Gets the servlet context
     * 
     * @return The web servlet context
     */
    public ServletContext getServletContext() {
        return servletContext;
    }

    /**
     * Sets the servlet context
     * 
     * @param context The web servlet context
     */
    public void setServletContext(ServletContext context) {
        servletContext = context;
    }

}
"
core/src/main/java/org/apache/struts2/config/Settings.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.config;

import java.util.Iterator;
import java.util.Locale;
import java.util.StringTokenizer;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.StrutsConstants;

import com.opensymphony.xwork2.ObjectFactory;


/**
 * Handles all Struts config properties. Implementation of this class is pluggable (the
 * default implementation is {@link DefaultSettings}). This gives developers to ability to customize how
 * Struts properties are set and retrieved. As an example, a developer may wish to check a separate property
 * store before delegating to the Struts one. <p>
 * <p/>
 * Key methods: <ul>
 * <p/>
 * <li>{@link #getLocale()}</li>
 * <li>{@link #get(String)}</li>
 * <li>{@link #set(String, String)}</li>
 * <li>{@link #list()}</li></ul>
 * <p/>
 * Key methods for subclassers: <ul>
 * <p/>
 * <li>{@link #getImpl(String)}</li>
 * <li>{@link #setImpl(String, String)}</li>
 * <li>{@link #listImpl()}</li>
 * <li>{@link #isSetImpl(String)}</li></ul>
 */
public class Settings {

    static Settings settingsImpl;
    static Settings defaultImpl;
    static Locale locale; // Cached locale
    private static final Log LOG = LogFactory.getLog(Settings.class);


    /**
     * Sets the current settings implementation. Can only be called once.
     *
     * @param config a Settings implementation
     * @throws IllegalStateException if an error occurs when setting the settings implementation.
     */
    public static void setInstance(Settings config) throws IllegalStateException {
        settingsImpl = config;
        locale = null; // Reset cached locale
    }

    /**
     * Gets the current settings implementation.
     *
     * @return the current settings implementation.
     */
    public static Settings getInstance() {
        return (settingsImpl == null) ? getDefaultInstance() : settingsImpl;
    }

    /**
     * Returns the Struts locale. Keys off the property <tt>struts.locale</tt> which should be set
     * as the Java {@link java.util.Locale#toString() toString()} representation of a Locale object (i.e.,
     * "en", "de_DE", "_GB", "en_US_WIN", "de__POSIX", "fr_MAC", etc). <p>
     * <p/>
     * If no locale is specified then the default VM locale is used ({@link java.util.Locale#getDefault()}).
     *
     * @return the Struts locale if specified or the VM default locale.
     */
    public static Locale getLocale() {
        if (locale == null) {
            try {
                StringTokenizer localeTokens = new StringTokenizer(get(StrutsConstants.STRUTS_LOCALE), "_");
                String lang = null;
                String country = null;

                if (localeTokens.hasMoreTokens()) {
                    lang = localeTokens.nextToken();
                }

                if (localeTokens.hasMoreTokens()) {
                    country = localeTokens.nextToken();
                }

                locale = new Locale(lang, country);
            } catch (Throwable t) {
                // Default
                LOG.warn("Setting locale to the default locale");
                locale = Locale.getDefault();
            }
        }

        return locale;
    }

    /**
     * Determines whether or not a value has been set. Useful for testing for the existance of parameter without
     * throwing an IllegalArgumentException.
     *
     * @param name the name of the property to test.
     * @return <tt>true</tt> if the property exists and has a value, <tt>false</tt> otherwise.
     */
    public static boolean isSet(String name) {
        return getInstance().isSetImpl(name);
    }

    /**
     * Returns a property as an Object. This will throw an <tt>IllegalArgumentException</tt> if an error occurs
     * while retrieveing the property or if the property doesn't exist.
     *
     * @param name the name of the property to get.
     * @return the property as an Object.
     * @throws IllegalArgumentException if an error occurs retrieveing the property or the property does not exist.
     */
    public static String get(String name) throws IllegalArgumentException {
        String val = getInstance().getImpl(name);

        return val;
    }

    /**
     * Returns an Iterator of all properties names.
     *
     * @return an Iterator of all properties names.
     */
    public static Iterator list() {
        return getInstance().listImpl();
    }

    /**
     * Implementation of the {@link #isSet(String)} method.
     *
     * @see #isSet(String)
     */
    public boolean isSetImpl(String name) {
        // this is dumb.. maybe it should just throw an unsupported op like the rest of the *Impl
        // methods in this class.
        return false;
    }

    /**
     * Sets a property. Throws an exception if an error occurs when setting the property or if the
     * Settings implementation does not support setting properties.
     *
     * @param name  the name of the property to set.
     * @param value the property to set.
     * @throws IllegalArgumentException      if an error occurs when setting the property.
     * @throws UnsupportedOperationException if the config implementation does not support setting properties.
     */
    public static void set(String name, String value) throws IllegalArgumentException, UnsupportedOperationException {
        getInstance().setImpl(name, value);
    }

    /**
     * Implementation of the {@link #set(String, String)} method.
     *
     * @see #set(String, String)
     */
    public void setImpl(String name, String value) throws IllegalArgumentException, UnsupportedOperationException {
        throw new UnsupportedOperationException("This settings does not support updating a setting");
    }

    /**
     * Implementation of the {@link #get(String)} method.
     *
     * @see #get(String)
     */
    public String getImpl(String aName) throws IllegalArgumentException {
        return null;
    }

    /**
     * Implementation of the {@link #list()} method.
     *
     * @see #list()
     */
    public Iterator listImpl() {
        throw new UnsupportedOperationException("This settings does not support listing the settings");
    }

    private static Settings getDefaultInstance() {
        if (defaultImpl == null) {
            // Create bootstrap implementation
            defaultImpl = new DefaultSettings();

            // Create default implementation
            try {
                String className = get(StrutsConstants.STRUTS_CONFIGURATION);

                if (!className.equals(defaultImpl.getClass().getName())) {
                    try {
                        // singleton instances shouldn't be built accessing request or session-specific context data
                        defaultImpl = (Settings) ObjectFactory.getObjectFactory().buildBean(Thread.currentThread().getContextClassLoader().loadClass(className), null);
                    } catch (Exception e) {
                        LOG.error("Could not instantiate settings", e);
                    }
                }
            } catch (IllegalArgumentException ex) {
                // ignore
            }
        }

        return defaultImpl;
    }

    public static void reset() {
        defaultImpl = null;
        settingsImpl = null;
    }
}
"
core/src/main/java/org/apache/struts2/config/StrutsXMLConfigurationProvider.java,false,"/*
 * Created on Aug 12, 2004 by mgreer
 */
package org.apache.struts2.config;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.StrutsException;

import com.opensymphony.xwork2.config.providers.XmlConfigurationProvider;

/**
 * Override Xwork class so we can use an arbitrary config file
 */
public class StrutsXMLConfigurationProvider extends XmlConfigurationProvider {

    private static final Log LOG = LogFactory.getLog(StrutsXMLConfigurationProvider.class);
    private File baseDir = null;

    /** 
     * Constructs the configuration provider
     * 
     * @param errorIfMissing If we should throw an exception if the file can't be found
     */
    public StrutsXMLConfigurationProvider(boolean errorIfMissing) {
        this("struts.xml", errorIfMissing);
    }
    
    /** 
     * Constructs the configuration provider
     * 
     * @param filename The filename to look for
     * @param errorIfMissing If we should throw an exception if the file can't be found
     */
    public StrutsXMLConfigurationProvider(String filename, boolean errorIfMissing) {
        super(filename, errorIfMissing);
        
        Map<String,String> dtdMappings = new HashMap<String,String>(getDtdMappings());
        dtdMappings.put("-//Apache Software Foundation//DTD Struts Configuration 2.0//EN", "struts-2.0.dtd");
        setDtdMappings(dtdMappings);
        File file = new File(filename);
        if (file.getParent() != null) {
            this.baseDir = file.getParentFile();
        }
    }

    /**
     * Look for the configuration file on the classpath and in the file system
     *
     * @param fileName The file name to retrieve
     * @see com.opensymphony.xwork2.config.providers.XmlConfigurationProvider#getInputStream(java.lang.String)
     */
    @Override
    protected Iterator<URL> getConfigurationUrls(String fileName) throws IOException {
        URL url = null;
        if (baseDir != null) {
            url = findInFileSystem(fileName);
            if (url == null) {
                return super.getConfigurationUrls(fileName);
            }
        } 
        if (url != null) {
            List<URL> list = new ArrayList<URL>();
            list.add(url);
            return list.iterator();
        } else {
            return super.getConfigurationUrls(fileName);
        }
    }
    
    protected URL findInFileSystem(String fileName) throws IOException {
        URL url = null;
        File file = new File(fileName);
        if (LOG.isDebugEnabled()) {
            LOG.debug("Trying to load file " + file);
        }
        
        // Trying relative path to original file
        if (!file.exists()) {
            file = new File(baseDir, fileName);
        }
        if (file.exists()) {
            try {
                url = file.toURL();
            } catch (MalformedURLException e) {
                throw new IOException("Unable to convert "+file+" to a URL");
            }
        } 
        return url;
    }
}
"
core/src/main/java/org/apache/struts2/config_browser/ActionNamesAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.config_browser;

import java.util.Set;
import java.util.TreeSet;

import org.apache.struts2.StrutsConstants;
import org.apache.struts2.config.Settings;

import com.opensymphony.xwork2.ActionSupport;
import com.opensymphony.xwork2.config.entities.ActionConfig;

/**
 * ActionNamesAction
 *
 */
public class ActionNamesAction extends ActionSupport {
	
	private static final long serialVersionUID = -5389385242431387840L;
	
	private Set actionNames;
    private String namespace = "";
    private Set namespaces;
    private String extension;

    public Set getActionNames() {
        return actionNames;
    }

    public String getNamespace() {
        return namespace;
    }

    public void setNamespace(String namespace) {
        this.namespace = namespace;
    }

    public ActionConfig getConfig(String actionName) {
        return ConfigurationHelper.getActionConfig(namespace, actionName);
    }

    public Set getNamespaces() {
        return namespaces;
    }

    public String getExtension() {
        if ( extension == null) {
            String ext = (String) Settings.get(StrutsConstants.STRUTS_ACTION_EXTENSION);
            if ( ext == null || ext.equals("")) {
                extension = "action";
            } else {
                extension = ext;
            }
        }
        return extension;
    }

    public String execute() throws Exception {
        namespaces = ConfigurationHelper.getNamespaces();
        if (namespaces.size() == 0) {
            addActionError("There are no namespaces in this configuration");
            return ERROR;
        }
        if (namespace == null) {
            namespace = "";
        }
        actionNames =
                new TreeSet(ConfigurationHelper.getActionNames(namespace));
        return SUCCESS;
    }
}
"
core/src/main/java/org/apache/struts2/config_browser/ConfigurationHelper.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.config_browser;

import java.util.Collections;
import java.util.Map;
import java.util.Set;

import org.apache.struts2.dispatcher.Dispatcher;

import com.opensymphony.xwork2.config.entities.ActionConfig;

/**
 * ConfigurationHelper
 */
public class ConfigurationHelper {

    public static Set getNamespaces() {
        Set namespaces = Collections.EMPTY_SET;
        Map allActionConfigs = Dispatcher.getInstance().getConfigurationManager().getConfiguration().getRuntimeConfiguration().getActionConfigs();
        if (allActionConfigs != null) {
            namespaces = allActionConfigs.keySet();
        }
        return namespaces;
    }

    public static Set getActionNames(String namespace) {
        Set actionNames = Collections.EMPTY_SET;
        Map allActionConfigs = Dispatcher.getInstance().getConfigurationManager().getConfiguration().getRuntimeConfiguration().getActionConfigs();
        if (allActionConfigs != null) {
            Map actionMappings = (Map) allActionConfigs.get(namespace);
            if (actionMappings != null) {
                actionNames = actionMappings.keySet();
            }
        }
        return actionNames;
    }

    public static ActionConfig getActionConfig(String namespace, String actionName) {
        ActionConfig config = null;
        Map allActionConfigs = Dispatcher.getInstance().getConfigurationManager().getConfiguration().getRuntimeConfiguration().getActionConfigs();
        if (allActionConfigs != null) {
            Map actionMappings = (Map) allActionConfigs.get(namespace);
            if (actionMappings != null) {
                config = (ActionConfig) actionMappings.get(actionName);
            }
        }
        return config;
    }
}
"
core/src/main/java/org/apache/struts2/config_browser/ListValidatorsAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.config_browser;

import java.util.Collections;
import java.util.List;

import org.apache.struts2.util.ClassLoaderUtils;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionSupport;
import com.opensymphony.xwork2.validator.ActionValidatorManagerFactory;

/**
 * ListValidatorsAction loads the validations for a given class and context
 *
 */
public class ListValidatorsAction extends ActionSupport {
	
	private static final long serialVersionUID = 1L;
	
	private String clazz;
    private String context;
    List validators = Collections.EMPTY_LIST;

    public String getClazz() {
        return clazz;
    }

    public void setClazz(String clazz) {
        this.clazz = clazz;
    }

    public String stripPackage(Class clazz) {
        return clazz.getName().substring(clazz.getName().lastIndexOf('.') + 1);
    }

    public String stripPackage(String clazz) {
        return clazz.substring(clazz.lastIndexOf('.') + 1);
    }

    public String getContext() {
        return context;
    }

    public void setContext(String context) {
        this.context = context;
    }

    public List getValidators() {
        return validators;
    }

    public String execute() throws Exception {
        loadValidators();
        return super.execute();
    }

    protected void loadValidators() {
        Class value = getClassInstance();
        if ( value != null ) {
            validators = ActionValidatorManagerFactory.getInstance().getValidators(value, context);
        }
    }

    private Class getClassInstance() {
        try {
            return ClassLoaderUtils.loadClass(clazz, ActionContext.getContext().getClass());
        } catch (Exception e) {
            LOG.error("Class '" + clazz + "' not found...",e);
        }
        return null;
    }
}
"
core/src/main/java/org/apache/struts2/config_browser/ShowConfigAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.config_browser;

import java.beans.PropertyDescriptor;
import java.util.Set;
import java.util.TreeSet;

import ognl.OgnlRuntime;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.opensymphony.xwork2.ObjectFactory;
import com.opensymphony.xwork2.config.entities.ActionConfig;

/**
 * ShowConfigAction
 */
public class ShowConfigAction extends ActionNamesAction {
	
	private static final long serialVersionUID = -1630527489407671652L;

	private static final PropertyDescriptor[] PDSAT = new PropertyDescriptor[0];

    private String namespace;
    private String actionName;
    private ActionConfig config;
    private Set actionNames;
    private String detailView = "results";
    private PropertyDescriptor[] properties;
    private static Log log = LogFactory.getLog(ShowConfigAction.class);

    public String getDetailView() {
        return detailView;
    }

    public void setDetailView(String detailView) {
        this.detailView = detailView;
    }

    public Set getActionNames() {
        return actionNames;
    }

    public String getNamespace() {
        return namespace;
    }

    public String stripPackage(Class clazz) {
        return clazz.getName().substring(clazz.getName().lastIndexOf('.') + 1);
    }

    public void setNamespace(String namespace) {
        this.namespace = namespace;
    }

    public String getActionName() {
        return actionName;
    }

    public void setActionName(String actionName) {
        this.actionName = actionName;
    }

    public ActionConfig getConfig() {
        return config;
    }

    public PropertyDescriptor[] getProperties() {
        return properties;
    }

    public String execute() throws Exception {
        super.execute();
        config = ConfigurationHelper.getActionConfig(namespace, actionName);
        actionNames =
                new TreeSet(ConfigurationHelper.getActionNames(namespace));
        try {
            Class clazz = ObjectFactory.getObjectFactory().getClassInstance(getConfig().getClassName());
            java.util.Collection pds = OgnlRuntime.getPropertyDescriptors(clazz).values();
            properties = (PropertyDescriptor[]) pds.toArray(PDSAT);
        } catch (Exception e) {
            log.error("Unable to get properties for action " + actionName, e);
            addActionError("Unable to retrieve action properties: " + e.toString());
        }

        if (hasErrors()) //super might have set some :)
            return ERROR;
        else
            return SUCCESS;
    }
}

"
core/src/main/java/org/apache/struts2/config_browser/ShowValidatorAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.config_browser;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.util.Collections;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import ognl.Ognl;
import ognl.OgnlException;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.opensymphony.xwork2.util.OgnlUtil;
import com.opensymphony.xwork2.validator.Validator;

/**
 * ShowValidatorAction
 *
 */
public class ShowValidatorAction extends ListValidatorsAction {
    private static final long serialVersionUID = 4061534149317835177L;

    private static Log log = LogFactory.getLog(ShowValidatorAction.class);

    Set properties = Collections.EMPTY_SET;
    int selected = 0;

    public int getSelected() {
        return selected;
    }

    public void setSelected(int selected) {
        this.selected = selected;
    }

    public Set getProperties() {
        return properties;
    }

    public Validator getSelectedValidator() {
        return (Validator) validators.get(selected);
    }

    public String execute() throws Exception {
        loadValidators();
        Validator validator = getSelectedValidator();
        properties = new TreeSet();
        try {
            Map context = Ognl.createDefaultContext(validator);
            BeanInfo beanInfoFrom = null;
            try {
                beanInfoFrom = Introspector.getBeanInfo(validator.getClass(), Object.class);
            } catch (IntrospectionException e) {
                log.error("An error occurred", e);
                addActionError("An error occurred while introspecting a validator of type " + validator.getClass().getName());
                return ERROR;
            }

            PropertyDescriptor[] pds = beanInfoFrom.getPropertyDescriptors();

            for (int i = 0; i < pds.length; i++) {
                PropertyDescriptor pd = pds[i];
                String name = pd.getName();
                Object value = null;
                if (pd.getReadMethod() == null) {
                    value = "No read method for property";
                } else {
                    try {
                        Object expr = OgnlUtil.compile(name);
                        value = Ognl.getValue(expr, context, validator);
                    } catch (OgnlException e) {
                        addActionError("Caught OGNL exception while getting property value for '" + name + "' on validator of type " + validator.getClass().getName());
                    }
                }
                properties.add(new PropertyInfo(name, pd.getPropertyType(), value));
            }
        } catch (Exception e) {
            log.warn("Unable to retrieve properties.", e);
            addActionError("Unable to retrieve properties: " + e.toString());
        }

        if (hasErrors())
            return ERROR;
        else
            return SUCCESS;
    }

    public static class PropertyInfo implements Comparable {
        private String name;
        private Class type;
        private Object value;

        public PropertyInfo(String name, Class type, Object value) {
            if (name == null) {
                throw new IllegalArgumentException("Name must not be null");
            }
            if (type == null) {
                throw new IllegalArgumentException("Type must not be null");
            }
            this.name = name;
            this.type = type;
            this.value = value;
        }

        public Class getType() {
            return type;
        }

        public void setType(Class type) {
            this.type = type;
        }

        public Object getValue() {
            return value;
        }

        public void setValue(Object value) {
            this.value = value;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof PropertyInfo)) return false;

            final PropertyInfo propertyInfo = (PropertyInfo) o;

            if (!name.equals(propertyInfo.name)) return false;
            if (!type.equals(propertyInfo.type)) return false;
            if (value != null ? !value.equals(propertyInfo.value) : propertyInfo.value != null) return false;

            return true;
        }

        public int hashCode() {
            int result;
            result = name.hashCode();
            result = 29 * result + type.hashCode();
            result = 29 * result + (value != null ? value.hashCode() : 0);
            return result;
        }

        public int compareTo(Object o) {
            PropertyInfo other = (PropertyInfo) o;
            return this.name.compareTo(other.name);
        }
    }
}
"
core/src/main/java/org/apache/struts2/dispatcher/ActionContextCleanUp.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher;

import java.io.IOException;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.opensymphony.xwork2.ActionContext;

/**
 * <!-- SNIPPET START: description -->
 * Special filter designed to work with the {@link FilterDispatcher} and allow
 * for easier integration with SiteMesh. Normally, ordering your filters to have
 * SiteMesh go first, and then {@link FilterDispatcher} go second is perfectly fine.
 * However, sometimes you may wish to access Struts features, including the
 * value stack, from within your SiteMesh decorators. Because {@link FilterDispatcher}
 * cleans up the {@link ActionContext}, your decorator won't have access to the
 * date you want.
 * <p/>
 * <p/>
 * By adding this filter, the {@link FilterDispatcher} will know to not clean up and
 * instead defer cleanup to this filter. The ordering of the filters should then be:
 * <p/>
 * <ul>
 * <li>this filter</li>
 * <li>SiteMesh filter</li>
 * <li>{@link FilterDispatcher}</li>
 * </ul>
 * <!-- SNIPPET END: description -->
 *
 * @see FilterDispatcher
 */
public class ActionContextCleanUp implements Filter {

    private static final Log LOG = LogFactory.getLog(ActionContextCleanUp.class);

    private static final String COUNTER = "__cleanup_recursion_counter";

    protected FilterConfig filterConfig;
    protected Dispatcher dispatcher;

    /**
     * Initializes the filter
     * 
     * @param filterConfig The filter configuration
     */
    public void init(FilterConfig filterConfig) throws ServletException {
        this.filterConfig = filterConfig;
        dispatcher = new Dispatcher(filterConfig.getServletContext());
    }

    
    /* (non-Javadoc)
     * @see javax.servlet.Filter#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain)
     */
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;

        // prepare the request no matter what - this ensures that the proper character encoding
        // is used before invoking the mapper (see WW-9127)
        Dispatcher.setInstance(dispatcher);
        dispatcher.prepare(request, response);

        ServletContext servletContext = filterConfig.getServletContext();
        try {
            request = dispatcher.wrapRequest(request, servletContext);
        } catch (IOException e) {
            String message = "Could not wrap servlet request with MultipartRequestWrapper!";
            LOG.error(message, e);
            throw new ServletException(message, e);
        }

        try {
            Integer count = (Integer)request.getAttribute(COUNTER);
            if (count == null) {
                count = new Integer(1);
            }
            else {
                count = new Integer(count.intValue()+1);
            }
            request.setAttribute(COUNTER, count);
            chain.doFilter(request, response);
        } finally {
            int counterVal = ((Integer)request.getAttribute(COUNTER)).intValue();
            counterVal -= 1;
            request.setAttribute(COUNTER, new Integer(counterVal));
            cleanUp(request);
        }
    }

    /**
     * Clean up the request of threadlocals if this is the last execution
     * 
     * @param req The servlet request
     */
    protected static void cleanUp(ServletRequest req) {
        // should we clean up yet?
        if (req.getAttribute(COUNTER) != null &&
                 ((Integer)req.getAttribute(COUNTER)).intValue() > 0 ) {
             return;
         }

        // always dontClean up the thread request, even if an action hasn't been executed
        ActionContext.setContext(null);
        
        Dispatcher.setInstance(null);
    }

    
    /* (non-Javadoc)
     * @see javax.servlet.Filter#destroy()
     */
    public void destroy() {
    }
}
"
core/src/main/java/org/apache/struts2/dispatcher/ApplicationMap.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher;

import java.io.Serializable;
import java.util.AbstractMap;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import javax.servlet.ServletContext;


/**
 * A simple implementation of the {@link java.util.Map} interface to handle a collection of attributes and
 * init parameters in a {@link javax.servlet.ServletContext} object. The {@link #entrySet()} method
 * enumerates over all servlet context attributes and init parameters and returns a collection of both.
 * Note, this will occur lazily - only when the entry set is asked for.
 *
 */
public class ApplicationMap extends AbstractMap implements Serializable {

	private static final long serialVersionUID = 9136809763083228202L;
	
	private ServletContext context;
    private Set<Object> entries;


    /**
     * Creates a new map object given the servlet context.
     *
     * @param ctx the servlet context
     */
    public ApplicationMap(ServletContext ctx) {
        this.context = ctx;
    }


    /**
     * Removes all entries from the Map and removes all attributes from the servlet context.
     */
    public void clear() {
        entries = null;

        Enumeration e = context.getAttributeNames();

        while (e.hasMoreElements()) {
            context.removeAttribute(e.nextElement().toString());
        }
    }

    /**
     * Creates a Set of all servlet context attributes as well as context init parameters.
     *
     * @return a Set of all servlet context attributes as well as context init parameters.
     */
    public Set entrySet() {
        if (entries == null) {
            entries = new HashSet<Object>();

            // Add servlet context attributes
            Enumeration enumeration = context.getAttributeNames();

            while (enumeration.hasMoreElements()) {
                final String key = enumeration.nextElement().toString();
                final Object value = context.getAttribute(key);
                entries.add(new Map.Entry() {
                    public boolean equals(Object obj) {
                        Map.Entry entry = (Map.Entry) obj;

                        return ((key == null) ? (entry.getKey() == null) : key.equals(entry.getKey())) && ((value == null) ? (entry.getValue() == null) : value.equals(entry.getValue()));
                    }

                    public int hashCode() {
                        return ((key == null) ? 0 : key.hashCode()) ^ ((value == null) ? 0 : value.hashCode());
                    }

                    public Object getKey() {
                        return key;
                    }

                    public Object getValue() {
                        return value;
                    }

                    public Object setValue(Object obj) {
                        context.setAttribute(key.toString(), obj);

                        return value;
                    }
                });
            }

            // Add servlet context init params
            enumeration = context.getInitParameterNames();

            while (enumeration.hasMoreElements()) {
                final String key = enumeration.nextElement().toString();
                final Object value = context.getInitParameter(key);
                entries.add(new Map.Entry() {
                    public boolean equals(Object obj) {
                        Map.Entry entry = (Map.Entry) obj;

                        return ((key == null) ? (entry.getKey() == null) : key.equals(entry.getKey())) && ((value == null) ? (entry.getValue() == null) : value.equals(entry.getValue()));
                    }

                    public int hashCode() {
                        return ((key == null) ? 0 : key.hashCode()) ^ ((value == null) ? 0 : value.hashCode());
                    }

                    public Object getKey() {
                        return key;
                    }

                    public Object getValue() {
                        return value;
                    }

                    public Object setValue(Object obj) {
                        context.setAttribute(key.toString(), obj);

                        return value;
                    }
                });
            }
        }

        return entries;
    }

    /**
     * Returns the servlet context attribute or init parameter based on the given key. If the
     * entry is not found, <tt>null</tt> is returned.
     *
     * @param key the entry key.
     * @return the servlet context attribute or init parameter or <tt>null</tt> if the entry is not found.
     */
    public Object get(Object key) {
        // Try context attributes first, then init params
        // This gives the proper shadowing effects
        String keyString = key.toString();
        Object value = context.getAttribute(keyString);

        return (value == null) ? context.getInitParameter(keyString) : value;
    }

    /**
     * Sets a servlet context attribute given a attribute name and value.
     *
     * @param key   the name of the attribute.
     * @param value the value to set.
     * @return the attribute that was just set.
     */
    public Object put(Object key, Object value) {
        entries = null;
        context.setAttribute(key.toString(), value);

        return get(key);
    }

    /**
     * Removes the specified servlet context attribute.
     *
     * @param key the attribute to remove.
     * @return the entry that was just removed.
     */
    public Object remove(Object key) {
        entries = null;

        Object value = get(key);
        context.removeAttribute(key.toString());

        return value;
    }
}
"
core/src/main/java/org/apache/struts2/dispatcher/DefaultActionSupport.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher;


import javax.servlet.http.HttpServletRequest;

import org.apache.struts2.ServletActionContext;

import com.opensymphony.xwork2.ActionSupport;

/**
 * A simple action support class that sets properties to be able to serve 
 */
public class DefaultActionSupport extends ActionSupport {

	private static final long serialVersionUID = -2426166391283746095L;
	
	private String successResultValue;
	
	
	/**
	 * Constructor 
	 */
	public DefaultActionSupport() {
		super();
	}

	/* (non-Javadoc)
	 * @see com.opensymphony.xwork2.ActionSupport#execute()
	 */
	public String execute() throws Exception {
		HttpServletRequest request = ServletActionContext.getRequest();
		String requestedUrl = request.getPathInfo();
		if (successResultValue == null) successResultValue = requestedUrl;
		return SUCCESS;
	}

	/**
	 * @return Returns the successResultValue.
	 */
	public String getSuccessResultValue() {
		return successResultValue;
	}

	/**
	 * @param successResultValue The successResultValue to set.
	 */
	public void setSuccessResultValue(String successResultValue) {
		this.successResultValue = successResultValue;
	}
	

}
"
core/src/main/java/org/apache/struts2/dispatcher/Dispatcher.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.ServletActionContext;
import org.apache.struts2.StrutsConstants;
import org.apache.struts2.StrutsStatics;
import org.apache.struts2.config.Settings;
import org.apache.struts2.config.StrutsXMLConfigurationProvider;
import org.apache.struts2.dispatcher.mapper.ActionMapping;
import org.apache.struts2.dispatcher.multipart.MultiPartRequest;
import org.apache.struts2.dispatcher.multipart.MultiPartRequestWrapper;
import org.apache.struts2.impl.StrutsActionProxyFactory;
import org.apache.struts2.impl.StrutsObjectFactory;
import org.apache.struts2.util.AttributeMap;
import org.apache.struts2.util.ObjectFactoryDestroyable;
import org.apache.struts2.util.ObjectFactoryInitializable;
import org.apache.struts2.views.freemarker.FreemarkerManager;

import com.opensymphony.xwork2.util.ClassLoaderUtil;
import com.opensymphony.xwork2.util.FileManager;
import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionProxy;
import com.opensymphony.xwork2.ActionProxyFactory;
import com.opensymphony.xwork2.ObjectFactory;
import com.opensymphony.xwork2.Result;
import com.opensymphony.xwork2.config.ConfigurationException;
import com.opensymphony.xwork2.config.ConfigurationManager;
import com.opensymphony.xwork2.config.providers.XmlConfigurationProvider;
import com.opensymphony.xwork2.util.LocalizedTextUtil;
import com.opensymphony.xwork2.util.ObjectTypeDeterminer;
import com.opensymphony.xwork2.util.ObjectTypeDeterminerFactory;
import com.opensymphony.xwork2.util.OgnlValueStack;
import com.opensymphony.xwork2.util.XWorkContinuationConfig;
import com.opensymphony.xwork2.util.location.Location;
import com.opensymphony.xwork2.util.location.LocationUtils;

import freemarker.template.Template;

/**
 * A utility class the actual dispatcher delegates most of its tasks to. Each instance
 * of the primary dispatcher holds an instance of this dispatcher to be shared for
 * all requests.
 *
 * @see org.apache.struts2.dispatcher.FilterDispatcher
 * @see org.apache.struts2.portlet.dispatcher.Jsr168Dispatcher
 */
public class Dispatcher {

    // Set Struts-specific factories.
    static {
        ObjectFactory.setObjectFactory(new StrutsObjectFactory());
        ActionProxyFactory.setFactory(new StrutsActionProxyFactory());
    }

    private static final Log LOG = LogFactory.getLog(Dispatcher.class);

    private static ThreadLocal<Dispatcher> instance = new ThreadLocal<Dispatcher>();
    private static List<DispatcherListener> dispatcherListeners = 
        new ArrayList<DispatcherListener>();
    
    private ConfigurationManager configurationManager;
    private static boolean portletSupportActive;
    private boolean devMode = false;

    // used to get WebLogic to play nice
    private boolean paramsWorkaroundEnabled = false;

    /**
     * Gets the current instance for this thread
     * 
     * @return The dispatcher instance
     */
    public static Dispatcher getInstance() {
        return (Dispatcher) instance.get();
    }

    /** 
     * Sets the dispatcher instance for this thread
     * 
     * @param instance The instance
     */
    public static void setInstance(Dispatcher instance) {
        Dispatcher.instance.set(instance);
    }
    
    /**
     * Adds a dispatcher lifecycle listener
     * 
     * @param l The listener
     */
    public static synchronized void addDispatcherListener(DispatcherListener l) {
        dispatcherListeners.add(l);
    }
    
    /** 
     * Removes a dispatcher lifecycle listener
     * 
     * @param l The listener
     */
    public static synchronized void removeDispatcherListener(DispatcherListener l) {
        dispatcherListeners.remove(l);
    }

    /**
     * The constructor with its servlet context instance (optional)
     * 
     * @param servletContext The servlet context
     */
    public Dispatcher(ServletContext servletContext) {
        init(servletContext);
    }

    /** 
     * Cleans up thread local variables
     */
    public void cleanup() {
        ObjectFactory objectFactory = ObjectFactory.getObjectFactory();
        if (objectFactory == null) {
            LOG.warn("Object Factory is null, something is seriously wrong, no clean up will be performed");
        }
        if (objectFactory instanceof ObjectFactoryDestroyable) {
            try {
                ((ObjectFactoryDestroyable)objectFactory).destroy();
            }
            catch(Exception e) {
                // catch any exception that may occured during destroy() and log it
                LOG.error("exception occurred while destroying ObjectFactory ["+objectFactory+"]", e);
            }
        }
        instance.set(null);
        synchronized(Dispatcher.class) {
            if (dispatcherListeners.size() > 0) {
                for (DispatcherListener l : dispatcherListeners) {
                    l.dispatcherDestroyed(this);
                }
            }
        }
    }

    /**
     * Initializes the instance
     * 
     * @param servletContext The servlet context
     */
    private void init(ServletContext servletContext) {
        boolean reloadi18n = Boolean.valueOf((String) Settings.get(StrutsConstants.STRUTS_I18N_RELOAD)).booleanValue();
        LocalizedTextUtil.setReloadBundles(reloadi18n);

        if (Settings.isSet(StrutsConstants.STRUTS_OBJECTFACTORY)) {
            String className = (String) Settings.get(StrutsConstants.STRUTS_OBJECTFACTORY);
            if (className.equals("spring")) {
                // note: this class name needs to be in string form so we don't put hard
                //       dependencies on spring, since it isn't technically required.
                className = "org.apache.struts2.spring.StrutsSpringObjectFactory";
            } else if (className.equals("plexus")) {
                // note: this class name needs to be in string form so we don't put hard
                //       dependencies on spring, since it isn't technically required.
                className = "org.apache.struts2.plexus.PlexusObjectFactory";
            }

            try {
                Class clazz = ClassLoaderUtil.loadClass(className, Dispatcher.class);
                ObjectFactory objectFactory = (ObjectFactory) clazz.newInstance();
                if (servletContext != null) {
                    if (objectFactory instanceof ObjectFactoryInitializable) {
                        ((ObjectFactoryInitializable) objectFactory).init(servletContext);
                    }
                }
                ObjectFactory.setObjectFactory(objectFactory);
            } catch (Exception e) {
                LOG.error("Could not load ObjectFactory named " + className + ". Using default ObjectFactory.", e);
            }
        }

        if (Settings.isSet(StrutsConstants.STRUTS_OBJECTTYPEDETERMINER)) {
            String className = (String) Settings.get(StrutsConstants.STRUTS_OBJECTTYPEDETERMINER);
            if (className.equals("tiger")) {
                // note: this class name needs to be in string form so we don't put hard
                //       dependencies on xwork-tiger, since it isn't technically required.
                className = "com.opensymphony.xwork2.util.GenericsObjectTypeDeterminer";
            }
            else if (className.equals("notiger")) {
                className = "com.opensymphony.xwork2.util.DefaultObjectTypeDeterminer";
            }

            try {
                Class clazz = ClassLoaderUtil.loadClass(className, Dispatcher.class);
                ObjectTypeDeterminer objectTypeDeterminer = (ObjectTypeDeterminer) clazz.newInstance();
                ObjectTypeDeterminerFactory.setInstance(objectTypeDeterminer);
            } catch (Exception e) {
                LOG.error("Could not load ObjectTypeDeterminer named " + className + ". Using default DefaultObjectTypeDeterminer.", e);
            }
        }

        if ("true".equals(Settings.get(StrutsConstants.STRUTS_DEVMODE))) {
            devMode = true;
            Settings.set(StrutsConstants.STRUTS_I18N_RELOAD, "true");
            Settings.set(StrutsConstants.STRUTS_CONFIGURATION_XML_RELOAD, "true");
        }

        //check for configuration reloading
        if ("true".equalsIgnoreCase(Settings.get(StrutsConstants.STRUTS_CONFIGURATION_XML_RELOAD))) {
            FileManager.setReloadingConfigs(true);
        }

        if (Settings.isSet(StrutsConstants.STRUTS_CONTINUATIONS_PACKAGE)) {
            String pkg = Settings.get(StrutsConstants.STRUTS_CONTINUATIONS_PACKAGE);
            ObjectFactory.setContinuationPackage(pkg);
        }

        // test wether param-access workaround needs to be enabled
        if (servletContext != null && servletContext.getServerInfo() != null 
                && servletContext.getServerInfo().indexOf("WebLogic") >= 0) {
            LOG.info("WebLogic server detected. Enabling Struts parameter access work-around.");
            paramsWorkaroundEnabled = true;
        } else if (Settings.isSet(StrutsConstants.STRUTS_DISPATCHER_PARAMETERSWORKAROUND)) {
            paramsWorkaroundEnabled = "true".equals(Settings.get(StrutsConstants.STRUTS_DISPATCHER_PARAMETERSWORKAROUND));
        } else {
            LOG.debug("Parameter access work-around disabled.");
        }

        configurationManager = new ConfigurationManager();
        
        // Load old xwork files
        configurationManager.addConfigurationProvider(new XmlConfigurationProvider("xwork.xml", false));
        
        // Load Struts config files
        configurationManager.addConfigurationProvider(new StrutsXMLConfigurationProvider(false));
        
        synchronized(Dispatcher.class) {
            if (dispatcherListeners.size() > 0) {
                for (DispatcherListener l : dispatcherListeners) {
                    l.dispatcherInitialized(this);
                }
            }
        }
    }

    /**
     * Loads the action and executes it. This method first creates the action context from the given
     * parameters then loads an <tt>ActionProxy</tt> from the given action name and namespace. After that,
     * the action is executed and output channels throught the response object. Actions not found are
     * sent back to the user via the {@link Dispatcher#sendError} method, using the 404 return code.
     * All other errors are reported by throwing a ServletException.
     *
     * @param request  the HttpServletRequest object
     * @param response the HttpServletResponse object
     * @param mapping  the action mapping object
     * @throws ServletException when an unknown error occurs (not a 404, but typically something that
     *                          would end up as a 5xx by the servlet container)
     */
    public void serviceAction(HttpServletRequest request, HttpServletResponse response, ServletContext context, ActionMapping mapping) throws ServletException {
        Map<String, Object> extraContext = createContextMap(request, response, mapping, context);

        // If there was a previous value stack, then create a new copy and pass it in to be used by the new Action
        OgnlValueStack stack = (OgnlValueStack) request.getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY);
        if (stack != null) {
            extraContext.put(ActionContext.VALUE_STACK, new OgnlValueStack(stack));
        }

        try {
            String namespace = mapping.getNamespace();
            String name = mapping.getName();
            String method = mapping.getMethod();

            String id = request.getParameter(XWorkContinuationConfig.CONTINUE_PARAM);
            if (id != null) {
                // remove the continue key from the params - we don't want to bother setting
                // on the value stack since we know it won't work. Besides, this breaks devMode!
                Map params = (Map) extraContext.get(ActionContext.PARAMETERS);
                params.remove(XWorkContinuationConfig.CONTINUE_PARAM);

                // and now put the key in the context to be picked up later by XWork
                extraContext.put(XWorkContinuationConfig.CONTINUE_KEY, id);
            }

            ActionProxy proxy = ActionProxyFactory.getFactory().createActionProxy(
                    configurationManager.getConfiguration(), namespace, name, extraContext, true, false);
            proxy.setMethod(method);
            request.setAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY, proxy.getInvocation().getStack());

            // if the ActionMapping says to go straight to a result, do it!
            if (mapping.getResult() != null) {
                Result result = mapping.getResult();
                result.execute(proxy.getInvocation());
            } else {
                proxy.execute();
            }

            // If there was a previous value stack then set it back onto the request
            if (stack != null) {
                request.setAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY, stack);
            }
        } catch (ConfigurationException e) {
            LOG.error("Could not find action", e);
            sendError(request, response, context, HttpServletResponse.SC_NOT_FOUND, e);
        } catch (Exception e) {
            LOG.error("Could not execute action", e);
            sendError(request, response, context, HttpServletResponse.SC_INTERNAL_SERVER_ERROR, e);
        }
    }

    /**
     * Creates a context map containing all the wrapped request objects
     * 
     * @param request The servlet request
     * @param response The servlet response
     * @param mapping The action mapping
     * @param context The servlet context
     * @return A map of context objects
     */
    public Map<String,Object> createContextMap(HttpServletRequest request, HttpServletResponse response, 
            ActionMapping mapping, ServletContext context) {
        // request map wrapping the http request objects
        Map requestMap = new RequestMap(request);

        // parameters map wrapping the http paraneters.
        Map params = null;
        if (mapping != null) {
            params = mapping.getParams();
        }
        Map requestParams = new HashMap(request.getParameterMap());
        if (params != null) {
            params.putAll(requestParams);
        } else {
            params = requestParams;
        }

        // session map wrapping the http session
        Map session = new SessionMap(request);

        // application map wrapping the ServletContext
        Map application = new ApplicationMap(context);

        return createContextMap(requestMap, params, session, application, request, response, context);
    }

    /**
     * Merges all application and servlet attributes into a single <tt>HashMap</tt> to represent the entire
     * <tt>Action</tt> context.
     *
     * @param requestMap     a Map of all request attributes.
     * @param parameterMap   a Map of all request parameters.
     * @param sessionMap     a Map of all session attributes.
     * @param applicationMap a Map of all servlet context attributes.
     * @param request        the HttpServletRequest object.
     * @param response       the HttpServletResponse object.
     * @param servletContext the ServletContext object.
     * @return a HashMap representing the <tt>Action</tt> context.
     */
    public HashMap<String,Object> createContextMap(Map requestMap,
                                    Map parameterMap,
                                    Map sessionMap,
                                    Map applicationMap,
                                    HttpServletRequest request,
                                    HttpServletResponse response,
                                    ServletContext servletContext) {
        HashMap<String,Object> extraContext = new HashMap<String,Object>();
        extraContext.put(ActionContext.PARAMETERS, new HashMap(parameterMap));
        extraContext.put(ActionContext.SESSION, sessionMap);
        extraContext.put(ActionContext.APPLICATION, applicationMap);

        Locale locale = null;
        if (Settings.isSet(StrutsConstants.STRUTS_LOCALE)) {
            locale = LocalizedTextUtil.localeFromString(Settings.get(StrutsConstants.STRUTS_LOCALE), request.getLocale());
        } else {
            locale = request.getLocale();
        }

        extraContext.put(ActionContext.LOCALE, locale);
        extraContext.put(ActionContext.DEV_MODE, Boolean.valueOf(devMode));

        extraContext.put(StrutsStatics.HTTP_REQUEST, request);
        extraContext.put(StrutsStatics.HTTP_RESPONSE, response);
        extraContext.put(StrutsStatics.SERVLET_CONTEXT, servletContext);

        // helpers to get access to request/session/application scope
        extraContext.put("request", requestMap);
        extraContext.put("session", sessionMap);
        extraContext.put("application", applicationMap);
        extraContext.put("parameters", parameterMap);

        AttributeMap attrMap = new AttributeMap(extraContext);
        extraContext.put("attr", attrMap);

        return extraContext;
    }

    /**
     * Returns the maximum upload size allowed for multipart requests (this is configurable).
     *
     * @return the maximum upload size allowed for multipart requests
     */
    private static int getMaxSize() {
        Integer maxSize = new Integer(Integer.MAX_VALUE);
        try {
            String maxSizeStr = Settings.get(StrutsConstants.STRUTS_MULTIPART_MAXSIZE);

            if (maxSizeStr != null) {
                try {
                    maxSize = new Integer(maxSizeStr);
                } catch (NumberFormatException e) {
                    LOG.warn("Unable to format 'struts.multipart.maxSize' property setting. Defaulting to Integer.MAX_VALUE");
                }
            } else {
                LOG.warn("Unable to format 'struts.multipart.maxSize' property setting. Defaulting to Integer.MAX_VALUE");
            }
        } catch (IllegalArgumentException e1) {
            LOG.warn("Unable to format 'struts.multipart.maxSize' property setting. Defaulting to Integer.MAX_VALUE");
        }

        if (LOG.isDebugEnabled()) {
            LOG.debug("maxSize=" + maxSize);
        }

        return maxSize.intValue();
    }

    /**
     * Returns the path to save uploaded files to (this is configurable).
     *
     * @return the path to save uploaded files to
     */
    private String getSaveDir(ServletContext servletContext) {
        String saveDir = Settings.get(StrutsConstants.STRUTS_MULTIPART_SAVEDIR).trim();

        if (saveDir.equals("")) {
            File tempdir = (File) servletContext.getAttribute("javax.servlet.context.tempdir");
            LOG.info("Unable to find 'struts.multipart.saveDir' property setting. Defaulting to javax.servlet.context.tempdir");

            if (tempdir != null) {
                saveDir = tempdir.toString();
            }
        } else {
            File multipartSaveDir = new File(saveDir);

            if (!multipartSaveDir.exists()) {
                multipartSaveDir.mkdir();
            }
        }

        if (LOG.isDebugEnabled()) {
            LOG.debug("saveDir=" + saveDir);
        }

        return saveDir;
    }

    /**
     * Prepares a request, including setting the encoding and locale
     * 
     * @param request The request
     * @param response The response
     */
    public void prepare(HttpServletRequest request, HttpServletResponse response) {
        String encoding = null;
        if (Settings.isSet(StrutsConstants.STRUTS_I18N_ENCODING)) {
            encoding = Settings.get(StrutsConstants.STRUTS_I18N_ENCODING);
        }

        Locale locale = null;
        if (Settings.isSet(StrutsConstants.STRUTS_LOCALE)) {
            locale = LocalizedTextUtil.localeFromString(Settings.get(StrutsConstants.STRUTS_LOCALE), request.getLocale());
        }

        if (encoding != null) {
            try {
                request.setCharacterEncoding(encoding);
            } catch (Exception e) {
                LOG.error("Error setting character encoding to '" + encoding + "' - ignoring.", e);
            }
        }

        if (locale != null) {
            response.setLocale(locale);
        }

        if (paramsWorkaroundEnabled) {
            request.getParameter("foo"); // simply read any parameter (existing or not) to "prime" the request
        }
    }

    /**
     * Wraps and returns the given response or returns the original response object. This is used to transparently
     * handle multipart data as a wrapped class around the given request. Override this method to handle multipart
     * requests in a special way or to handle other types of requests. Note, {@link org.apache.struts2.dispatcher.multipart.MultiPartRequestWrapper} is
     * flexible - you should look to that first before overriding this method to handle multipart data.
     *
     * @param request the HttpServletRequest object.
     * @return a wrapped request or original request.
     * @see org.apache.struts2.dispatcher.multipart.MultiPartRequestWrapper
     */
    public HttpServletRequest wrapRequest(HttpServletRequest request, ServletContext servletContext) throws IOException {
        // don't wrap more than once
        if (request instanceof StrutsRequestWrapper) {
            return request;
        }

        if (MultiPartRequest.isMultiPart(request)) {
            request = new MultiPartRequestWrapper(request, getSaveDir(servletContext), getMaxSize());
        } else {
            request = new StrutsRequestWrapper(request);
        }

        return request;
    }

    /**
     * Sends an HTTP error response code.
     *
     * @param request  the HttpServletRequest object.
     * @param response the HttpServletResponse object.
     * @param code     the HttpServletResponse error code (see {@link javax.servlet.http.HttpServletResponse} for possible error codes).
     * @param e        the Exception that is reported.
     */
    public void sendError(HttpServletRequest request, HttpServletResponse response, 
            ServletContext ctx, int code, Exception e) {
        if (devMode) {
            response.setContentType("text/html");
            
            try {
                freemarker.template.Configuration config = FreemarkerManager.getInstance().getConfiguration(ctx);
                Template template = config.getTemplate("/org/apache/struts2/dispatcher/error.ftl");
                
                List<Throwable> chain = new ArrayList<Throwable>();
                Throwable cur = e;
                chain.add(cur);
                while ((cur = cur.getCause()) != null) {
                    chain.add(cur);
                }
                
                HashMap<String,Object> data = new HashMap<String,Object>();
                data.put("exception", e);
                data.put("unknown", Location.UNKNOWN);
                data.put("chain", chain);
                data.put("locator", new Locator());
                template.process(data, response.getWriter());
                response.getWriter().close();
            } catch (Exception exp) {
                try {
                    response.sendError(code, "Unable to show problem report: " + exp);
                } catch (IOException ex) {
                    // we're already sending an error, not much else we can do if more stuff breaks
                }
            }
        } else {
            try {
                // send a http error response to use the servlet defined error handler
                // make the exception availible to the web.xml defined error page
                request.setAttribute("javax.servlet.error.exception", e);
    
                // for compatibility
                request.setAttribute("javax.servlet.jsp.jspException", e);
    
                // send the error response
                response.sendError(code, e.getMessage());
            } catch (IOException e1) {
                // we're already sending an error, not much else we can do if more stuff breaks
            }
        }
    }

    /**
     * Returns <tt>true</tt>, if portlet support is active, <tt>false</tt> otherwise.
     *
     * @return <tt>true</tt>, if portlet support is active, <tt>false</tt> otherwise.
     */
    public boolean isPortletSupportActive() {
        return portletSupportActive;
    }

    /**
     * Set the flag that portlet support is active or not.
     * @param portletSupportActive <tt>true</tt> or <tt>false</tt>
     */
    public static void setPortletSupportActive(boolean portletSupportActive) {
        Dispatcher.portletSupportActive = portletSupportActive;
    }

    /** Simple accessor for a static method */
    public class Locator {
        public Location getLocation(Object obj) {
            Location loc = LocationUtils.getLocation(obj);
            if (loc == null) {
                return Location.UNKNOWN;
            } 
            return loc;
        }
    }

    /**
     * Gets the current configuration manager instance
     * 
     * @return The instance
     */
    public ConfigurationManager getConfigurationManager() {
        return configurationManager;
    }

    /**
     * Sets the current configuration manager instance
     * 
     * @param mgr The configuration manager
     */
    public void setConfigurationManager(ConfigurationManager mgr) {
        this.configurationManager = mgr;
    }
}
"
core/src/main/java/org/apache/struts2/dispatcher/DispatcherListener.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher;

/**
 * A interface to tag those that want to execute code on the init and
 * destory of a Dispatcher.
 */
public interface DispatcherListener {

    /**
     * Called when the dispatcher is initialized
     * 
     * @param du The dispatcher instance
     */
    public void dispatcherInitialized(Dispatcher du);
    
    /**
     * Called when the dispatcher is destroyed
     * 
     * @param du The dispatcher instance
     */
    public void dispatcherDestroyed(Dispatcher du);
}
"
core/src/main/java/org/apache/struts2/dispatcher/FilterDispatcher.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URLDecoder;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.StringTokenizer;
import java.util.TimeZone;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.RequestUtils;
import org.apache.struts2.StrutsConstants;
import org.apache.struts2.StrutsStatics;
import org.apache.struts2.config.Settings;
import org.apache.struts2.dispatcher.mapper.ActionMapper;
import org.apache.struts2.dispatcher.mapper.ActionMapperFactory;
import org.apache.struts2.dispatcher.mapper.ActionMapping;

import com.opensymphony.module.sitemesh.RequestConstants;
import com.opensymphony.xwork2.util.ClassLoaderUtil;
import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.XWorkException;

/**
 * Master filter for Struts that handles four distinct 
 * responsibilities:
 *
 * <ul>
 *
 * <li>Executing actions</li>
 *
 * <li>Cleaning up the {@link ActionContext} (see note)</li>
 *
 * <li>Serving static content</li>
 *
 * <li>Kicking off XWork's interceptor chain for the request lifecycle</li>
 *
 * </ul>
 *
 * <p/> <b>IMPORTANT</b>: this filter must be mapped to all requests. Unless you know exactly what you are doing, always
 * map to this URL pattern: /*
 *
 * <p/> <b>Executing actions</b>
 *
 * <p/> This filter executes actions by consulting the {@link ActionMapper} and determining if the requested URL should
 * invoke an action. If the mapper indicates it should, <b>the rest of the filter chain is stopped</b> and the action is
 * invoked. This is important, as it means that filters like the SiteMesh filter must be placed <b>before</b> this
 * filter or they will not be able to decorate the output of actions.
 *
 * <p/> <b>Cleaning up the {@link ActionContext}</b>
 *
 * <p/> This filter will also automatically clean up the {@link ActionContext} for you, ensuring that no memory leaks
 * take place. However, this can sometimes cause problems integrating with other products like SiteMesh. See {@link
 * ActionContextCleanUp} for more information on how to deal with this.
 *
 * <p/> <b>Serving static content</b>
 *
 * <p/> This filter also serves common static content needed when using various parts of Struts, such as JavaScript
 * files, CSS files, etc. It works by looking for requests to /struts/*, and then mapping the value after "/struts/"
 * to common packages in Struts and, optionally, in your class path. By default, the following packages are
 * automatically searched:
 *
 * <ul>
 *
 * <li>org.apache.struts2.static</li>
 *
 * <li>template</li>
 *
 * </ul>
 *
 * <p/> This means that you can simply request /struts/xhtml/styles.css and the XHTML UI theme's default stylesheet
 * will be returned. Likewise, many of the AJAX UI components require various JavaScript files, which are found in the
 * org.apache.struts2.static package. If you wish to add additional packages to be searched, you can add a comma
 * separated (space, tab and new line will do as well) list in the filter init parameter named "packages". <b>Be
 * careful</b>, however, to expose any packages that may have sensitive information, such as properties file with
 * database access credentials.
 *
 * <p/>
 * 
 * To use a custom {@link Dispatcher}, the <code>createDispatcher()</code> method could be overriden by 
 * the subclass.
 *
 * @see org.apache.struts2.lifecycle.LifecycleListener
 * @see ActionMapper
 * @see ActionContextCleanUp
 */
public class FilterDispatcher implements Filter, StrutsStatics {
    private static final Log LOG = LogFactory.getLog(FilterDispatcher.class);

    private FilterConfig filterConfig;
    private String[] pathPrefixes;
    private Dispatcher dispatcher;

    private SimpleDateFormat df = new SimpleDateFormat("E, d MMM yyyy HH:mm:ss");
    private final Calendar lastModifiedCal = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
    private final String lastModified = df.format(lastModifiedCal.getTime());

    /** 
     * Gets this filter's configuration
     * 
     * @return The filter config
     */
    protected FilterConfig getFilterConfig() {
        return filterConfig;
    }

    /**
     * Cleans up the dispatcher
     */
    public void destroy() {
        	if (dispatcher == null) {
        		LOG.warn("something is seriously wrong, DispatcherUtil is not initialized (null) ");
        	} else {
        	    dispatcher.cleanup();
        }
    }

    /**
     * Initializes the dispatcher and filter
     */
    public void init(FilterConfig filterConfig) throws ServletException {
        this.filterConfig = filterConfig;
        String param = filterConfig.getInitParameter("packages");
        String packages = "org.apache.struts2.static template org.apache.struts2.interceptor.debugging";
        if (param != null) {
            packages = param + " " + packages;
        }
        this.pathPrefixes = parse(packages);
        dispatcher = createDispatcher();
    }
    
    /**
     * Parses the list of packages
     * 
     * @param packages A comma-delimited String 
     * @return A string array of packages
     */
    protected String[] parse(String packages) {
        if (packages == null) {
            return null;
        }
        List<String> pathPrefixes = new ArrayList<String>();

        StringTokenizer st = new StringTokenizer(packages, ", \n\t");
        while (st.hasMoreTokens()) {
            String pathPrefix = st.nextToken().replace('.', '/');
            if (!pathPrefix.endsWith("/")) {
                pathPrefix += "/";
            }
            pathPrefixes.add(pathPrefix);
        }

        return (String[]) pathPrefixes.toArray(new String[pathPrefixes.size()]);
    }


    /* (non-Javadoc)
     * @see javax.servlet.Filter#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain)
     */
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;
        ServletContext servletContext = filterConfig.getServletContext();

        Dispatcher du = Dispatcher.getInstance();
        
        // Prepare and wrap the request if the cleanup filter hasn't already
        if (du == null) {
            du = dispatcher;
            // prepare the request no matter what - this ensures that the proper character encoding
            // is used before invoking the mapper (see WW-9127)
            du.prepare(request, response);

            try {
                // Wrap request first, just in case it is multipart/form-data 
                // parameters might not be accessible through before encoding (ww-1278)
                request = du.wrapRequest(request, servletContext);
            } catch (IOException e) {
                String message = "Could not wrap servlet request with MultipartRequestWrapper!";
                LOG.error(message, e);
                throw new ServletException(message, e);
            }
            Dispatcher.setInstance(du);
        }

        ActionMapper mapper = null;
        ActionMapping mapping = null;
        try {
            mapper = ActionMapperFactory.getMapper();
            mapping = mapper.getMapping(request, du.getConfigurationManager().getConfiguration());
        } catch (Exception ex) {
            du.sendError(request, response, servletContext, response.SC_INTERNAL_SERVER_ERROR, ex);
            ActionContextCleanUp.cleanUp(req);
            return;
        }

        if (mapping == null) {
            // there is no action in this request, should we look for a static resource?
            String resourcePath = RequestUtils.getServletPath(request);

            if ("".equals(resourcePath) && null != request.getPathInfo()) {
                resourcePath = request.getPathInfo();
            }

            if ("true".equals(Settings.get(StrutsConstants.STRUTS_SERVE_STATIC_CONTENT)) 
                    && resourcePath.startsWith("/struts")) {
                String name = resourcePath.substring("/struts".length());
                findStaticResource(name, response);
            } else {
                // this is a normal request, let it pass through
                chain.doFilter(request, response);
            }
            // The framework did its job here
            return;
        }


        try {
            dispatcher.serviceAction(request, response, servletContext, mapping);
        } finally {
            ActionContextCleanUp.cleanUp(req);
        }
    }

    /**
     * Servlet 2.3 specifies that the servlet context can be retrieved from the session. Unfortunately, some versions of
     * WebLogic can only retrieve the servlet context from the filter config. Hence, this method enables subclasses to
     * retrieve the servlet context from other sources.
     *
     * @param session the HTTP session where, in Servlet 2.3, the servlet context can be retrieved
     * @return the servlet context.
     */
    protected ServletContext getServletContext(HttpSession session) {
        return filterConfig.getServletContext();
    }

    /**
     * Fins a static resource
     * 
     * @param name The resource name
     * @param response The request
     * @throws IOException If anything goes wrong
     */
    protected void findStaticResource(String name, HttpServletResponse response) throws IOException {
        if (!name.endsWith(".class")) {
            for (int i = 0; i < pathPrefixes.length; i++) {
                InputStream is = findInputStream(name, pathPrefixes[i]);
                if (is != null) {
                    // set the content-type header
                    String contentType = getContentType(name);
                    if (contentType != null) {
                        response.setContentType(contentType);
                    }
                    
                    if ("true".equals(Settings.get(StrutsConstants.STRUTS_SERVE_STATIC_BROWSER_CACHE))) {
                    	// set heading information for caching static content
                        Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
                        response.setHeader("Date",df.format(cal.getTime())+" GMT");
                        cal.add(Calendar.DAY_OF_MONTH,1);
                        response.setHeader("Expires",df.format(cal.getTime())+" GMT");
                        response.setHeader("Retry-After",df.format(cal.getTime())+" GMT");
                        response.setHeader("Cache-Control","public");
                        response.setHeader("Last-Modified",lastModified+" GMT");
                    }
                    else {
                    	response.setHeader("Cache-Control","no-cache");
                        response.setHeader("Pragma","no-cache");
                        response.setHeader("Expires","-1");
                    }

                    try {
                        copy(is, response.getOutputStream());
                    } finally {
                        is.close();
                    }
                    return;
                }
            }
        }

        response.sendError(HttpServletResponse.SC_NOT_FOUND);
    }

    /**
     * Determines the content type for the resource name
     * 
     * @param name The resource name
     * @return The mime type
     */
    protected String getContentType(String name) {
        // NOT using the code provided activation.jar to avoid adding yet another dependency
        // this is generally OK, since these are the main files we server up
        if (name.endsWith(".js")) {
            return "text/javascript";
        } else if (name.endsWith(".css")) {
            return "text/css";
        } else if (name.endsWith(".html")) {
            return "text/html";
        } else if (name.endsWith(".txt")) {
            return "text/plain";
        } else if (name.endsWith(".gif")) {
            return "image/gif";
        } else if (name.endsWith(".jpg") || name.endsWith(".jpeg")) {
            return "image/jpeg";
        } else if (name.endsWith(".png")) {
            return "image/png";
        } else {
            return null;
        }
    }

    /**
     * Copies the from the input stream to the output stream
     * 
     * @param input The input stream
     * @param output The output stream
     * @throws IOException If anything goes wrong
     */
    protected void copy(InputStream input, OutputStream output) throws IOException {
        final byte[] buffer = new byte[4096];
        int n;
        while (-1 != (n = input.read(buffer))) {
            output.write(buffer, 0, n);
        }
    }

    /**
     * Looks for a static resource in the classpath
     * 
     * @param name The resource name
     * @param packagePrefix The package prefix to use to locate the resource
     * @return The inputstream of the resource
     * @throws IOException If there is a problem locating the resource
     */
    protected InputStream findInputStream(String name, String packagePrefix) throws IOException {
        String resourcePath;
        if (packagePrefix.endsWith("/") && name.startsWith("/")) {
            resourcePath = packagePrefix + name.substring(1);
        } else {
            resourcePath = packagePrefix + name;
        }

        String enc = (String) Settings.get(StrutsConstants.STRUTS_I18N_ENCODING);
        resourcePath = URLDecoder.decode(resourcePath, enc);

        return ClassLoaderUtil.getResourceAsStream(resourcePath, getClass());
    }
    
    /**
     * Create a {@link Dispatcher}, this serves as a hook for subclass to overried
     * such that a custom {@link Dispatcher} could be created. 
     * 
     * @return Dispatcher
     */
    protected Dispatcher createDispatcher() {
    	return new Dispatcher(filterConfig.getServletContext());
    }
}
"
core/src/main/java/org/apache/struts2/dispatcher/FilterDispatcherCompatWeblogic61.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher;

import javax.servlet.Filter;
import javax.servlet.FilterConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpSession;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.config.ServletContextSingleton;


/**
 * When running Weblogic Server 6.1, this class should be
 * specified in web.xml instead of {@link FilterDispatcher}.
 * <p/>
 * This class properly handles the weblogic.jar handling
 * of servlet filters.  There is one serious incompatibility, and
 * that is that while {@link FilterDispatcher#init(FilterConfig)}
 * throws a {@link ServletException}, this class's method
 * {@link #setFilterConfig(FilterConfig)} does not throw
 * the exception.  Since {@link #setFilterConfig(FilterConfig)}
 * invokes {@link FilterDispatcher#init(FilterConfig)}, the setter
 * must "swallow" the exception.  This it does by logging the
 * exception as an error.
 *
 */
public class FilterDispatcherCompatWeblogic61
        extends FilterDispatcher
        implements Filter {

    private static Log log =
            LogFactory.getLog(FilterDispatcherCompatWeblogic61.class);

    /**
     * dummy setter for {@link #filterConfig}; this method
     * sets up the {@link org.apache.struts2.config.ServletContextSingleton} with
     * the servlet context from the filter configuration.
     * <p/>
     * This is needed by Weblogic Server 6.1 because it
     * uses a slightly obsolete Servlet 2.3-minus spec
     * whose {@link Filter} interface requires this method.
     * <p/>
     *
     * @param filterConfig the filter configuration.
     */
    public void setFilterConfig(FilterConfig filterConfig) {
        try {
            init(filterConfig);
        } catch (ServletException se) {
            log.error("Couldn't set the filter configuration in this filter", se);
        }

        ServletContextSingleton singleton = ServletContextSingleton.getInstance();
        singleton.setServletContext(filterConfig.getServletContext());
    }

    /**
     * answers the servlet context.
     * <p/>
     * Servlet 2.3 specifies that this can be retrieved from
     * the session.  Unfortunately, weblogic.jar can only retrieve
     * the servlet context from the filter config.  Hence, this
     * returns the servlet context from the singleton that was
     * setup by {@link #setFilterConfig(FilterConfig)}.
     *
     * @param session the HTTP session.  Not used
     * @return the servlet context.
     */
    protected ServletContext getServletContext(HttpSession session) {
        ServletContextSingleton singleton =
                ServletContextSingleton.getInstance();
        return singleton.getServletContext();
    }

    /**
     * This method is required by Weblogic 6.1 SP4 because
     * they defined this as a required method just before
     * the Servlet 2.3 specification was finalized.
     *
     * @return the filter's filter configuration
     */
    public FilterConfig getFilterConfig() {
        return super.getFilterConfig();
    }
}
"
core/src/main/java/org/apache/struts2/dispatcher/HttpHeaderResult.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.ServletActionContext;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.Result;
import com.opensymphony.xwork2.util.OgnlValueStack;
import com.opensymphony.xwork2.util.TextParseUtil;


/**
 * <!-- START SNIPPET: description -->
 *
 * A custom Result type for setting HTTP headers and status by optionally evaluating against the ValueStack.
 * 
 * <!-- END SNIPPET: description -->
 * <p/>
 * <b>This result type takes the following parameters:</b>
 *
 * <!-- START SNIPPET: params -->
 *
 * <ul>
 *
 * <li><b>status</b> - the http servlet response status code that should be set on a response.</li>
 *
 * <li><b>parse</b> - true by default. If set to false, the headers param will not be parsed for Ognl expressions.</li>
 *
 * <li><b>headers</b> - header values.</li>
 *
 * </ul>
 *
 * <!-- END SNIPPET: params -->
 *
 * <b>Example:</b>
 *
 * <pre><!-- START SNIPPET: example -->
 * &lt;result name="success" type="httpheader"&gt;
 *   &lt;param name="status"&gt;204&lt;/param&gt;
 *   &lt;param name="headers.a"&gt;a custom header value&lt;/param&gt;
 *   &lt;param name="headers.b"&gt;another custom header value&lt;/param&gt;
 * &lt;/result&gt;
 * <!-- END SNIPPET: example --></pre>
 *
 */
public class HttpHeaderResult implements Result {

	private static final long serialVersionUID = 195648957144219214L;

    /** The default parameter */
	public static final String DEFAULT_PARAM = "status";


    private boolean parse = true;
    private Map headers;
    private int status = -1;


    /**
     * Returns a Map of all HTTP headers.
     *
     * @return a Map of all HTTP headers.
     */
    public Map getHeaders() {
        if (headers == null) {
            headers = new HashMap();
        }

        return headers;
    }

    /**
     * Sets whether or not the HTTP header values should be evaluated against the ValueStack (by default they are).
     *
     * @param parse <tt>true</tt> if HTTP header values should be evaluated agains the ValueStack, <tt>false</tt>
     *              otherwise.
     */
    public void setParse(boolean parse) {
        this.parse = parse;
    }

    /**
     * Sets the http servlet response status code that should be set on a response.
     *
     * @param status the Http status code
     * @see javax.servlet.http.HttpServletResponse#setStatus(int)
     */
    public void setStatus(int status) {
        this.status = status;
    }

    /**
     * Sets the optional HTTP response status code and also re-sets HTTP headers after they've
     * been optionally evaluated against the ValueStack.
     *
     * @param invocation an encapsulation of the action execution state.
     * @throws Exception if an error occurs when re-setting the headers.
     */
    public void execute(ActionInvocation invocation) throws Exception {
        HttpServletResponse response = ServletActionContext.getResponse();

        if (status != -1) {
            response.setStatus(status);
        }

        if (headers != null) {
            OgnlValueStack stack = ActionContext.getContext().getValueStack();

            for (Iterator iterator = headers.entrySet().iterator();
                 iterator.hasNext();) {
                Map.Entry entry = (Map.Entry) iterator.next();
                String value = (String) entry.getValue();
                String finalValue = parse ? TextParseUtil.translateVariables(value, stack) : value;
                response.addHeader((String) entry.getKey(), finalValue);
            }
        }
    }
}
"
core/src/main/java/org/apache/struts2/dispatcher/PlainTextResult.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher;

import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.nio.charset.Charset;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.opensymphony.xwork2.ActionInvocation;

/**
 * <!-- START SNIPPET: description -->
 * 
 * A result that send the content out as plain text. Usefull typically when needed
 * to display the raw content of a JSP or Html file for example.
 * 
 * <!-- END SNIPPET: description -->
 * 
 * 
 * <!-- START SNIPPET: params -->
 * 
 * <ul>
 * 	<li>location (default) = location of the file (jsp/html) to be displayed as plain text.</li>
 *  <li>charSet (optional) = character set to be used. This character set will be used to set the
 *  response type (eg. Content-Type=text/plain; charset=UTF-8) and when reading 
 *  using a Reader. Some example of charSet would be UTF-8, ISO-8859-1 etc. 
 * </ul>
 * 
 * <!-- END SNIPPET: params -->
 * 
 * 
 * <pre>
 * <!-- START SNIPPET: example -->
 * 
 * &lt;action name="displayJspRawContent" &gt;
 *   &lt;result type="plaintext"&gt;/myJspFile.jsp&lt;/result&gt;
 * &lt;/action&gt;
 * 
 * 
 * &lt;action name="displayJspRawContent" &gt;
 *   &lt;result type="plaintext"&gt;
 *      &lt;param name="location"&gt;/myJspFile.jsp&lt;/param&gt;
 *      &lt;param name="charSet"&gt;UTF-8&lt;/param&gt;
 *   &lt;/result&gt;
 * &lt;/action&gt;
 * 
 * <!-- END SNIPPET: example -->
 * </pre>
 * 
 */
public class PlainTextResult extends StrutsResultSupport {

    public static final int BUFFER_SIZE = 1024;
    
	private static final Log _log = LogFactory.getLog(PlainTextResult.class);

	private static final long serialVersionUID = 3633371605905583950L;
	
	private String charSet;
	
	
    /**
     * Set the character set
     * 
     * @return The character set
     */
	public String getCharSet() {
		return charSet;
	}
    
    /**
     * Set the character set
     * 
     * @param charSet The character set
     */
	public void setCharSet(String charSet) {
		this.charSet = charSet;
	}
	
	/* (non-Javadoc)
	 * @see org.apache.struts2.dispatcher.StrutsResultSupport#doExecute(java.lang.String, com.opensymphony.xwork2.ActionInvocation)
	 */
	protected void doExecute(String finalLocation, ActionInvocation invocation) throws Exception {
		
		// verify charset 
		Charset charset = null;
		if (charSet != null) {
			if (Charset.isSupported(charSet)) {
				charset = Charset.forName(charSet);
			}
			else {
				_log.warn("charset ["+charSet+"] is not recognized ");
				charset = null;
			}
		}
		
		HttpServletResponse response = (HttpServletResponse) invocation.getInvocationContext().get(HTTP_RESPONSE);
		ServletContext servletContext = (ServletContext) invocation.getInvocationContext().get(SERVLET_CONTEXT);

		
		if (charset != null) {
			response.setContentType("text/plain; charset="+charSet);
		}
		else {
			response.setContentType("text/plain");
		}
		response.setHeader("Content-Disposition", "inline");
		
		
		PrintWriter writer = response.getWriter();
		InputStreamReader reader = null;
		try {
			if (charset != null) {
				reader = new InputStreamReader(servletContext.getResourceAsStream(location), charset);
			}
			else {
				reader = new InputStreamReader(servletContext.getResourceAsStream(location));
			}
			if (reader == null) {
				_log.warn("resource at location ["+location+"] cannot be obtained (return null) from ServletContext !!! ");
			}
			else {
				char[] buffer = new char[BUFFER_SIZE];
				int charRead = 0;
				while((charRead = reader.read(buffer)) != -1) {
					writer.write(buffer, 0, charRead);
				}
			}
		}
		finally {
			if (reader != null)
				reader.close();
			if (writer != null) {
				writer.flush();
				writer.close();
			}
		}
	}
}
"
core/src/main/java/org/apache/struts2/dispatcher/RequestMap.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher;

import java.io.Serializable;
import java.util.AbstractMap;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Set;

import javax.servlet.http.HttpServletRequest;


/**
 * A simple implementation of the {@link java.util.Map} interface to handle a collection of request attributes.
 */
public class RequestMap extends AbstractMap implements Serializable {

	private static final long serialVersionUID = -7675640869293787926L;
	
	private Set<Object> entries;
    private HttpServletRequest request;


    /**
     * Saves the request to use as the backing for getting and setting values
     *
     * @param request the http servlet request.
     */
    public RequestMap(final HttpServletRequest request) {
        this.request = request;
    }


    /**
     * Removes all attributes from the request as well as clears entries in this map.
     */
    public void clear() {
        entries = null;
        Enumeration keys = request.getAttributeNames();

        while (keys.hasMoreElements()) {
            String key = (String) keys.nextElement();
            request.removeAttribute(key);
        }
    }

    /**
     * Returns a Set of attributes from the http request.
     *
     * @return a Set of attributes from the http request.
     */
    public Set entrySet() {
        if (entries == null) {
            entries = new HashSet<Object>();

            Enumeration enumeration = request.getAttributeNames();

            while (enumeration.hasMoreElements()) {
                final String key = enumeration.nextElement().toString();
                final Object value = request.getAttribute(key);
                entries.add(new Entry() {
                    public boolean equals(Object obj) {
                        Entry entry = (Entry) obj;

                        return ((key == null) ? (entry.getKey() == null) : key.equals(entry.getKey())) && ((value == null) ? (entry.getValue() == null) : value.equals(entry.getValue()));
                    }

                    public int hashCode() {
                        return ((key == null) ? 0 : key.hashCode()) ^ ((value == null) ? 0 : value.hashCode());
                    }

                    public Object getKey() {
                        return key;
                    }

                    public Object getValue() {
                        return value;
                    }

                    public Object setValue(Object obj) {
                        request.setAttribute(key.toString(), obj);

                        return value;
                    }
                });
            }
        }

        return entries;
    }

    /**
     * Returns the request attribute associated with the given key or <tt>null</tt> if it doesn't exist.
     *
     * @param key the name of the request attribute.
     * @return the request attribute or <tt>null</tt> if it doesn't exist.
     */
    public Object get(Object key) {
        return request.getAttribute(key.toString());
    }

    /**
     * Saves an attribute in the request.
     *
     * @param key   the name of the request attribute.
     * @param value the value to set.
     * @return the object that was just set.
     */
    public Object put(Object key, Object value) {
        entries = null;
        request.setAttribute(key.toString(), value);

        return get(key);
    }

    /**
     * Removes the specified request attribute.
     *
     * @param key the name of the attribute to remove.
     * @return the value that was removed or <tt>null</tt> if the value was not found (and hence, not removed).
     */
    public Object remove(Object key) {
        entries = null;

        Object value = get(key);
        request.removeAttribute(key.toString());

        return value;
    }
}
"
core/src/main/java/org/apache/struts2/dispatcher/ServletActionRedirectResult.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.apache.struts2.dispatcher.mapper.ActionMapper;
import org.apache.struts2.dispatcher.mapper.ActionMapperFactory;
import org.apache.struts2.dispatcher.mapper.ActionMapping;
import org.apache.struts2.views.util.UrlHelper;

import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.config.entities.ResultConfig;

/**
 * <!-- START SNIPPET: description -->
 *
 * This result uses the {@link ActionMapper} provided by the {@link ActionMapperFactory} to redirect the browser to a
 * URL that invokes the specified action and (optional) namespace. This is better than the {@link ServletRedirectResult}
 * because it does not require you to encode the URL patterns processed by the {@link ActionMapper} in to your struts.xml
 * configuration files. This means you can change your URL patterns at any point and your application will still work.
 * It is strongly recommended that if you are redirecting to another action, you use this result rather than the
 * standard redirect result.
 *
 * <p/>
 *
 * To pass parameters, the &lt;param&gt; ... &lt;/param&gt; tag. The following parameters will not be
 * passable becuase they are part of the config param for this particular result.
 *
 * <ul>
 * 	<li>actionName</li>
 *  <li>namespace</li>
 *  <li>method</li>
 *  <li>encode</li>
 *  <li>parse</li>
 *  <li>location</li>
 *  <li>prependServletContext</li>
 * </ul>
 *
 * See examples below for an example of how request parameters could be passed in.
 *
 * <!-- END SNIPPET: description -->
 *
 * <b>This result type takes the following parameters:</b>
 *
 * <!-- START SNIPPET: params -->
 *
 * <ul>
 *
 * <li><b>actionName (default)</b> - the name of the action that will be redirect to</li>
 *
 * <li><b>namespace</b> - used to determine which namespace the action is in that we're redirecting to . If namespace is
 * null, this defaults to the current namespace</li>
 *
 * </ul>
 *
 * <!-- END SNIPPET: params -->
 *
 * <b>Example:</b>
 *
 * <pre><!-- START SNIPPET: example -->
 * &lt;package name="public" extends="struts-default"&gt;
 *     &lt;action name="login" class="..."&gt;
 *         &lt;!-- Redirect to another namespace --&gt;
 *         &lt;result type="redirect-action"&gt;
 *             &lt;param name="actionName"&gt;dashboard&lt;/param&gt;
 *             &lt;param name="namespace"&gt;/secure&lt;/param&gt;
 *         &lt;/result&gt;
 *     &lt;/action&gt;
 * &lt;/package&gt;
 *
 * &lt;package name="secure" extends="struts-default" namespace="/secure"&gt;
 *     &lt;-- Redirect to an action in the same namespace --&gt;
 *     &lt;action name="dashboard" class="..."&gt;
 *         &lt;result&gt;dashboard.jsp&lt;/result&gt;
 *         &lt;result name="error" type="redirect-action&gt;error&lt;/result&gt;
 *     &lt;/action&gt;
 *
 *     &lt;action name="error" class="..."&gt;
 *         &lt;result&gt;error.jsp&lt;/result&gt;
 *     &lt;/action&gt;
 * &lt;/package&gt;
 *
 * &lt;package name="passingRequestParameters" extends="struts-default" namespace="/passingRequestParameters"&gt;
 * 	  &lt;-- Pass parameters (reportType, width and height) --&gt;
 *    &lt;!--
 *    The redirect-action url generated will be :
 *    /genReport/generateReport.action?reportType=pie&width=100&height=100
 *    --&gt;
 *    &lt;action name="gatherReportInfo" class="..."&gt;
 *       &lt;result name="showReportResult" type="redirect-action"&gt;
 *       	&lt;param name="actionName"&gt;generateReport&lt;/param&gt;
 *          &lt;param name="namespace="&gt;/genReport&lt;/param&gt;
 *          &lt;param name="reportType"&gt;pie&lt;/param&gt;
 *          &lt;param name="width"&gt;100&lt;/param&gt;
 *          &lt;param name="height"&gt;100&lt;/param&gt;
 *       &lt;/result&gt;
 *    &lt;/action&gt;
 * &lt;/package&gt;
 *
 *
 * <!-- END SNIPPET: example --></pre>
 *
 * @see ActionMapper
 */
public class ServletActionRedirectResult extends ServletRedirectResult {

	private static final long serialVersionUID = -9042425229314584066L;

    /** The default parameter */
	public static final String DEFAULT_PARAM = "actionName";

    protected String actionName;
    protected String namespace;
    protected String method;

    protected List<String> prohibitedResultParam = Arrays.asList(new String[] {
    		DEFAULT_PARAM, "namespace", "method", "encode", "parse", "location",
    		"prependServletContext" });

    /**
     * @see com.opensymphony.xwork2.Result#execute(com.opensymphony.xwork2.ActionInvocation)
     */
    public void execute(ActionInvocation invocation) throws Exception {
        actionName = conditionalParse(actionName, invocation);
        if (namespace == null) {
            namespace = invocation.getProxy().getNamespace();
        } else {
            namespace = conditionalParse(namespace, invocation);
        }
        if (method == null) {
        	method = "";
        }
        else {
        	method = conditionalParse(method, invocation);
        }

        Map<String, String> requestParameters = new HashMap<String, String>();
        ResultConfig resultConfig = invocation.getProxy().getConfig().getResults().get(
        		invocation.getResultCode());
        Map resultConfigParams = resultConfig.getParams();
        for (Iterator i = resultConfigParams.entrySet().iterator(); i.hasNext(); ) {
        	Map.Entry e = (Map.Entry) i.next();
        	if (! prohibitedResultParam.contains(e.getKey())) {
        		requestParameters.put(e.getKey().toString(),
        				e.getValue() == null ? "":
        					conditionalParse(e.getValue().toString(), invocation));
        	}
        }

        ActionMapper mapper = ActionMapperFactory.getMapper();
        StringBuffer tmpLocation = new StringBuffer(mapper.getUriFromActionMapping(new ActionMapping(actionName, namespace, method, null)));
        UrlHelper.buildParametersString(requestParameters, tmpLocation, "&");

        location = tmpLocation.toString();

        super.execute(invocation);
    }

    /**
     * Sets the action name
     *
     * @param actionName The name
     */
    public void setActionName(String actionName) {
        this.actionName = actionName;
    }

    /**
     * Sets the namespace
     *
     * @param namespace The namespace
     */
    public void setNamespace(String namespace) {
        this.namespace = namespace;
    }

    /**
     * Sets the method
     *
     * @param method The method
     */
    public void setMethod(String method) {
    	this.method = method;
    }
}
"
core/src/main/java/org/apache/struts2/dispatcher/ServletDispatcherResult.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher;

import javax.servlet.RequestDispatcher;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.jsp.PageContext;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.ServletActionContext;

import com.opensymphony.xwork2.ActionInvocation;


/**
 * <!-- START SNIPPET: description -->
 *
 * Includes or forwards to a view (usually a jsp). Behind the scenes Struts
 * will use a RequestDispatcher, where the target servlet/JSP receives the same
 * request/response objects as the original servlet/JSP. Therefore, you can pass
 * data between them using request.setAttribute() - the Struts action is
 * available.
 * <p/>
 * There are three possible ways the result can be executed:
 *  
 * <ul>
 *
 * <li>If we are in the scope of a JSP (a PageContext is available), PageContext's
 * {@link PageContext#include(String) include} method is called.</li>
 *
 * <li>If there is no PageContext and we're not in any sort of include (there is no
 * "javax.servlet.include.servlet_path" in the request attributes), then a call to
 * {@link RequestDispatcher#forward(javax.servlet.ServletRequest, javax.servlet.ServletResponse) forward}
 * is made.</li>
 * 
 * <li>Otherwise, {@link RequestDispatcher#include(javax.servlet.ServletRequest, javax.servlet.ServletResponse) include}
 * is called.</li>
 * 
 * </ul>
 * <!-- END SNIPPET: description -->
 *
 * <b>This result type takes the following parameters:</b>
 *
 * <!-- START SNIPPET: params -->
 *
 * <ul>
 *
 * <li><b>location (default)</b> - the location to go to after execution (ex. jsp).</li>
 *
 * <li><b>parse</b> - true by default. If set to false, the location param will not be parsed for Ognl expressions.</li>
 *
 * </ul>
 *
 * <!-- END SNIPPET: params -->
 *
 * <b>Example:</b>
 *
 * <pre><!-- START SNIPPET: example -->
 * &lt;result name="success" type="dispatcher"&gt;
 *   &lt;param name="location"&gt;foo.jsp&lt;/param&gt;
 * &lt;/result&gt;
 * <!-- END SNIPPET: example --></pre>
 *
 * This result follows the same rules from {@link StrutsResultSupport}.
 *
 * @see javax.servlet.RequestDispatcher
 */
public class ServletDispatcherResult extends StrutsResultSupport {

	private static final long serialVersionUID = -1970659272360685627L;
	
	private static final Log log = LogFactory.getLog(ServletDispatcherResult.class);


    /**
     * Dispatches to the given location. Does its forward via a RequestDispatcher. If the
     * dispatch fails a 404 error will be sent back in the http response.
     *
     * @param finalLocation the location to dispatch to.
     * @param invocation    the execution state of the action
     * @throws Exception if an error occurs. If the dispatch fails the error will go back via the
     *                   HTTP request.
     */
    public void doExecute(String finalLocation, ActionInvocation invocation) throws Exception {
        if (log.isDebugEnabled()) {
            log.debug("Forwarding to location " + finalLocation);
        }

        PageContext pageContext = ServletActionContext.getPageContext();

        if (pageContext != null) {
            pageContext.include(finalLocation);
        } else {
            HttpServletRequest request = ServletActionContext.getRequest();
            HttpServletResponse response = ServletActionContext.getResponse();
            RequestDispatcher dispatcher = request.getRequestDispatcher(finalLocation);

            // if the view doesn't exist, let's do a 404
            if (dispatcher == null) {
                response.sendError(404, "result '" + finalLocation + "' not found");

                return;
            }

            // If we're included, then include the view
            // Otherwise do forward 
            // This allow the page to, for example, set content type 
            if (!response.isCommitted() && (request.getAttribute("javax.servlet.include.servlet_path") == null)) {
                request.setAttribute("struts.view_uri", finalLocation);
                request.setAttribute("struts.request_uri", request.getRequestURI());

                dispatcher.forward(request, response);
            } else {
                dispatcher.include(request, response);
            }
        }
    }
}
"
core/src/main/java/org/apache/struts2/dispatcher/ServletRedirectResult.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.ServletActionContext;
import org.apache.struts2.dispatcher.mapper.ActionMapperFactory;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;


/**
 * <!-- START SNIPPET: description -->
 *
 * Calls the {@link HttpServletResponse#sendRedirect(String) sendRedirect}
 * method to the location specified. The response is told to redirect the
 * browser to the specified location (a new request from the client). The
 * consequence of doing this means that the action (action instance, action
 * errors, field errors, etc) that was just executed is lost and no longer
 * available. This is because actions are built on a single-thread model. The
 * only way to pass data is through the session or with web parameters
 * (url?name=value) which can be OGNL expressions.
 *
 * <!-- END SNIPPET: description -->
 * <p/>
 * <b>This result type takes the following parameters:</b>
 *
 * <!-- START SNIPPET: params -->
 *
 * <ul>
 *
 * <li><b>location (default)</b> - the location to go to after execution.</li>
 *
 * <li><b>parse</b> - true by default. If set to false, the location param will 
 * not be parsed for Ognl expressions.</li>
 *
 * </ul>
 *
 * <p>
 * This result follows the same rules from {@link StrutsResultSupport}.
 * </p>
 *
 * <!-- END SNIPPET: params -->
 *
 * <b>Example:</b>
 *
 * <pre><!-- START SNIPPET: example -->
 * &lt;result name="success" type="redirect"&gt;
 *   &lt;param name="location"&gt;foo.jsp&lt;/param&gt;
 *   &lt;param name="parse"&gt;false&lt;/param&gt;
 * &lt;/result&gt;
 * <!-- END SNIPPET: example --></pre>
 *
 */
public class ServletRedirectResult extends StrutsResultSupport {
	
	private static final long serialVersionUID = 6316947346435301270L;

	private static final Log log = LogFactory.getLog(ServletRedirectResult.class);

    protected boolean prependServletContext = true;

    /**
     * Sets whether or not to prepend the servlet context path to the redirected URL.
     *
     * @param prependServletContext <tt>true</tt> to prepend the location with the servlet context path,
     *                              <tt>false</tt> otherwise.
     */
    public void setPrependServletContext(boolean prependServletContext) {
        this.prependServletContext = prependServletContext;
    }

    /**
     * Redirects to the location specified by calling {@link HttpServletResponse#sendRedirect(String)}.
     *
     * @param finalLocation the location to redirect to.
     * @param invocation    an encapsulation of the action execution state.
     * @throws Exception if an error occurs when redirecting.
     */
    protected void doExecute(String finalLocation, ActionInvocation invocation) throws Exception {
        ActionContext ctx = invocation.getInvocationContext();
        HttpServletRequest request = (HttpServletRequest) ctx.get(ServletActionContext.HTTP_REQUEST);
        HttpServletResponse response = (HttpServletResponse) ctx.get(ServletActionContext.HTTP_RESPONSE);

        if (isPathUrl(finalLocation)) {
            if (!finalLocation.startsWith("/")) {
                String namespace = ActionMapperFactory.getMapper().getMapping(
                        request, Dispatcher.getInstance().getConfigurationManager().getConfiguration()).getNamespace();

                if ((namespace != null) && (namespace.length() > 0) && (!"/".equals(namespace))) {
                    finalLocation = namespace + "/" + finalLocation;
                } else {
                    finalLocation = "/" + finalLocation;
                }
            }

            // if the URL's are relative to the servlet context, append the servlet context path
            if (prependServletContext && (request.getContextPath() != null) && (request.getContextPath().length() > 0)) {
                finalLocation = request.getContextPath() + finalLocation;
            }

            finalLocation = response.encodeRedirectURL(finalLocation);
        }

        if (log.isDebugEnabled()) {
            log.debug("Redirecting to finalLocation " + finalLocation);
        }

        response.sendRedirect(finalLocation);
    }

    private static boolean isPathUrl(String url) {
        // filter out "http:", "https:", "mailto:", "file:", "ftp:"
        // since the only valid places for : in URL's is before the path specification
        // either before the port, or after the protocol
        return (url.indexOf(':') == -1);
    }
}
"
core/src/main/java/org/apache/struts2/dispatcher/SessionMap.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher;

import java.io.Serializable;
import java.util.AbstractMap;
import java.util.Arrays;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;


/**
 * A simple implementation of the {@link java.util.Map} interface to handle a collection of HTTP session
 * attributes. The {@link #entrySet()} method enumerates over all session attributes and creates a Set of entries.
 * Note, this will occur lazily - only when the entry set is asked for.
 *
 */
public class SessionMap extends AbstractMap implements Serializable {

	private static final long serialVersionUID = 4678843241638046854L;
	
	protected HttpSession session;
    protected Set<Object> entries;
    protected HttpServletRequest request;


    /**
     * Creates a new session map given a http servlet request. Note, ths enumeration of request
     * attributes will occur when the map entries are asked for.
     *
     * @param request the http servlet request object.
     */
    public SessionMap(HttpServletRequest request) {
        // note, holding on to this request and relying on lazy session initalization will not work
        // if you are running your action invocation in a background task, such as using the
        // "exec-and-wait" interceptor
        this.request = request;
        this.session = request.getSession(false);
    }

    /**
     * Invalidate the http session.
     */
    public void invalidate() {
		if (session == null) {
			return;
		}

		synchronized (session) {
			session.invalidate();
			session = null;
			entries = null;
		}
	}

    /**
	 * Removes all attributes from the session as well as clears entries in this
	 * map.
	 */
    public void clear() {
        if (session == null ) {
            return;
        }

        synchronized (session) {
        	entries = null;
        	Enumeration<String> attributeNamesEnum = session.getAttributeNames();
        	while(attributeNamesEnum.hasMoreElements()) {
        		session.removeAttribute(attributeNamesEnum.nextElement());
        	}
        }
        
    }

    /**
     * Returns a Set of attributes from the http session.
     *
     * @return a Set of attributes from the http session.
     */
    public Set entrySet() {
        if (session == null) {
            return Collections.EMPTY_SET;
        }

        synchronized (session) {
            if (entries == null) {
                entries = new HashSet<Object>();

                Enumeration enumeration = session.getAttributeNames();

                while (enumeration.hasMoreElements()) {
                    final String key = enumeration.nextElement().toString();
                    final Object value = session.getAttribute(key);
                    entries.add(new Map.Entry() {
                        public boolean equals(Object obj) {
                            Map.Entry entry = (Map.Entry) obj;

                            return ((key == null) ? (entry.getKey() == null) : key.equals(entry.getKey())) && ((value == null) ? (entry.getValue() == null) : value.equals(entry.getValue()));
                        }

                        public int hashCode() {
                            return ((key == null) ? 0 : key.hashCode()) ^ ((value == null) ? 0 : value.hashCode());
                        }

                        public Object getKey() {
                            return key;
                        }

                        public Object getValue() {
                            return value;
                        }

                        public Object setValue(Object obj) {
                            session.setAttribute(key.toString(), obj);

                            return value;
                        }
                    });
                }
            }
        }

        return entries;
    }

    /**
     * Returns the session attribute associated with the given key or <tt>null</tt> if it doesn't exist.
     *
     * @param key the name of the session attribute.
     * @return the session attribute or <tt>null</tt> if it doesn't exist.
     */
    public Object get(Object key) {
        if (session == null) {
            return null;
        }

        synchronized (session) {
            return session.getAttribute(key.toString());
        }
    }

    /**
     * Saves an attribute in the session.
     *
     * @param key   the name of the session attribute.
     * @param value the value to set.
     * @return the object that was just set.
     */
    public Object put(Object key, Object value) {
        synchronized (this) {
            if (session == null) {
                session = request.getSession(true);
            }
        }

        synchronized (session) {
            entries = null;
            session.setAttribute(key.toString(), value);

            return get(key);
        }
    }

    /**
     * Removes the specified session attribute.
     *
     * @param key the name of the attribute to remove.
     * @return the value that was removed or <tt>null</tt> if the value was not found (and hence, not removed).
     */
    public Object remove(Object key) {
        if (session == null) {
            return null;
        }

        synchronized (session) {
            entries = null;

            Object value = get(key);
            session.removeAttribute(key.toString());

            return value;
        }
    }
}
"
core/src/main/java/org/apache/struts2/dispatcher/StreamResult.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher;

import java.io.InputStream;
import java.io.OutputStream;

import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.opensymphony.xwork2.ActionInvocation;

/**
 * <!-- START SNIPPET: description -->
 *
 * A custom Result type for send raw data (via an InputStream) directly to the
 * HttpServletResponse. Very useful for allowing users to download content.
 *
 * <!-- END SNIPPET: description -->
 * <p/>
 * <b>This result type takes the following parameters:</b>
 *
 * <!-- START SNIPPET: params -->
 *
 * <ul>
 *
 * <li><b>contentType</b> - the stream mime-type as sent to the web browser
 * (default = <code>text/plain</code>).</li>
 *
 * <li><b>contentLength</b> - the stream length in bytes (the browser displays a
 * progress bar).</li>
 *
 * <li><b>contentDispostion</b> - the content disposition header value for
 * specifing the file name (default = <code>inline</code>, values are typically
 * <i>filename="document.pdf"</i>.</li>
 *
 * <li><b>inputName</b> - the name of the InputStream property from the chained
 * action (default = <code>inputStream</code>).</li>
 *
 * <li><b>bufferSize</b> - the size of the buffer to copy from input to output
 * (default = <code>1024</code>).</li>
 *
 * </ul>
 *
 * <!-- END SNIPPET: params -->
 *
 * <b>Example:</b>
 *
 * <pre><!-- START SNIPPET: example -->
 * &lt;result name="success" type="stream"&gt;
 *   &lt;param name="contentType"&gt;image/jpeg&lt;/param&gt;
 *   &lt;param name="inputName"&gt;imageStream&lt;/param&gt;
 *   &lt;param name="contentDisposition"&gt;filename="document.pdf"&lt;/param&gt;
 *   &lt;param name="bufferSize"&gt;1024&lt;/param&gt;
 * &lt;/result&gt;
 * <!-- END SNIPPET: example --></pre>
 *
 */
public class StreamResult extends StrutsResultSupport {
	
	private static final long serialVersionUID = -1468409635999059850L;

	protected static final Log log = LogFactory.getLog(StreamResult.class);

    protected String contentType = "text/plain";
    protected String contentLength;
    protected String contentDisposition = "inline";
    protected String inputName = "inputStream";
    protected int bufferSize = 1024;

    /**
     * @return Returns the bufferSize.
     */
    public int getBufferSize() {
        return (bufferSize);
    }

    /**
     * @param bufferSize The bufferSize to set.
     */
    public void setBufferSize(int bufferSize) {
        this.bufferSize = bufferSize;
    }

    /**
     * @return Returns the contentType.
     */
    public String getContentType() {
        return (contentType);
    }

    /**
     * @param contentType The contentType to set.
     */
    public void setContentType(String contentType) {
        this.contentType = contentType;
    }

    /**
     * @return Returns the contentLength.
     */
    public String getContentLength() {
        return contentLength;
    }

    /**
     * @param contentLength The contentLength to set.
     */
    public void setContentLength(String contentLength) {
        this.contentLength = contentLength;
    }

    /**
     * @return Returns the Content-disposition header value.
     */
    public String getContentDisposition() {
        return contentDisposition;
    }

    /**
     * @param contentDisposition the Content-disposition header value to use.
     */
    public void setContentDisposition(String contentDisposition) {
        this.contentDisposition = contentDisposition;
    }

    /**
     * @return Returns the inputName.
     */
    public String getInputName() {
        return (inputName);
    }

    /**
     * @param inputName The inputName to set.
     */
    public void setInputName(String inputName) {
        this.inputName = inputName;
    }

    /**
     * @see org.apache.struts2.dispatcher.StrutsResultSupport#doExecute(java.lang.String, com.opensymphony.xwork2.ActionInvocation)
     */
    protected void doExecute(String finalLocation, ActionInvocation invocation) throws Exception {

        InputStream oInput = null;
        OutputStream oOutput = null;

        try {
            // Find the inputstream from the invocation variable stack
            oInput = (InputStream) invocation.getStack().findValue(conditionalParse(inputName, invocation));

            if (oInput == null) {
                String msg = ("Can not find a java.io.InputStream with the name [" + inputName + "] in the invocation stack. " +
                    "Check the <param name=\"inputName\"> tag specified for this action.");
                log.error(msg);
                throw new IllegalArgumentException(msg);
            }

            // Find the Response in context
            HttpServletResponse oResponse = (HttpServletResponse) invocation.getInvocationContext().get(HTTP_RESPONSE);

            // Set the content type
            oResponse.setContentType(conditionalParse(contentType, invocation));

            // Set the content length
            if (contentLength != null) {
            	String _contentLength = conditionalParse(contentLength, invocation);
            	int _contentLengthAsInt = -1;
            	try {
            		_contentLengthAsInt = Integer.parseInt(_contentLength);
            		if (_contentLengthAsInt >= 0) {
                		oResponse.setContentLength(_contentLengthAsInt);
                	}
            	}
            	catch(NumberFormatException e) {
            		log.warn("failed to recongnize "+_contentLength+" as a number, contentLength header will not be set", e);
            	}
            }

            // Set the content-disposition
            if (contentDisposition != null) {
                oResponse.addHeader("Content-disposition", conditionalParse(contentDisposition, invocation));
            }

            // Get the outputstream
            oOutput = oResponse.getOutputStream();

            if (log.isDebugEnabled()) {
                log.debug("Streaming result [" + inputName + "] type=[" + contentType + "] length=[" + contentLength +
                    "] content-disposition=[" + contentDisposition + "]");
            }

            // Copy input to output
            log.debug("Streaming to output buffer +++ START +++");
            byte[] oBuff = new byte[bufferSize];
            int iSize;
            while (-1 != (iSize = oInput.read(oBuff))) {
                oOutput.write(oBuff, 0, iSize);
            }
            log.debug("Streaming to output buffer +++ END +++");

            // Flush
            oOutput.flush();
        }
        finally {
            if (oInput != null) oInput.close();
            if (oOutput != null) oOutput.close();
        }
    }

}
"
core/src/main/java/org/apache/struts2/dispatcher/StrutsRequestWrapper.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 *
 * All Struts requests are wrapped with this class, which provides simple JSTL accessibility. This is because JSTL
 * works with request attributes, so this class delegates to the value stack except for a few cases where required to
 * prevent infinite loops. Namely, we don't let any attribute name with "#" in it delegate out to the value stack, as it
 * could potentially cause an infinite loop. For example, an infinite loop would take place if you called:
 * request.getAttribute("#attr.foo").
 *
 * <!-- END SNIPPET: javadoc -->
 *
 */
public class StrutsRequestWrapper extends HttpServletRequestWrapper {
    
    /**
     * The constructor
     * @param req The request
     */
    public StrutsRequestWrapper(HttpServletRequest req) {
        super(req);
    }

    /**
     * Gets the object, looking in the value stack if not found
     * 
     * @param s The attribute key
     */
    public Object getAttribute(String s) {
        if (s != null && s.startsWith("javax.servlet")) {
            // don't bother with the standard javax.servlet attributes, we can short-circuit this
            // see WW-953 and the forums post linked in that issue for more info
            return super.getAttribute(s);
        }

        Object attribute = super.getAttribute(s);

        boolean alreadyIn = false;
        Boolean b = (Boolean) ActionContext.getContext().get("__requestWrapper.getAttribute");
        if (b != null) {
            alreadyIn = b.booleanValue();
        }

        // note: we don't let # come through or else a request for
        // #attr.foo or #request.foo could cause an endless loop
        if (!alreadyIn && attribute == null && s.indexOf("#") == -1) {
            try {
                // If not found, then try the ValueStack
                ActionContext.getContext().put("__requestWrapper.getAttribute", Boolean.TRUE);
                OgnlValueStack stack = ActionContext.getContext().getValueStack();
                if (stack != null) {
                    attribute = stack.findValue(s);
                }
            } finally {
                ActionContext.getContext().put("__requestWrapper.getAttribute", Boolean.FALSE);
            }
        }
        return attribute;
    }
}
"
core/src/main/java/org/apache/struts2/dispatcher/StrutsResultSupport.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.StrutsStatics;

import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.Result;
import com.opensymphony.xwork2.util.TextParseUtil;


/**
 * <!-- START SNIPPET: javadoc -->
 * 
 * A base class for all Struts action execution results.
 * The "location" param is the default parameter, meaning the most common usage of this result would be:
 * <p/>
 * This class provides two common parameters for any subclass:
 * <ul>
 * <li>location - the location to go to after execution (could be a jsp page or another action).
 * It can be parsed as per the rules definied in the
 * {@link TextParseUtil#translateVariables(java.lang.String, com.opensymphony.xwork2.util.OgnlValueStack) translateVariables}
 * method</li>
 * <li>parse - true by default. If set to false, the location param will not be parsed for expressions</li>
 * <li>encode - false by default. If set to false, the location param will not be url encoded. This only have effect when parse is true</li>
 * </ul>
 * 
 * <b>NOTE:</b>
 * The encode param will only have effect when parse is true
 * 
 * <!-- END SNIPPET: javadoc -->
 * 
 * <p/>
 * 
 * <!-- START SNIPPET: example -->
 * 
 * <p/>
 * In the struts.xml configuration file, these would be included as:
 * <p/>
 * <pre>
 *  &lt;result name="success" type="redirect"&gt;
 *      &lt;param name="<b>location</b>"&gt;foo.jsp&lt;/param&gt;
 *  &lt;/result&gt;</pre>
 * <p/>
 * or
 * <p/>
 * <pre>
 *  &lt;result name="success" type="redirect" &gt;
 *      &lt;param name="<b>location</b>"&gt;foo.jsp?url=${myUrl}&lt;/param&gt;
 *      &lt;param name="<b>parse</b>"&gt;true&lt;/param&gt;
 *      &lt;param name="<b>encode</b>"&gt;true&lt;/param&gt;
 *  &lt;/result&gt;</pre>
 * <p/>
 * In the above case, myUrl will be parsed against Ognl Value Stack and then 
 * URL encoded.
 * <p/>
 * or when using the default parameter feature
 * <p/>
 * <pre>
 *  &lt;result name="success" type="redirect"&gt;<b>foo.jsp</b>&lt;/result&gt;</pre>
 * <p/>
 * You should subclass this class if you're interested in adding more parameters or functionality
 * to your Result. If you do subclass this class you will need to
 * override {@link #doExecute(String, ActionInvocation)}.<p>
 * <p/>
 * Any custom result can be defined in struts.xml as:
 * <p/>
 * <pre>
 *  &lt;result-types&gt;
 *      ...
 *      &lt;result-type name="myresult" class="com.foo.MyResult" /&gt;
 *  &lt;/result-types&gt;</pre>
 * <p/>
 * Please see the {@link com.opensymphony.xwork2.Result} class for more info on Results in general.
 *
 * <!-- END SNIPPET: example -->
 * 
 * @see com.opensymphony.xwork2.Result
 */
public abstract class StrutsResultSupport implements Result, StrutsStatics {
	
	private static final Log _log = LogFactory.getLog(StrutsResultSupport.class);
	
    /** The default parameter */
    public static final String DEFAULT_PARAM = "location";

    protected boolean parse = true;
    protected boolean encode = false;
    protected String location;

    /**
     * The location to go to after action execution. This could be a JSP page or another action.
     * The location can contain OGNL expressions which will be evaulated if the <tt>parse</tt>
     * parameter is set to <tt>true</tt>.
     *
     * @param location the location to go to after action execution.
     * @see #setParse(boolean)
     */
    public void setLocation(String location) {
        this.location = location;
    }

    /**
     * Set parse to <tt>true</tt> to indicate that the location should be parsed as an OGNL expression. This
     * is set to <tt>true</tt> by default.
     *
     * @param parse <tt>true</tt> if the location parameter is an OGNL expression, <tt>false</tt> otherwise.
     */
    public void setParse(boolean parse) {
        this.parse = parse;
    }
    
    /**
     * Set encode to <tt>true</tt> to indicate that the location should be url encoded. This is set to
     * <tt>true</tt> by default
     * 
     * @param encode <tt>true</tt> if the location parameter should be url encode, <tt>false</tt> otherwise.
     */
    public void setEncode(boolean encode) {
    	this.encode = encode;
    }

    /**
     * Implementation of the <tt>execute</tt> method from the <tt>Result</tt> interface. This will call
     * the abstract method {@link #doExecute(String, ActionInvocation)} after optionally evaluating the
     * location as an OGNL evaluation.
     *
     * @param invocation the execution state of the action.
     * @throws Exception if an error occurs while executing the result.
     */
    public void execute(ActionInvocation invocation) throws Exception {
        doExecute(conditionalParse(location, invocation), invocation);
    }
    
    /**
     * Parses the parameter for OGNL expressions against the valuestack
     * 
     * @param param The parameter value
     * @param invocation The action invocation instance
     * @return The resulting string
     */
    protected String conditionalParse(String param, ActionInvocation invocation) {
        if (parse && param != null && invocation != null) {
            return TextParseUtil.translateVariables(param, invocation.getStack(), 
            		new TextParseUtil.ParsedValueEvaluator() {
						public Object evaluate(Object parsedValue) {
							if (encode) {
								if (parsedValue != null) {
									try {
										// use UTF-8 as this is the recommended encoding by W3C to 
										// avoid incompatibilities.
										return URLEncoder.encode(parsedValue.toString(), "UTF-8");
									}
									catch(UnsupportedEncodingException e) {
										_log.warn("error while trying to encode ["+parsedValue+"]", e);
									}
								}
							}
							return parsedValue;
						}
            });
        } else {
        	return param;
        }
    }

    /**
     * Executes the result given a final location (jsp page, action, etc) and the action invocation
     * (the state in which the action was executed). Subclasses must implement this class to handle
     * custom logic for result handling.
     *
     * @param finalLocation the location (jsp page, action, etc) to go to.
     * @param invocation    the execution state of the action.
     * @throws Exception if an error occurs while executing the result.
     */
    protected abstract void doExecute(String finalLocation, ActionInvocation invocation) throws Exception;
}
"
core/src/main/java/org/apache/struts2/dispatcher/VelocityResult.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher;

import java.io.OutputStreamWriter;
import java.io.Writer;

import javax.servlet.Servlet;
import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.jsp.JspFactory;
import javax.servlet.jsp.PageContext;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.ServletActionContext;
import org.apache.struts2.StrutsConstants;
import org.apache.struts2.config.Settings;
import org.apache.struts2.views.JspSupportServlet;
import org.apache.struts2.views.velocity.VelocityManager;
import org.apache.velocity.Template;
import org.apache.velocity.app.VelocityEngine;
import org.apache.velocity.context.Context;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * <!-- START SNIPPET: description -->
 *
 * Using the Servlet container's {@link JspFactory}, this result mocks a JSP
 * execution environment and then displays a Velocity template that will be
 * streamed directly to the servlet output.
 *
 * <!-- END SNIPPET: description -->
 * <p/>
 * <b>This result type takes the following parameters:</b>
 *
 * <!-- START SNIPPET: params -->
 *
 * <ul>
 *
 * <li><b>location (default)</b> - the location of the template to process.</li>
 *
 * <li><b>parse</b> - true by default. If set to false, the location param will 
 * not be parsed for Ognl expressions.</li>
 *
 * </ul>
 * <p>
 * This result follows the same rules from {@link StrutsResultSupport}.
 * </p>
 *
 * <!-- END SNIPPET: params -->
 *
 * <b>Example:</b>
 *
 * <pre><!-- START SNIPPET: example -->
 * &lt;result name="success" type="velocity"&gt;
 *   &lt;param name="location"&gt;foo.vm&lt;/param&gt;
 * &lt;/result&gt;
 * <!-- END SNIPPET: example --></pre>
 *
 */
public class VelocityResult extends StrutsResultSupport {

	private static final long serialVersionUID = 7268830767762559424L;
	
	private static final Log log = LogFactory.getLog(VelocityResult.class);


    /**
     * Creates a Velocity context from the action, loads a Velocity template and executes the
     * template. Output is written to the servlet output stream.
     *
     * @param finalLocation the location of the Velocity template
     * @param invocation    an encapsulation of the action execution state.
     * @throws Exception if an error occurs when creating the Velocity context, loading or executing
     *                   the template or writing output to the servlet response stream.
     */
    public void doExecute(String finalLocation, ActionInvocation invocation) throws Exception {
        OgnlValueStack stack = ActionContext.getContext().getValueStack();

        HttpServletRequest request = ServletActionContext.getRequest();
        HttpServletResponse response = ServletActionContext.getResponse();
        JspFactory jspFactory = null;
        ServletContext servletContext = ServletActionContext.getServletContext();
        Servlet servlet = JspSupportServlet.jspSupportServlet;

        VelocityManager.getInstance().init(servletContext);

        boolean usedJspFactory = false;
        PageContext pageContext = (PageContext) ActionContext.getContext().get(ServletActionContext.PAGE_CONTEXT);

        if (pageContext == null && servlet != null) {
            jspFactory = JspFactory.getDefaultFactory();
            pageContext = jspFactory.getPageContext(servlet, request, response, null, true, 8192, true);
            ActionContext.getContext().put(ServletActionContext.PAGE_CONTEXT, pageContext);
            usedJspFactory = true;
        }

        try {
            String encoding = getEncoding(finalLocation);
            String contentType = getContentType(finalLocation);

            if (encoding != null) {
                contentType = contentType + ";charset=" + encoding;
            }

            VelocityManager velocityManager = VelocityManager.getInstance();
            Template t = getTemplate(stack, velocityManager.getVelocityEngine(), invocation, finalLocation, encoding);

            Context context = createContext(velocityManager, stack, request, response, finalLocation);
            Writer writer = new OutputStreamWriter(response.getOutputStream(), encoding);


            response.setContentType(contentType);

            t.merge(context, writer);

            // always flush the writer (we used to only flush it if this was a jspWriter, but someone asked
            // to do it all the time (WW-829). Since Velocity support is being deprecated, we'll oblige :)
            writer.flush();
        } catch (Exception e) {
            log.error("Unable to render Velocity Template, '" + finalLocation + "'", e);
            throw e;
        } finally {
            if (usedJspFactory) {
                jspFactory.releasePageContext(pageContext);
            }
        }

        return;
    }

    /**
     * Retrieve the content type for this template.
     * <p/>
     * People can override this method if they want to provide specific content types for specific templates (eg text/xml).
     *
     * @return The content type associated with this template (default "text/html")
     */
    protected String getContentType(String templateLocation) {
        return "text/html";
    }

    /**
     * Retrieve the encoding for this template.
     * <p/>
     * People can override this method if they want to provide specific encodings for specific templates.
     *
     * @return The encoding associated with this template (defaults to the value of 'struts.i18n.encoding' property)
     */
    protected String getEncoding(String templateLocation) {
        String encoding = (String) Settings.get(StrutsConstants.STRUTS_I18N_ENCODING);
        if (encoding == null) {
            encoding = System.getProperty("file.encoding");
        }
        if (encoding == null) {
            encoding = "UTF-8";
        }
        return encoding;
    }

    /**
     * Given a value stack, a Velocity engine, and an action invocation, this method returns the appropriate
     * Velocity template to render.
     *
     * @param stack      the value stack to resolve the location again (when parse equals true)
     * @param velocity   the velocity engine to process the request against
     * @param invocation an encapsulation of the action execution state.
     * @param location   the location of the template
     * @param encoding   the charset encoding of the template
     * @return the template to render
     * @throws Exception when the requested template could not be found
     */
    protected Template getTemplate(OgnlValueStack stack, VelocityEngine velocity, ActionInvocation invocation, String location, String encoding) throws Exception {
        if (!location.startsWith("/")) {
            location = invocation.getProxy().getNamespace() + "/" + location;
        }

        Template template = velocity.getTemplate(location, encoding);

        return template;
    }

    /**
     * Creates the VelocityContext that we'll use to render this page.
     *
     * @param velocityManager a reference to the velocityManager to use
     * @param stack           the value stack to resolve the location against (when parse equals true)
     * @param location        the name of the template that is being used
     * @return the a minted Velocity context.
     */
    protected Context createContext(VelocityManager velocityManager, OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response, String location) {
        return velocityManager.createContext(stack, request, response);
    }
}
"
core/src/main/java/org/apache/struts2/dispatcher/mapper/ActionMapper.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher.mapper;

import javax.servlet.http.HttpServletRequest;

import com.opensymphony.xwork2.config.Configuration;

/**
 * <!-- START SNIPPET: javadoc -->
 *
 * The ActionMapper is responsible for providing a mapping between HTTP requests and action invocation requests and
 * vice-versa. When given an HttpServletRequest, the ActionMapper may return null if no action invocation request maps,
 * or it may return an {@link ActionMapping} that describes an action invocation that Struts should attempt to try. The
 * ActionMapper is not required to guarantee that the {@link ActionMapping} returned be a real action or otherwise
 * ensure a valid request. This means that most ActionMappers do not need to consult the Struts configuration to
 * determine if a request should be mapped.
 *
 * <p/> Just as requests can be mapped from HTTP to an action invocation, the opposite is true as well. However, because
 * HTTP requests (when shown in HTTP responses) must be in String form, a String is returned rather than an actual
 * request object.
 *
 * <!-- END SNIPPET: javadoc -->
 */
public interface ActionMapper {
    
    /**
     * Gets an action mapping for the current request
     * 
     * @param request The servlet request
     * @param config The current configuration
     * @return The appropriate action mapping
     */
    ActionMapping getMapping(HttpServletRequest request, Configuration config);

    /**
     * Converts an ActionMapping into a URI string
     * 
     * @param mapping The action mapping
     * @return The URI string that represents this mapping
     */
    String getUriFromActionMapping(ActionMapping mapping);
}
"
core/src/main/java/org/apache/struts2/dispatcher/mapper/ActionMapperFactory.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher.mapper;

import java.util.HashMap;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.StrutsConstants;
import org.apache.struts2.StrutsException;
import org.apache.struts2.config.Settings;

import com.opensymphony.xwork2.ObjectFactory;

/**
 * <!-- START SNIPPET: javadoc -->
 *
 * Factory that creates {@link ActionMapper}s. This factory looks up the class name of the {@link ActionMapper} from
 * Struts's configuration using the key <b>struts.mapper.class</b>.
 *
 * <!-- END SNIPPET: javadoc -->
 *
 */
public class ActionMapperFactory {
    protected static final Log LOG = LogFactory.getLog(ActionMapperFactory.class);

    private static final HashMap<String,ActionMapper> classMap = new HashMap<String,ActionMapper>();

    /**
     * Gets an instance of the ActionMapper
     * 
     * @return The action mapper
     */
    public static ActionMapper getMapper() {
        synchronized (classMap) {
            String clazz = (String) Settings.get(StrutsConstants.STRUTS_MAPPER_CLASS);
            try {
                ActionMapper mapper = (ActionMapper) classMap.get(clazz);
                if (mapper == null) {
                    mapper = (ActionMapper) ObjectFactory.getObjectFactory().buildBean(clazz, null);
                    classMap.put(clazz, mapper);
                }

                return mapper;
            } catch (Exception e) {
                String msg = "Could not create ActionMapper: Struts will *not* work!";
                throw new StrutsException(msg, e);
            }
        }
    }
}
"
core/src/main/java/org/apache/struts2/dispatcher/mapper/ActionMapping.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher.mapper;

import java.util.Map;

import com.opensymphony.xwork2.Result;

/**
 * Simple class that holds the action mapping information used to invoke a
 * Struts action. The name and namespace are required, but the params map
 * is optional, and as such may be null. If a params map is supplied,
 * it <b>must</b> be a mutable map, such as a HashMap.
 *
 */
public class ActionMapping {

    private String name;
    private String namespace;
    private String method;
    private Map params;
    private Result result;

    /**
     * Constructs an ActionMapping
     */
    public ActionMapping() {}

    /**
     * Constructs an ActionMapping with a default result
     * 
     * @param result The default result
     */
    public ActionMapping(Result result) {
        this.result = result;
    }

    /**
     * Constructs an ActionMapping with its values
     * 
     * @param name The action name
     * @param namespace The action namespace
     * @param method The method
     * @param params The extra parameters
     */
    public ActionMapping(String name, String namespace, String method, Map params) {
        this.name = name;
        this.namespace = namespace;
        this.method = method;
        this.params = params;
    }

    /**
     * @return The action name
     */
    public String getName() {
        return name;
    }

    /**
     * @return The action namespace
     */
    public String getNamespace() {
        return namespace;
    }

    /**
     * @return The extra parameters
     */
    public Map getParams() {
        return params;
    }

    /**
     * @return The method
     */
    public String getMethod() {
        if (null != method && "".equals(method)) {
            return null;
        } else {
            return method;
        }
    }

    /**
     * @return The default result
     */
    public Result getResult() {
        return result;
    }

    /**
     * @param result The result
     */
    public void setResult(Result result) {
        this.result = result;
    }

    /**
     * @param name The action name
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * @param namespace The action namespace
     */
    public void setNamespace(String namespace) {
        this.namespace = namespace;
    }

    /**
     * @param method The method name to call on the action
     */
    public void setMethod(String method) {
        this.method = method;
    }

    /**
     * @param params The extra parameters for this mapping
     */
    public void setParams(Map params) {
        this.params = params;
    }
}
"
core/src/main/java/org/apache/struts2/dispatcher/mapper/DefaultActionMapper.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher.mapper;

import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;

import org.apache.struts2.RequestUtils;
import org.apache.struts2.StrutsConstants;
import org.apache.struts2.config.Settings;
import org.apache.struts2.dispatcher.ServletRedirectResult;
import org.apache.struts2.util.PrefixTrie;

import com.opensymphony.xwork2.config.Configuration;
import com.opensymphony.xwork2.config.entities.PackageConfig;

/**
 * <!-- START SNIPPET: javadoc -->
 *
 * Default action mapper implementation, using the standard *.[ext] (where ext usually "action") pattern. The extension
 * is looked up from the Struts configuration key <b>struts.action.exection</b>.
 *
 * <p/> To help with dealing with buttons and other related requirements, this mapper (and other {@link ActionMapper}s,
 * we hope) has the ability to name a button with some predefined prefix and have that button name alter the execution
 * behaviour. The four prefixes are:
 *
 * <ul>
 *
 * <li>Method prefix - <i>method:default</i></li>
 *
 * <li>Action prefix - <i>action:dashboard</i></li>
 *
 * <li>Redirect prefix - <i>redirect:cancel.jsp</i></li>
 *
 * <li>Redirect-action prefix - <i>redirect-action:cancel</i></li>
 *
 * </ul>
 *
 * <p/> In addition to these four prefixes, this mapper also understands the action naming pattern of <i>foo!bar</i> in
 * either the extension form (eg: foo!bar.action) or in the prefix form (eg: action:foo!bar). This syntax tells this mapper
 * to map to the action named <i>foo</i> and the method <i>bar</i>.
 *
 * <!-- END SNIPPET: javadoc -->
 *
 * <p/> <b>Method Prefix</b> <p/>
 *
 * <!-- START SNIPPET: method -->
 *
 * With method-prefix, instead of calling baz action's execute() method (by default if it isn't overriden in struts.xml
 * to be something else), the baz action's anotherMethod() will be called. A very elegant way determine which button is
 * clicked. Alternatively, one would have submit button set a particular value on the action when clicked, and the
 * execute() method decides on what to do with the setted value depending on which button is clicked.
 *
 * <!-- END SNIPPET: method -->
 *
 * <pre>
 * <!-- START SNIPPET: method-example -->
 * &lt;a:form action="baz"&gt;
 *     &lt;a:textfield label="Enter your name" name="person.name"/&gt;
 *     &lt;a:submit value="Create person"/&gt;
 *     &lt;a:submit name="method:anotherMethod" value="Cancel"/&gt;
 * &lt;/a:form&gt;
 * <!-- END SNIPPET: method-example -->
 * </pre>
 *
 * <p/> <b>Action prefix</b> <p/>
 *
 * <!-- START SNIPPET: action -->
 *
 * With action-prefix, instead of executing baz action's execute() method (by default if it isn't overriden in struts.xml
 * to be something else), the anotherAction action's execute() method (assuming again if it isn't overriden with
 * something else in struts.xml) will be executed.
 *
 * <!-- END SNIPPET: action -->
 *
 * <pre>
 * <!-- START SNIPPET: action-example -->
 * &lt;a:form action="baz"&gt;
 *     &lt;a:textfield label="Enter your name" name="person.name"/&gt;
 *     &lt;a:submit value="Create person"/&gt;
 *     &lt;a:submit name="action:anotherAction" value="Cancel"/&gt;
 * &lt;/a:form&gt;
 * <!-- END SNIPPET: action-example -->
 * </pre>
 *
 * <p/> <b>Redirect prefix</b> <p/>
 *
 * <!-- START SNIPPET: redirect -->
 *
 * With redirect-prefix, instead of executing baz action's execute() method (by default it isn't overriden in struts.xml
 * to be something else), it will get redirected to, in this case to www.google.com. Internally it uses
 * ServletRedirectResult to do the task.
 *
 * <!-- END SNIPPET: redirect -->
 *
 * <pre>
 * <!-- START SNIPPET: redirect-example -->
 * &lt;a:form action="baz"&gt;
 *     &lt;a:textfield label="Enter your name" name="person.name"/&gt;
 *     &lt;a:submit value="Create person"/&gt;
 *     &lt;a:submit name="redirect:www.google.com" value="Cancel"/&gt;
 * &lt;/a:form&gt;
 * <!-- END SNIPPET: redirect-example -->
 * </pre>
 *
 * <p/> <b>Redirect-action prefix</b> <p/>
 *
 * <!-- START SNIPPET: redirect-action -->
 *
 * With redirect-action-prefix, instead of executing baz action's execute() method (by default it isn't overriden in
 * struts.xml to be something else), it will get redirected to, in this case 'dashboard.action'. Internally it uses
 * ServletRedirectResult to do the task and read off the extension from the struts.properties.
 *
 * <!-- END SNIPPET: redirect-action -->
 *
 * <pre>
 * <!-- START SNIPPET: redirect-action-example -->
 * &lt;a:form action="baz"&gt;
 *     &lt;a:textfield label="Enter your name" name="person.name"/&gt;
 *     &lt;a:submit value="Create person"/&gt;
 *     &lt;a:submit name="redirect-action:dashboard" value="Cancel"/&gt;
 * &lt;/a:form&gt;
 * <!-- END SNIPPET: redirect-action-example -->
 * </pre>
 *
 */
public class DefaultActionMapper implements ActionMapper {

    static final String METHOD_PREFIX = "method:";
    static final String ACTION_PREFIX = "action:";
    static final String REDIRECT_PREFIX = "redirect:";
    static final String REDIRECT_ACTION_PREFIX = "redirect-action:";

    private static boolean allowDynamicMethodCalls = "true".equals(Settings.get(StrutsConstants.STRUTS_ENABLE_DYNAMIC_METHOD_INVOCATION));

    private PrefixTrie prefixTrie = null;
    public DefaultActionMapper() {
        prefixTrie = new PrefixTrie() {
            {
                put(METHOD_PREFIX, new ParameterAction() {
                    public void execute(String key, ActionMapping mapping) {
                        mapping.setMethod(key.substring(METHOD_PREFIX.length()));
                    }
                });

                put(ACTION_PREFIX, new ParameterAction() {
                    public void execute(String key, ActionMapping mapping) {
                        String name = key.substring(ACTION_PREFIX.length());
                        if (allowDynamicMethodCalls) {
                            int bang = name.indexOf('!');
                            if (bang != -1) {
                                String method = name.substring(bang + 1);
                                mapping.setMethod(method);
                                name = name.substring(0, bang);
                            }
                        }
                        mapping.setName(name);
                    }
                });

                put(REDIRECT_PREFIX, new ParameterAction() {
                    public void execute(String key, ActionMapping mapping) {
                        ServletRedirectResult redirect = new ServletRedirectResult();
                        redirect.setLocation(key.substring(REDIRECT_PREFIX.length()));
                        mapping.setResult(redirect);
                    }
                });
    
                put(REDIRECT_ACTION_PREFIX, new ParameterAction() {
                    public void execute(String key, ActionMapping mapping) {
                        String location = key.substring(REDIRECT_ACTION_PREFIX.length());
                        ServletRedirectResult redirect = new ServletRedirectResult();
                        String extension = getDefaultExtension();
                        if (extension != null) {
                            location += "." + extension;
                        }
                        redirect.setLocation(location);
                        mapping.setResult(redirect);
                    }
                });
            }
        };
    }

    /* (non-Javadoc)
     * @see org.apache.struts2.dispatcher.mapper.ActionMapper#getMapping(javax.servlet.http.HttpServletRequest)
     */
    public ActionMapping getMapping(HttpServletRequest request, Configuration config) {
        ActionMapping mapping = new ActionMapping();
        String uri = getUri(request);

        parseNameAndNamespace(uri, mapping, config);

        handleSpecialParameters(request, mapping);

        if (mapping.getName() == null) {
            return null;
        }

        if (allowDynamicMethodCalls) {
            // handle "name!method" convention.
            String name = mapping.getName();
            int exclamation = name.lastIndexOf("!");
            if (exclamation != -1) {
                mapping.setName(name.substring(0, exclamation));
                mapping.setMethod(name.substring(exclamation + 1));
            }
        }

        return mapping;
    }

    /**
     * Special parameters, as described in the class-level comment, are searched for
     * and handled.
     * 
     * @param request The request
     * @param mapping The action mapping
     */
    public void handleSpecialParameters(HttpServletRequest request, ActionMapping mapping) {
        // handle special parameter prefixes.
        Map parameterMap = request.getParameterMap();
        for (Iterator iterator = parameterMap.keySet().iterator(); iterator.hasNext();) {
            String key = (String) iterator.next();
            ParameterAction parameterAction = (ParameterAction) prefixTrie.get(key);
            if (parameterAction != null) {
                parameterAction.execute(key, mapping);
                break;
            }
        }
    }

    /**
     * Parses the name and namespace from the uri
     * 
     * @param uri The uri
     * @param mapping The action mapping to populate
     */
    void parseNameAndNamespace(String uri, ActionMapping mapping, Configuration config) {
        String namespace, name;
        int lastSlash = uri.lastIndexOf("/");
        if (lastSlash == -1) {
            namespace = "";
            name = uri;
        } else if (lastSlash == 0) {
            // ww-1046, assume it is the root namespace, it will fallback to default
            // namespace anyway if not found in root namespace.
            namespace = "/";
            name = uri.substring(lastSlash + 1);
        } else {
            String prefix = uri.substring(0, lastSlash);
            namespace = "";
            // Find the longest matching namespace, defaulting to the default
            for (Iterator i = config.getPackageConfigs().values().iterator(); i.hasNext(); ) {
                String ns = ((PackageConfig)i.next()).getNamespace();
                if (ns != null && prefix.startsWith(ns)) {
                    if (ns.length() > namespace.length()) {
                        namespace = ns;
                    }
                }
            }
            
            name = uri.substring(namespace.length() + 1);
        }
        mapping.setNamespace(namespace);
        mapping.setName(dropExtension(name));
    }

    /**
     * Drops the extension from the action name
     * 
     * @param name The action name
     * @return The action name without its extension
     */
    String dropExtension(String name) {
    		List extensions = getExtensions();
		if (extensions == null) {
		    return name;
		}
        	Iterator it = extensions.iterator();
        	while (it.hasNext()) {
        		String extension = "." + (String) it.next();
        		if ( name.endsWith(extension)) {
        			name = name.substring(0, name.length() - extension.length());
        			return name;
        		}
        	}
        	return null;
    }

    /**
     * Returns null if no extension is specified.
     */
    static String getDefaultExtension() {
        List extensions = getExtensions();
        if (extensions == null) {
        	return null;
        } else {
        	return (String) extensions.get(0);
        }
    }
    
    /**
     * Returns null if no extension is specified.
     */
    static List getExtensions() {
        String extensions = (String) org.apache.struts2.config.Settings.get(StrutsConstants.STRUTS_ACTION_EXTENSION);

        if ("".equals(extensions)) {
        	return null;
        } else {
        	return Arrays.asList(extensions.split(","));        	
        } 
    }

    /**
     * Gets the uri from the request
     * 
     * @param request The request
     * @return The uri
     */
    String getUri(HttpServletRequest request) {
        // handle http dispatcher includes.
        String uri = (String) request.getAttribute("javax.servlet.include.servlet_path");
        if (uri != null) {
            return uri;
        }

        uri = RequestUtils.getServletPath(request);
        if (uri != null && !"".equals(uri)) {
            return uri;
        }

        uri = request.getRequestURI();
        return uri.substring(request.getContextPath().length());
    }

    /* (non-Javadoc)
     * @see org.apache.struts2.dispatcher.mapper.ActionMapper#getUriFromActionMapping(org.apache.struts2.dispatcher.mapper.ActionMapping)
     */
    public String getUriFromActionMapping(ActionMapping mapping) {
        StringBuffer uri = new StringBuffer();

        uri.append(mapping.getNamespace());
        if(!"/".equals(mapping.getNamespace())) {
            uri.append("/");
        }
        String name = mapping.getName();
        String params = "";
        if ( name.indexOf('?') != -1) {
            params = name.substring(name.indexOf('?'));
            name = name.substring(0, name.indexOf('?'));
        }
        uri.append(name);

        if (null != mapping.getMethod() && !"".equals(mapping.getMethod())) {
            uri.append("!").append(mapping.getMethod());
        }

        String extension = getDefaultExtension();
        if ( extension != null) {
            if (uri.indexOf( '.' + extension) == -1  ) {
                uri.append(".").append(extension);
                if ( params.length() > 0) {
                    uri.append(params);
                }
            }
        }

        return uri.toString();
    }

    /**
     * Defines a parameter action prefix
     */
    interface ParameterAction {
        void execute(String key, ActionMapping mapping);
    }
}
"
core/src/main/java/org/apache/struts2/dispatcher/mapper/RestfulActionMapper.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher.mapper;

import java.net.URLDecoder;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.StringTokenizer;

import javax.servlet.http.HttpServletRequest;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.RequestUtils;

import com.opensymphony.xwork2.config.Configuration;

/**
 * A custom action mapper using the following format:
 * <p/>
 * <p/>
 * <ul><tt>http://HOST/ACTION_NAME/PARAM_NAME1/PARAM_VALUE1/PARAM_NAME2/PARAM_VALUE2</tt></ul>
 * <p/>
 * You can have as many parameters you'd like to use. Alternatively the URL can be shortened to the following:
 * <p/>
 * <ul><tt>http://HOST/ACTION_NAME/PARAM_VALUE1/PARAM_NAME2/PARAM_VALUE2</tt></ul>
 * <p/>
 * This is the same as:
 * <p/>
 * <ul><tt>http://HOST/ACTION_NAME/ACTION_NAME + "Id"/PARAM_VALUE1/PARAM_NAME2/PARAM_VALUE2</tt></ul>
 * <p/>
 * Suppose for example we would like to display some articles by id at using the following URL sheme:
 * <p/>
 * <ul><tt>http://HOST/article/Id</tt></ul>
 * <p/>
 * <p/>
 * Your action just needs a setArticleId() method, and requests such as /article/1, /article/2, etc will all map
 * to that URL pattern.
 *
 */
public class RestfulActionMapper implements ActionMapper {
    protected static final Log LOG = LogFactory.getLog(RestfulActionMapper.class);

    /* (non-Javadoc)
     * @see org.apache.struts2.dispatcher.mapper.ActionMapper#getMapping(javax.servlet.http.HttpServletRequest)
     */
    public ActionMapping getMapping(HttpServletRequest request, Configuration config) {
        String uri = RequestUtils.getServletPath(request);

        int nextSlash = uri.indexOf('/', 1);
        if (nextSlash == -1) {
            return null;
        }

        String actionName = uri.substring(1, nextSlash);
        HashMap<String,String> parameters = new HashMap<String,String>();
        try {
            StringTokenizer st = new StringTokenizer(uri.substring(nextSlash), "/");
            boolean isNameTok = true;
            String paramName = null;
            String paramValue;

            // check if we have the first parameter name
            if ((st.countTokens() % 2) != 0) {
                isNameTok = false;
                paramName = actionName + "Id";
            }

            while (st.hasMoreTokens()) {
                if (isNameTok) {
                    paramName = URLDecoder.decode(st.nextToken(), "UTF-8");
                    isNameTok = false;
                } else {
                    paramValue = URLDecoder.decode(st.nextToken(), "UTF-8");

                    if ((paramName != null) && (paramName.length() > 0)) {
                        parameters.put(paramName, paramValue);
                    }

                    isNameTok = true;
                }
            }
        } catch (Exception e) {
            LOG.warn(e);
        }

        return new ActionMapping(actionName, "", "", parameters);
    }

    /* (non-Javadoc)
     * @see org.apache.struts2.dispatcher.mapper.ActionMapper#getUriFromActionMapping(org.apache.struts2.dispatcher.mapper.ActionMapping)
     */
    public String getUriFromActionMapping(ActionMapping mapping) {
        String base = mapping.getNamespace() + mapping.getName();
        for (Iterator iterator = mapping.getParams().entrySet().iterator(); iterator.hasNext();) {
            Map.Entry entry = (Map.Entry) iterator.next();
            String name = (String) entry.getKey();
            if (name.equals(mapping.getName() + "Id")) {
                base = base + "/" + entry.getValue();
                break;
            }
        }

        return base;
    }
}
"
core/src/main/java/org/apache/struts2/dispatcher/multipart/JakartaMultiPartRequest.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher.multipart;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;

import org.apache.commons.fileupload.FileItem;
import org.apache.commons.fileupload.FileUploadException;
import org.apache.commons.fileupload.RequestContext;
import org.apache.commons.fileupload.disk.DiskFileItem;
import org.apache.commons.fileupload.disk.DiskFileItemFactory;
import org.apache.commons.fileupload.servlet.ServletFileUpload;

/**
 * Multipart form data request adapter for Jakarta Commons Fileupload package.
 *
 */
public class JakartaMultiPartRequest extends MultiPartRequest {
    // maps parameter name -> List of FileItem objects
    private Map<String,List<FileItem>> files = new HashMap<String,List<FileItem>>();
    // maps parameter name -> List of param values
    private Map<String,List<String>> params = new HashMap<String,List<String>>();
    // any errors while processing this request
    private List<String> errors = new ArrayList<String>();

    /**
     * Creates a new request wrapper to handle multi-part data using methods adapted from Jason Pell's
     * multipart classes (see class description).
     *
     * @param maxSize        maximum size post allowed
     * @param saveDir        the directory to save off the file
     * @param servletRequest the request containing the multipart
     * @throws java.io.IOException  is thrown if encoding fails.
     */
    public JakartaMultiPartRequest(HttpServletRequest servletRequest, String saveDir, int maxSize)
            throws IOException {
        DiskFileItemFactory fac = new DiskFileItemFactory();
        fac.setSizeThreshold(0);
        if (saveDir != null) {
            fac.setRepository(new File(saveDir));
        }

        // Parse the request
        try {
            ServletFileUpload upload = new ServletFileUpload(fac);
            List items = upload.parseRequest(createRequestContext(servletRequest));

            for (int i = 0; i < items.size(); i++) {
                FileItem item = (FileItem) items.get(i);
                if (log.isDebugEnabled()) log.debug("Found item " + item.getFieldName());
                if (item.isFormField()) {
                    log.debug("Item is a normal form field");
                    List<String> values;
                    if (params.get(item.getFieldName()) != null) {
                        values = params.get(item.getFieldName());
                    } else {
                        values = new ArrayList<String>();
                    }

                    // note: see http://jira.opensymphony.com/browse/WW-633
                    // basically, in some cases the charset may be null, so
                    // we're just going to try to "other" method (no idea if this
                    // will work)
                    String charset = servletRequest.getCharacterEncoding();
                    if (charset != null) {
                        values.add(item.getString(charset));
                    } else {
                        values.add(item.getString());
                    }
                    params.put(item.getFieldName(), values);
                } else {
                    log.debug("Item is a file upload");

                    List<FileItem> values;
                    if (files.get(item.getFieldName()) != null) {
                        values = files.get(item.getFieldName());
                    } else {
                        values = new ArrayList<FileItem>();
                    }

                    values.add(item);
                    files.put(item.getFieldName(), values);
                }
            }
        } catch (FileUploadException e) {
            log.error(e);
            errors.add(e.getMessage());
        }
    }

    /* (non-Javadoc)
     * @see org.apache.struts2.dispatcher.multipart.MultiPartRequest#getFileParameterNames()
     */
    public Enumeration<String> getFileParameterNames() {
        return Collections.enumeration(files.keySet());
    }

    /* (non-Javadoc)
     * @see org.apache.struts2.dispatcher.multipart.MultiPartRequest#getContentType(java.lang.String)
     */
    public String[] getContentType(String fieldName) {
        List items = (List) files.get(fieldName);

        if (items == null) {
            return null;
        }

        List<String> contentTypes = new ArrayList<String>(items.size());
        for (int i = 0; i < items.size(); i++) {
            FileItem fileItem = (FileItem) items.get(i);
            contentTypes.add(fileItem.getContentType());
        }

        return (String[]) contentTypes.toArray(new String[contentTypes.size()]);
    }

    /* (non-Javadoc)
     * @see org.apache.struts2.dispatcher.multipart.MultiPartRequest#getFile(java.lang.String)
     */
    public File[] getFile(String fieldName) {
        List items = (List) files.get(fieldName);

        if (items == null) {
            return null;
        }

        List<File> fileList = new ArrayList<File>(items.size());
        for (int i = 0; i < items.size(); i++) {
            DiskFileItem fileItem = (DiskFileItem) items.get(i);
            fileList.add(fileItem.getStoreLocation());
        }

        return (File[]) fileList.toArray(new File[fileList.size()]);
    }

    /* (non-Javadoc)
     * @see org.apache.struts2.dispatcher.multipart.MultiPartRequest#getFileNames(java.lang.String)
     */
    public String[] getFileNames(String fieldName) {
        List<FileItem> items = files.get(fieldName);

        if (items == null) {
            return null;
        }

        List<String> fileNames = new ArrayList<String>(items.size());
        for (int i = 0; i < items.size(); i++) {
            DiskFileItem fileItem = (DiskFileItem) items.get(i);
            fileNames.add(getCanonicalName(fileItem.getName()));
        }

        return (String[]) fileNames.toArray(new String[fileNames.size()]);
    }

    /* (non-Javadoc)
     * @see org.apache.struts2.dispatcher.multipart.MultiPartRequest#getFilesystemName(java.lang.String)
     */
    public String[] getFilesystemName(String fieldName) {
        List items = (List) files.get(fieldName);

        if (items == null) {
            return null;
        }

        List<String> fileNames = new ArrayList<String>(items.size());
        for (int i = 0; i < items.size(); i++) {
            DiskFileItem fileItem = (DiskFileItem) items.get(i);
            fileNames.add(fileItem.getStoreLocation().getName());
        }

        return (String[]) fileNames.toArray(new String[fileNames.size()]);
    }

    /* (non-Javadoc)
     * @see org.apache.struts2.dispatcher.multipart.MultiPartRequest#getParameter(java.lang.String)
     */
    public String getParameter(String name) {
        List v = (List) params.get(name);
        if (v != null && v.size() > 0) {
            return (String) v.get(0);
        }

        return null;
    }

    /* (non-Javadoc)
     * @see org.apache.struts2.dispatcher.multipart.MultiPartRequest#getParameterNames()
     */
    public Enumeration<String> getParameterNames() {
        return Collections.enumeration(params.keySet());
    }

    /* (non-Javadoc)
     * @see org.apache.struts2.dispatcher.multipart.MultiPartRequest#getParameterValues(java.lang.String)
     */
    public String[] getParameterValues(String name) {
        List<String> v = params.get(name);
        if (v != null && v.size() > 0) {
            return (String[]) v.toArray(new String[v.size()]);
        }

        return null;
    }

    /* (non-Javadoc)
     * @see org.apache.struts2.dispatcher.multipart.MultiPartRequest#getErrors()
     */
    public List getErrors() {
        return errors;
    }

    /**
     * Returns the canonical name of the given file.
     *
     * @param filename  the given file
     * @return the canonical name of the given file
     */
    private String getCanonicalName(String filename) {
        int forwardSlash = filename.lastIndexOf("/");
        int backwardSlash = filename.lastIndexOf("\\");
        if (forwardSlash != -1 && forwardSlash > backwardSlash) {
            filename = filename.substring(forwardSlash + 1, filename.length());
        } else if (backwardSlash != -1 && backwardSlash >= forwardSlash) {
            filename = filename.substring(backwardSlash + 1, filename.length());
        }

        return filename;
    }

    /**
     * Creates a RequestContext needed by Jakarta Commons Upload.
     *
     * @param req  the request.
     * @return a new request context.
     */
    private RequestContext createRequestContext(final HttpServletRequest req) {
        return new RequestContext() {
            public String getCharacterEncoding() {
                return req.getCharacterEncoding();
            }

            public String getContentType() {
                return req.getContentType();
            }

            public int getContentLength() {
                return req.getContentLength();
            }

            public InputStream getInputStream() throws IOException {
                return req.getInputStream();
            }
        };
    }

}
"
core/src/main/java/org/apache/struts2/dispatcher/multipart/MultiPartRequest.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher.multipart;

import java.io.File;
import java.util.Enumeration;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;


/**
 * Abstract wrapper class HTTP requests to handle multi-part data. <p>
 *
 */
public abstract class MultiPartRequest {

    protected static Log log = LogFactory.getLog(MultiPartRequest.class);


    /**
     * Returns <tt>true</tt> if the request is multipart form data, <tt>false</tt> otherwise.
     *
     * @param request the http servlet request.
     * @return <tt>true</tt> if the request is multipart form data, <tt>false</tt> otherwise.
     */
    public static boolean isMultiPart(HttpServletRequest request) {
        String content_type = request.getContentType();
        return content_type != null && content_type.indexOf("multipart/form-data") != -1;
    }

    /**
     * Returns an enumeration of the parameter names for uploaded files
     *
     * @return an enumeration of the parameter names for uploaded files
     */
    public abstract Enumeration<String> getFileParameterNames();

    /**
     * Returns the content type(s) of the file(s) associated with the specified field name
     * (as supplied by the client browser), or <tt>null</tt> if no files are associated with the
     * given field name.
     *
     * @param fieldName input field name
     * @return an array of content encoding for the specified input field name or <tt>null</tt> if
     *         no content type was specified.
     */
    public abstract String[] getContentType(String fieldName);

    /**
     * Returns a {@link java.io.File} object for the filename specified or <tt>null</tt> if no files
     * are associated with the given field name.
     *
     * @param fieldName input field name
     * @return a File[] object for files associated with the specified input field name
     */
    public abstract File[] getFile(String fieldName);

    /**
     * Returns a String[] of file names for files associated with the specified input field name
     *
     * @param fieldName input field name
     * @return a String[] of file names for files associated with the specified input field name
     */
    public abstract String[] getFileNames(String fieldName);

    /**
     * Returns the file system name(s) of files associated with the given field name or
     * <tt>null</tt> if no files are associated with the given field name.
     *
     * @param fieldName input field name
     * @return the file system name(s) of files associated with the given field name
     */
    public abstract String[] getFilesystemName(String fieldName);

    /**
     * Returns the specified request parameter.
     *
     * @param name the name of the parameter to get
     * @return the parameter or <tt>null</tt> if it was not found.
     */
    public abstract String getParameter(String name);

    /**
     * Returns an enumeration of String parameter names.
     *
     * @return an enumeration of String parameter names.
     */
    public abstract Enumeration<String> getParameterNames();

    /**
     * Returns a list of all parameter values associated with a parameter name. If there is only
     * one parameter value per name the resulting array will be of length 1.
     *
     * @param name the name of the parameter.
     * @return an array of all values associated with the parameter name.
     */
    public abstract String[] getParameterValues(String name);

    /**
     * Returns a list of error messages that may have occurred while processing the request.
     * If there are no errors, an empty list is returned. If the underlying implementation
     * (ie: pell, cos, jakarta, etc) cannot support providing these errors, an empty list is
     * also returned. This list of errors is repoted back to the
     * {@link MultiPartRequestWrapper}'s errors field.
     *
     * @return a list of Strings that represent various errors during parsing
     */
    public abstract List getErrors();
}
"
core/src/main/java/org/apache/struts2/dispatcher/multipart/MultiPartRequestWrapper.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher.multipart;

import java.io.File;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Vector;

import javax.servlet.http.HttpServletRequest;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.StrutsConstants;
import org.apache.struts2.config.Settings;
import org.apache.struts2.dispatcher.StrutsRequestWrapper;
import org.apache.struts2.util.ClassLoaderUtils;


/**
 * Parses a multipart request and provides a wrapper around the request. The parsing implementation used
 * depends on the <tt>struts.multipart.parser</tt> setting. It should be set to a class which
 * extends {@link org.apache.struts2.dispatcher.multipart.MultiPartRequest}. <p>
 * <p/>
 * Struts ships with three implementations,
 * {@link org.apache.struts2.dispatcher.multipart.PellMultiPartRequest}, and
 * {@link org.apache.struts2.dispatcher.multipart.CosMultiPartRequest} and
 * {@link org.apache.struts2.dispatcher.multipart.JakartaMultiPartRequest}. The Jakarta implementation
 * is the default. The <tt>struts.multipart.parser</tt> property should be set to <tt>jakarta</tt> for the
 * Jakarta implementation, <tt>pell</tt> for the Pell implementation and <tt>cos</tt> for the Jason Hunter
 * implementation. <p>
 * <p/>
 * The files are uploaded when the object is instantiated. If there are any errors they are logged using
 * {@link #addError(String)}. An action handling a multipart form should first check {@link #hasErrors()}
 * before doing any other processing. <p>
 *
 */
public class MultiPartRequestWrapper extends StrutsRequestWrapper {
    protected static final Log log = LogFactory.getLog(MultiPartRequestWrapper.class);

    Collection errors;
    MultiPartRequest multi;

    /**
     * Instantiates the appropriate MultiPartRequest parser implementation and processes the data.
     *
     * @param request the servlet request object
     * @param saveDir directory to save the file(s) to
     * @param maxSize maximum file size allowed
     */
    public MultiPartRequestWrapper(HttpServletRequest request, String saveDir, int maxSize) {
        super(request);

        if (request instanceof MultiPartRequest) {
            multi = (MultiPartRequest) request;
        } else {
            String parser = Settings.get(StrutsConstants.STRUTS_MULTIPART_PARSER);

            // If it's not set, use Jakarta
            if (parser.equals("")) {
                log.warn("Property struts.multipart.parser not set." +
                        " Using org.apache.struts2.dispatcher.multipart.JakartaMultiPartRequest");
                parser = "org.apache.struts2.dispatcher.multipart.JakartaMultiPartRequest";
            }
            // legacy support for old style property values
            else if (parser.equals("pell")) {
                parser = "org.apache.struts2.dispatcher.multipart.PellMultiPartRequest";
            } else if (parser.equals("cos")) {
                parser = "org.apache.struts2.dispatcher.multipart.CosMultiPartRequest";
            } else if (parser.equals("jakarta")) {
                parser = "org.apache.struts2.dispatcher.multipart.JakartaMultiPartRequest";
            }

            try {
                Class baseClazz = org.apache.struts2.dispatcher.multipart.MultiPartRequest.class;

                Class clazz = ClassLoaderUtils.loadClass(parser, MultiPartRequestWrapper.class);

                // make sure it extends MultiPartRequest
                if (!baseClazz.isAssignableFrom(clazz)) {
                    addError("Class '" + parser + "' does not extend MultiPartRequest");

                    return;
                }

                // get the constructor
                Constructor ctor = clazz.getDeclaredConstructor(new Class[]{
                        ClassLoaderUtils.loadClass("javax.servlet.http.HttpServletRequest", MultiPartRequestWrapper.class),
                        java.lang.String.class, int.class
                });

                // build the parameter list
                Object[] parms = new Object[]{
                        request, saveDir, new Integer(maxSize)
                };

                // instantiate it
                multi = (MultiPartRequest) ctor.newInstance(parms);
                for (Iterator iter = multi.getErrors().iterator(); iter.hasNext();) {
                    String error = (String) iter.next();
                    addError(error);
                }
            } catch (ClassNotFoundException e) {
                addError("Class: " + parser + " not found.");
            } catch (NoSuchMethodException e) {
                addError("Constructor error for " + parser + ": " + e);
            } catch (InstantiationException e) {
                addError("Error instantiating " + parser + ": " + e);
            } catch (IllegalAccessException e) {
                addError("Access errror for " + parser + ": " + e);
            } catch (InvocationTargetException e) {
                // This is a wrapper for any exceptions thrown by the constructor called from newInstance
                addError(e.getTargetException().toString());
            }
        }
    }

    /**
     * Get an enumeration of the parameter names for uploaded files
     *
     * @return enumeration of parameter names for uploaded files
     */
    public Enumeration<String> getFileParameterNames() {
        if (multi == null) {
            return null;
        }

        return multi.getFileParameterNames();
    }

    /**
     * Get an array of content encoding for the specified input field name or <tt>null</tt> if
     * no content type was specified.
     *
     * @param name input field name
     * @return an array of content encoding for the specified input field name
     */
    public String[] getContentTypes(String name) {
        if (multi == null) {
            return null;
        }

        return multi.getContentType(name);
    }

    /**
     * Get a {@link java.io.File[]} for the given input field name.
     *
     * @param fieldName input field name
     * @return a File[] object for files associated with the specified input field name
     */
    public File[] getFiles(String fieldName) {
        if (multi == null) {
            return null;
        }

        return multi.getFile(fieldName);
    }

    /**
     * Get a String array of the file names for uploaded files
     *
     * @return a String[] of file names for uploaded files
     */
    public String[] getFileNames(String fieldName) {
        if (multi == null) {
            return null;
        }

        return multi.getFileNames(fieldName);
    }

    /**
     * Get the filename(s) of the file(s) uploaded for the given input field name.
     * Returns <tt>null</tt> if the file is not found.
     *
     * @param fieldName input field name
     * @return the filename(s) of the file(s) uploaded for the given input field name or
     *         <tt>null</tt> if name not found.
     */
    public String[] getFileSystemNames(String fieldName) {
        if (multi == null) {
            return null;
        }

        return multi.getFilesystemName(fieldName);
    }

    /**
     * @see javax.servlet.http.HttpServletRequest#getParameter(String)
     */
    public String getParameter(String name) {
        return ((multi == null) || (multi.getParameter(name) == null)) ? super.getParameter(name) : multi.getParameter(name);
    }

    /**
     * @see javax.servlet.http.HttpServletRequest#getParameterMap()
     */
    public Map getParameterMap() {
        Map map = new HashMap();
        Enumeration enumeration = getParameterNames();

        while (enumeration.hasMoreElements()) {
            String name = (String) enumeration.nextElement();
            map.put(name, this.getParameterValues(name));
        }

        return map;
    }

    /**
     * @see javax.servlet.http.HttpServletRequest#getParameterNames()
     */
    public Enumeration getParameterNames() {
        if (multi == null) {
            return super.getParameterNames();
        } else {
            return mergeParams(multi.getParameterNames(), super.getParameterNames());
        }
    }

    /**
     * @see javax.servlet.http.HttpServletRequest#getParameterValues(String)
     */
    public String[] getParameterValues(String name) {
        return ((multi == null) || (multi.getParameterValues(name) == null)) ? super.getParameterValues(name) : multi.getParameterValues(name);
    }

    /**
     * Returns <tt>true</tt> if any errors occured when parsing the HTTP multipart request, <tt>false</tt> otherwise.
     *
     * @return <tt>true</tt> if any errors occured when parsing the HTTP multipart request, <tt>false</tt> otherwise.
     */
    public boolean hasErrors() {
        if ((errors == null) || errors.isEmpty()) {
            return false;
        } else {
            return true;
        }
    }

    /**
     * Returns a collection of any errors generated when parsing the multipart request.
     *
     * @return the error Collection.
     */
    public Collection getErrors() {
        return errors;
    }

    /**
     * Adds an error message.
     *
     * @param anErrorMessage the error message to report.
     */
    protected void addError(String anErrorMessage) {
        if (errors == null) {
            errors = new ArrayList();
        }

        errors.add(anErrorMessage);
    }

    /**
     * Merges 2 enumeration of parameters as one.
     *
     * @param params1 the first enumeration.
     * @param params2 the second enumeration.
     * @return a single Enumeration of all elements from both Enumerations.
     */
    protected Enumeration mergeParams(Enumeration params1, Enumeration params2) {
        Vector temp = new Vector();

        while (params1.hasMoreElements()) {
            temp.add(params1.nextElement());
        }

        while (params2.hasMoreElements()) {
            temp.add(params2.nextElement());
        }

        return temp.elements();
    }
}
"
core/src/main/java/org/apache/struts2/impl/ActionContextImpl.java,false,"// Copyright 2006 Google Inc. All Rights Reserved.

package org.apache.struts2.impl;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

import org.apache.struts2.spi.ActionContext;
import org.apache.struts2.spi.Result;

import com.opensymphony.xwork2.ActionInvocation;

public class ActionContextImpl implements ActionContext {

    final ActionInvocation invocation;

    public ActionContextImpl(ActionInvocation invocation) {
        this.invocation = invocation;
    }

    public Object getAction() {
        return invocation.getAction();
    }

    public Method getMethod() {
        String methodName = invocation.getProxy().getMethod();
        try {
            return getAction().getClass().getMethod(methodName);
        } catch (NoSuchMethodException e) {
            throw new RuntimeException(e);
        }
    }

    public String getActionName() {
        return invocation.getProxy().getActionName();
    }

    public String getNamespacePath() {
        return invocation.getProxy().getNamespace();
    }

    // TODO: Do something with these.
    List<Result> resultInterceptors = new ArrayList<Result>();

    public void addResultInterceptor(Result interceptor) {
        resultInterceptors.add(interceptor);
    }

    public Result getResult() {
        // TODO
        throw new UnsupportedOperationException();
    }

    public ActionContext getPrevious() {
        // TODO
        throw new UnsupportedOperationException();
    }

    public ActionContext getNext() {
        // TODO
        throw new UnsupportedOperationException();
    }
}
"
core/src/main/java/org/apache/struts2/impl/InterceptorAdapter.java,false,"// Copyright 2006 Google Inc. All Rights Reserved.

package org.apache.struts2.impl;

import static org.apache.struts2.impl.RequestContextImpl.ILLEGAL_PROCEED;

import java.util.concurrent.Callable;

import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.interceptor.Interceptor;

public class InterceptorAdapter implements Interceptor {

    private static final long serialVersionUID = 8020658947818231684L;
    final org.apache.struts2.spi.Interceptor delegate;

    public InterceptorAdapter(org.apache.struts2.spi.Interceptor delegate) {
        this.delegate = delegate;
    }

    public String intercept(final ActionInvocation invocation) throws Exception {
        final RequestContextImpl requestContext = RequestContextImpl.get();

        // Save the existing proceed implementation so we can restore it later.
        Callable<String> previous = requestContext.getProceed();

        requestContext.setProceed(new Callable<String>() {
            public String call() throws Exception {
                // This proceed implementation is no longer valid past this point.
                requestContext.setProceed(ILLEGAL_PROCEED);
                try {
                    return invocation.invoke();
                } finally {
                    // We're valid again.
                    requestContext.setProceed(this);
                }
            }
        });

        try {
            return delegate.intercept(requestContext);
        } finally {
            requestContext.setProceed(previous);
        }
    }

    public void destroy() {}
    public void init() {}
}
"
core/src/main/java/org/apache/struts2/impl/MessagesImpl.java,false,"// Copyright 2006 Google Inc. All Rights Reserved.

package org.apache.struts2.impl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.struts2.Messages;

import com.opensymphony.xwork2.DefaultTextProvider;
import com.opensymphony.xwork2.TextProvider;

public class MessagesImpl implements Messages {

    final TextProvider textProvider = DefaultTextProvider.INSTANCE;
    Map<String, Messages> fieldMap = new HashMap<String, Messages>();
    Map<Severity, List<String>> severityMap = new EnumMap<Severity, List<String>>(Severity.class);

    public Messages forField(String fieldName) {
        Messages forField = fieldMap.get(fieldName);
        if (forField == null) {
            forField = new MessagesImpl();
            fieldMap.put(fieldName, forField);
        }
        return forField;
    }

    public Map<String, Messages> forFields() {
        return fieldMap;
    }

    public void addInformation(String key) {
        forSeverity(Severity.INFO).add(textProvider.getText(key));
    }

    public void addInformation(String key, String... arguments) {
        forSeverity(Severity.INFO).add(textProvider.getText(key, arguments));
    }

    public void addWarning(String key) {
        forSeverity(Severity.WARN).add(textProvider.getText(key));
    }

    public void addWarning(String key, String... arguments) {
        forSeverity(Severity.WARN).add(textProvider.getText(key, arguments));
    }

    public void addError(String key) {
        forSeverity(Severity.ERROR).add(textProvider.getText(key));
    }

    public void addError(String key, String... arguments) {
        forSeverity(Severity.ERROR).add(textProvider.getText(key, arguments));
    }

    public void add(Severity severity, String key) {
        forSeverity(severity).add(textProvider.getText(key));
    }

    public void add(Severity severity, String key, String... arguments) {
        forSeverity(severity).add(textProvider.getText(key, arguments));
    }

    public Set<Severity> getSeverities() {
        Set<Severity> severities = EnumSet.noneOf(Severity.class);
        for (Severity severity : Severity.values()) {
            List<String> messages = severityMap.get(severity);
            if (messages != null && !messages.isEmpty()) {
                severities.add(severity);
            }
        }
        return Collections.unmodifiableSet(severities);
    }

    public List<String> forSeverity(Severity severity) {
        List<String> messages = severityMap.get(severity);
        if (messages == null) {
            messages = new ArrayList<String>();
            severityMap.put(severity, messages);
        }
        return messages;
    }

    public List<String> getErrors() {
        return forSeverity(Severity.ERROR);
    }

    public List<String> getWarnings() {
        return forSeverity(Severity.WARN);
    }

    public List<String> getInformation() {
        return forSeverity(Severity.INFO);
    }

    public boolean hasErrors() {
        return !isEmpty(Severity.ERROR);
    }

    public boolean hasWarnings() {
        return !isEmpty(Severity.WARN);
    }

    public boolean hasInformation() {
        return !isEmpty(Severity.INFO);
    }

    public boolean isEmpty() {
        for (Severity severity : Severity.values())
            if (!isEmpty(severity))
                return false;

        return true;
    }

    public boolean isEmpty(Severity severity) {
        List<String> messages = severityMap.get(severity);
        if (messages != null && !messages.isEmpty()) {
            return false;
        }

        for (Messages fieldMessages : fieldMap.values())
            if (!fieldMessages.isEmpty(severity))
                return false;

        return true;
    }
}
"
core/src/main/java/org/apache/struts2/impl/RequestContextImpl.java,true,"// Copyright 2006 Google Inc. All Rights Reserved.

package org.apache.struts2.impl;

import static org.apache.struts2.StrutsStatics.HTTP_REQUEST;
import static org.apache.struts2.StrutsStatics.HTTP_RESPONSE;
import static org.apache.struts2.StrutsStatics.SERVLET_CONTEXT;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;

import javax.servlet.ServletContext;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.Messages;
import org.apache.struts2.dispatcher.RequestMap;
import org.apache.struts2.spi.ActionContext;
import org.apache.struts2.spi.RequestContext;
import org.apache.struts2.spi.ValueStack;

import com.opensymphony.xwork2.ActionInvocation;

public class RequestContextImpl implements RequestContext {

    com.opensymphony.xwork2.ActionContext xworkContext;
    ActionContext actionContext;
    Messages messages = new MessagesImpl();

    public static final Callable<String> ILLEGAL_PROCEED = new Callable<String>() {
        public String call() throws Exception {
            throw new IllegalStateException();
        }
    };

    public RequestContextImpl(com.opensymphony.xwork2.ActionContext xworkContext) {
        this.xworkContext = xworkContext;
    }

    public ActionContext getActionContext() {
        return actionContext;
    }

    public Object getAction() {
        return getActionContext().getAction();
    }

    void setActionContext(ActionContext actionContext) {
        this.actionContext = actionContext;
    }

    public Map<String, String[]> getParameterMap() {
        return xworkContext.getParameters();
    }

    Map<String, Object> attributeMap;

    public Map<String, Object> getAttributeMap() {
        if (attributeMap == null) {
            attributeMap = new RequestMap(getServletRequest());
        }
        return attributeMap;
    }

    public Map<String, Object> getSessionMap() {
        return xworkContext.getSession();
    }

    public Map<String, Object> getApplicationMap() {
        return xworkContext.getApplication();
    }

    public List<Cookie> findCookiesForName(String name) {
        List<Cookie> cookies = new ArrayList<Cookie>();
        for (Cookie cookie : getServletRequest().getCookies())
            if (name.equals(cookie.getName()))
                cookies.add(cookie);

        return cookies;
   }

    public Locale getLocale() {
        return xworkContext.getLocale();
    }

    public void setLocale(Locale locale) {
        xworkContext.setLocale(locale);
    }

    public Messages getMessages() {
        return messages;
    }

    public HttpServletRequest getServletRequest() {
        return (HttpServletRequest) xworkContext.get(HTTP_REQUEST);
    }

    public HttpServletResponse getServletResponse() {
        return (HttpServletResponse) xworkContext.get(HTTP_RESPONSE);
    }

    public ServletContext getServletContext() {
        return (ServletContext) xworkContext.get(SERVLET_CONTEXT);
    }

    ValueStack valueStack;

    public ValueStack getValueStack() {
        if (valueStack == null) {
            valueStack = new ValueStackAdapter(xworkContext.getValueStack());
        }
        return valueStack;
    }

    Callable<String> proceed = ILLEGAL_PROCEED;

    public String proceed() throws Exception {
        return proceed.call();
    }

    public void setProceed(Callable<String> proceed) {
        this.proceed = proceed;
    }

    public Callable<String> getProceed() {
        return proceed;
    }

    static ThreadLocal<RequestContextImpl[]> threadLocalRequestContext = new ThreadLocal<RequestContextImpl[]>() {
        protected RequestContextImpl[] initialValue() {
            return new RequestContextImpl[1];
        }
    };

    /**
     * Creates RequestContext if necessary. Always creates a new ActionContext and restores an existing ActionContext
     * when finished.
     */
    public static String callInContext(ActionInvocation invocation, Callable<String> callable)
            throws Exception {
        RequestContextImpl[] reference = threadLocalRequestContext.get();

        if (reference[0] == null) {
            // Initial invocation.
            reference[0] = new RequestContextImpl(invocation.getInvocationContext());
            reference[0].setActionContext(new ActionContextImpl(invocation));
            try {
                return callable.call();
            } finally {
                reference[0] = null;
            }
        } else {
            // Nested invocation.
            RequestContextImpl requestContext = reference[0];
            ActionContext previous = requestContext.getActionContext();
            requestContext.setActionContext(new ActionContextImpl(invocation));
            try {
                return callable.call();
            } finally {
                requestContext.setActionContext(previous);
            }
        }
    }

    public static RequestContextImpl get() {
        RequestContextImpl requestContext = threadLocalRequestContext.get()[0];

        if (requestContext == null)
            throw new IllegalStateException("RequestContext has not been created.");

        return requestContext;
    }
}
"
core/src/main/java/org/apache/struts2/impl/ResultAdapter.java,false,"// Copyright 2006 Google Inc. All Rights Reserved.

package org.apache.struts2.impl;

import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.Result;

public class ResultAdapter implements Result {

    private static final long serialVersionUID = -5107033078266553554L;
    final org.apache.struts2.spi.Result delegate;

    public ResultAdapter(org.apache.struts2.spi.Result delegate) {
        this.delegate = delegate;
    }

    public void execute(ActionInvocation invocation) throws Exception {
        delegate.execute(RequestContextImpl.get());
    }
}
"
core/src/main/java/org/apache/struts2/impl/StrutsActionProxy.java,false,"// Copyright 2006 Google Inc. All Rights Reserved.

package org.apache.struts2.impl;

import java.util.Map;
import java.util.concurrent.Callable;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.DefaultActionProxy;
import com.opensymphony.xwork2.config.Configuration;

public class StrutsActionProxy extends DefaultActionProxy {

    private static final long serialVersionUID = -2434901249671934080L;

    public StrutsActionProxy(Configuration cfg, String namespace, String actionName, Map extraContext,
                             boolean executeResult, boolean cleanupContext) throws Exception {
        super(cfg, namespace, actionName, extraContext, executeResult, cleanupContext);
    }

    public String execute() throws Exception {
        ActionContext previous = ActionContext.getContext();
        ActionContext.setContext(invocation.getInvocationContext());
        try {
            return RequestContextImpl.callInContext(invocation, new Callable<String>() {
                public String call() throws Exception {
                    return invocation.invoke();
                }
            });
        } finally {
            if (cleanupContext)
                ActionContext.setContext(previous);
        }
    }
}
"
core/src/main/java/org/apache/struts2/impl/StrutsActionProxyFactory.java,true,"// Copyright 2006 Google Inc. All Rights Reserved.

package org.apache.struts2.impl;

import java.util.Map;

import com.opensymphony.xwork2.ActionProxy;
import com.opensymphony.xwork2.DefaultActionProxyFactory;
import com.opensymphony.xwork2.config.Configuration;

public class StrutsActionProxyFactory extends DefaultActionProxyFactory {

    public ActionProxy createActionProxy(Configuration config, String namespace, String actionName, Map extraContext)
            throws Exception {
        return new StrutsActionProxy(config, namespace, actionName, extraContext, true, true);
    }

    public ActionProxy createActionProxy(Configuration config, String namespace, String actionName, Map extraContext,
            boolean executeResult, boolean cleanupContext) throws Exception {
        return new StrutsActionProxy(config, namespace, actionName, extraContext, executeResult, cleanupContext);
    }
}
"
core/src/main/java/org/apache/struts2/impl/StrutsObjectFactory.java,true,"// Copyright 2006 Google Inc. All Rights Reserved.

package org.apache.struts2.impl;

import java.util.HashMap;
import java.util.Map;

import com.opensymphony.xwork2.ObjectFactory;
import com.opensymphony.xwork2.Result;
import com.opensymphony.xwork2.config.ConfigurationException;
import com.opensymphony.xwork2.config.entities.InterceptorConfig;
import com.opensymphony.xwork2.config.entities.ResultConfig;
import com.opensymphony.xwork2.interceptor.Interceptor;
import com.opensymphony.xwork2.util.OgnlUtil;

public class StrutsObjectFactory extends ObjectFactory {

    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map refParams)
            throws ConfigurationException {
        String className = interceptorConfig.getClassName();

        Map<String, String> params = new HashMap<String, String>();
        Map typeParams = interceptorConfig.getParams();
        if (typeParams != null && !typeParams.isEmpty())
            params.putAll(typeParams);
        if (refParams != null && !refParams.isEmpty())
            params.putAll(refParams);
        params.putAll(refParams);

        try {
            // interceptor instances are long-lived and used across user sessions, so don't try to pass in any extra
            // context
            Object o = buildBean(className, null);
            OgnlUtil.setProperties(params, o);

            if (o instanceof Interceptor) {
                Interceptor interceptor = (Interceptor) o;
                interceptor.init();
                return interceptor;
            }

            if (o instanceof org.apache.struts2.spi.Interceptor)
                return new InterceptorAdapter((org.apache.struts2.spi.Interceptor) o);

            throw new ConfigurationException(
                    "Class [" + className + "] does not implement Interceptor", interceptorConfig);
        } catch (InstantiationException e) {
            throw new ConfigurationException(
                    "Unable to instantiate an instance of Interceptor class [" + className + "].",
                    e, interceptorConfig);
        } catch (IllegalAccessException e) {
            throw new ConfigurationException(
                    "IllegalAccessException while attempting to instantiate an instance of Interceptor class ["
                            + className + "].",
                    e, interceptorConfig);
        } catch (Exception e) {
            throw new ConfigurationException(
                    "Caught Exception while registering Interceptor class " + className,
                    e, interceptorConfig);
        } catch (NoClassDefFoundError e) {
            throw new ConfigurationException(
                    "Could not load class " + className
                            + ". Perhaps it exists but certain dependencies are not available?",
                    e, interceptorConfig);
        }
    }

    public Result buildResult(ResultConfig resultConfig, Map extraContext) throws Exception {
        String resultClassName = resultConfig.getClassName();
        if (resultClassName == null)
            return null;

        Object result = buildBean(resultClassName, extraContext);
        OgnlUtil.setProperties(resultConfig.getParams(), result, extraContext);

        if (result instanceof Result)
            return (Result) result;

        if (result instanceof org.apache.struts2.spi.Result)
            return new ResultAdapter((org.apache.struts2.spi.Result) result);

        throw new ConfigurationException(result.getClass().getName() + " does not implement Result.");
    }
}
"
core/src/main/java/org/apache/struts2/impl/ValueStackAdapter.java,false,"// Copyright 2006 Google Inc. All Rights Reserved.

package org.apache.struts2.impl;

import java.util.Iterator;

import org.apache.struts2.spi.ValueStack;

import com.opensymphony.xwork2.util.OgnlValueStack;

public class ValueStackAdapter implements ValueStack {

    final OgnlValueStack delegate;

    public ValueStackAdapter(OgnlValueStack delegate) {
        this.delegate = delegate;
    }

    public Object peek() {
        return delegate.peek();
    }

    public Object pop() {
        return delegate.pop();
    }

    public void push(Object o) {
        delegate.push(o);
    }

    public ValueStack clone() {
        return new ValueStackAdapter(new OgnlValueStack(delegate));
    }

    public Object get(String expr) {
        return delegate.findValue(expr);
    }

    public <T> T get(String expr, Class<T> requiredType) {
        return (T) delegate.findValue(expr, requiredType);
    }

    public String getString(String expr) {
        return delegate.findString(expr);
    }

    public void set(String expr, Object o) {
        delegate.set(expr, o);
    }

    public int size() {
        return delegate.size();
    }

    public Iterator<Object> iterator() {
        return delegate.getRoot().iterator();
    }
}"
core/src/main/java/org/apache/struts2/interceptor/ApplicationAware.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.interceptor;

import java.util.Map;


/**
 * Actions that want to be aware of the application Map object should implement this interface.
 * This will give them access to a Map where they can put objects that should be available
 * to other parts of the application. <p>
 * <p/>
 * Typical uses are configuration objects and caches.
 *
 */
public interface ApplicationAware {

    /**
     * Sets the map of application properties in the implementing class.
     *
     * @param application a Map of application properties.
     */
    public void setApplication(Map application);
}
"
core/src/main/java/org/apache/struts2/interceptor/BackgroundProcess.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.interceptor;

import java.io.Serializable;

import com.opensymphony.xwork2.ActionInvocation;

/**
 * Background thread to be executed by the ExecuteAndWaitInterceptor.
 *
 */
public class BackgroundProcess implements Serializable {
	
	private static final long serialVersionUID = 3884464776311686443L;
	
	protected Object action;
    protected ActionInvocation invocation;
    protected String result;
    protected Exception exception;
    protected boolean done;

    /**
     * Constructs a background process
     * 
     * @param threadName The thread name
     * @param invocation The action invocation
     * @param threadPriority The thread priority
     */
    public BackgroundProcess(String threadName, final ActionInvocation invocation, int threadPriority) {
        this.invocation = invocation;
        this.action = invocation.getAction();
        try {
            final Thread t = new Thread(new Runnable() {
                public void run() {
                    try {
                        beforeInvocation();
                        result = invocation.invokeActionOnly();
                        afterInvocation();
                    } catch (Exception e) {
                        exception = e;
                    }

                    done = true;
                }
            });
            t.setName(threadName);
            t.setPriority(threadPriority);
            t.start();
        } catch (Exception e) {
            exception = e;
        }
    }

    /**
     * Called before the background thread determines the result code
     * from the ActionInvocation.
     *
     * @throws Exception any exception thrown will be thrown, in turn, by the ExecuteAndWaitInterceptor
     */
    protected void beforeInvocation() throws Exception {
    }

    /**
     * Called after the background thread determines the result code
     * from the ActionInvocation, but before the background thread is
     * marked as done.
     *
     * @throws Exception any exception thrown will be thrown, in turn, by the ExecuteAndWaitInterceptor
     */
    protected void afterInvocation() throws Exception {
    }

    /**
     * Retrieves the action.
     *
     * @return  the action.
     */
    public Object getAction() {
        return action;
    }

    /**
     * Retrieves the action invocation.
     * 
     * @return the action invocation
     */
    public ActionInvocation getInvocation() {
        return invocation;
    }

    /**
     * Gets the result of the background process.
     * 
     * @return  the result; <tt>null</tt> if not done.
     */
    public String getResult() {
        return result;
    }

    /**
     * Gets the exception if any was thrown during the execution of the background process.
     * 
     * @return the exception or <tt>null</tt> if no exception was thrown.
     */
    public Exception getException() {
        return exception;
    }

    /**
     * Returns the status of the background process.
     * 
     * @return <tt>true</tt> if finished, <tt>false</tt> otherwise
     */
    public boolean isDone() {
        return done;
    }
}
"
core/src/main/java/org/apache/struts2/interceptor/CheckboxInterceptor.java,true,"/*
 * $Id: CheckboxListTest.java 439747 2006-09-03 09:22:46Z mrdon $
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.interceptor;

import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.interceptor.Interceptor;

import java.util.Map;
import java.util.Set;
import java.util.HashMap;
import java.util.Iterator;

/**
 * <!-- START SNIPPET: description -->
 * Looks for a hidden identification field that specifies the original value of the checkbox.
 * If the checkbox isn't submitted, insert it into the parameters as if it was with the value 
 * of 'false'.
 * <!-- END SNIPPET: description -->
 * <p/>
 * <!-- START SNIPPET: parameters -->
 * <ul><li>setUncheckedValue -
 * The default value of an unchecked box can be overridden by setting the 'uncheckedValue' property.
 * </li></ul>
 * <!-- END SNIPPET: parameters -->
 * <p/>
 * <!-- START SNIPPET: extending -->
 * <p/>
 * <!-- END SNIPPET: extending -->
 */
public class CheckboxInterceptor implements Interceptor {
    
    /** Auto-generated serialization id */
    private static final long serialVersionUID = -586878104807229585L;
    
    private String uncheckedValue = Boolean.FALSE.toString();

    public void destroy() {
    }

    public void init() {
    }

    public String intercept(ActionInvocation ai) throws Exception {
        Map parameters = ai.getInvocationContext().getParameters();
        Map<String, String> newParams = new HashMap<String, String>();
        Set<String> keys = parameters.keySet();
        for (Iterator<String> iterator = keys.iterator(); iterator.hasNext();) {
            String key = iterator.next();

            if (key.startsWith("__checkbox_")) {
                String name = key.substring("__checkbox_".length());

                iterator.remove();

                // is this checkbox checked/submitted?
                if (!parameters.containsKey(name)) {
                    // if not, let's be sure to default the value to false
                    newParams.put(name, uncheckedValue);
                }
            }
        }

        parameters.putAll(newParams);

        return ai.invoke();
    }

    /**
     * Overrides the default value for an unchecked checkbox
     * 
     * @param uncheckedValue The uncheckedValue to set
     */
    public void setUncheckedValue(String uncheckedValue) {
        this.uncheckedValue = uncheckedValue;
    }
}
"
core/src/main/java/org/apache/struts2/interceptor/CreateSessionInterceptor.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.interceptor;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.ServletActionContext;

import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.interceptor.AbstractInterceptor;

/**
 * <!-- START SNIPPET: description -->
 *
 * This interceptor creates the HttpSession.
 * <p/>
 * This is particular usefull when using the &lt;@s.token&gt; tag in freemarker templates.
 * The tag <b>do</b> require that a HttpSession is already created since freemarker commits
 * the response to the client immediately.
 * 
 * <!-- END SNIPPET: description -->
 *
 * <p/> <u>Interceptor parameters:</u>
 *
 *
 * <!-- START SNIPPET: extending -->
 * 
 * <ul>
 * 	<li>none</li>
 * </ul>
 * 
 * <!-- END SNIPPET: extending -->
 *
 *
 * <!-- START SNIPPET: parameters -->
 *
 * <ul>
 *
 * <li>None</li>
 *
 * </ul>
 *
 * <!-- END SNIPPET: parameters -->
 *
 * <b>Example:</b>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * 
 * &lt;action name="someAction" class="com.examples.SomeAction"&gt;
 *     &lt;interceptor-ref name="create-session"/&gt;
 *     &lt;interceptor-ref name="defaultStack"/&gt;
 *     &lt;result name="input"&gt;input_with_token_tag.ftl&lt;/result&gt;
 * &lt;/action&gt;
 * 
 * <!-- END SNIPPET: example -->
 * </pre>
 * 
 * @version $Date$ $Id$
 */
public class CreateSessionInterceptor extends AbstractInterceptor {
	
	private static final long serialVersionUID = -4590322556118858869L;
	
	private static final Log _log = LogFactory.getLog(CreateSessionInterceptor.class);
	
	
    /* (non-Javadoc)
     * @see com.opensymphony.xwork2.interceptor.Interceptor#intercept(com.opensymphony.xwork2.ActionInvocation)
     */
    public String intercept(ActionInvocation invocation) throws Exception {
		_log.debug("Creating HttpSession");
		ServletActionContext.getRequest().getSession(true);
        return invocation.invoke();
	}

}
"
core/src/main/java/org/apache/struts2/interceptor/ExecuteAndWaitInterceptor.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.interceptor;

import java.util.Collections;
import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.ActionProxy;
import com.opensymphony.xwork2.config.entities.ResultConfig;
import com.opensymphony.xwork2.interceptor.MethodFilterInterceptor;


/**
 * <!-- START SNIPPET: description -->
 *
 * The ExecuteAndWaitInterceptor is great for running long-lived actions in the background while showing the user a nice
 * progress meter. This also prevents the HTTP request from timing out when the action takes more than 5 or 10 minutes.
 *
 * <p/> Using this interceptor is pretty straight forward. Assuming that you are including struts-default.xml, this
 * interceptor is already configured but is not part of any of the default stacks. Because of the nature of this
 * interceptor, it must be the <b>last</b> interceptor in the stack.
 *
 * <p/> This interceptor works on a per-session basis. That means that the same action name (myLongRunningAction, in the
 * above example) cannot be run more than once at a time in a given session. On the initial request or any subsequent
 * requests (before the action has completed), the <b>wait</b> result will be returned. <b>The wait result is
 * responsible for issuing a subsequent request back to the action, giving the effect of a self-updating progress
 * meter</b>.
 *
 * <p/> If no "wait" result is found, Struts will automatically generate a wait result on the fly. This result is
 * written in FreeMarker and cannot run unless FreeMarker is installed. If you don't wish to deploy with FreeMarker, you
 * must provide your own wait result. This is generally a good thing to do anyway, as the default wait page is very
 * plain.
 *
 * <p/>Whenever the wait result is returned, the <b>action that is currently running in the background will be placed on
 * top of the stack</b>. This allows you to display progress data, such as a count, in the wait page. By making the wait
 * page automatically reload the request to the action (which will be short-circuited by the interceptor), you can give
 * the appearance of an automatic progress meter.
 *
 * <p/>This interceptor also supports using an initial wait delay. An initial delay is a time in milliseconds we let the
 * server wait before the wait page is shown to the user. During the wait this interceptor will wake every 100 millis
 * to check if the background process is done premature, thus if the job for some reason doesn't take to long the wait
 * page is not shown to the user.
 * <br/> This is useful for e.g. search actions that have a wide span of execution time. Using a delay time of 2000
 * millis we ensure the user is presented fast search results immediately and for the slow results a wait page is used.
 *
 * <p/><b>Important</b>: Because the action will be running in a seperate thread, you can't use ActionContext because it
 * is a ThreadLocal. This means if you need to access, for example, session data, you need to implement SessionAware
 * rather than calling ActionContext.getSesion().
 *
 * <p/>The thread kicked off by this interceptor will be named in the form <b><u>actionName</u>BrackgroundProcess</b>.
 * For example, the <i>search</i> action would run as a thread named <i>searchBackgroundProcess</i>.
 *
 * <!-- END SNIPPET: description -->
 *
 * <p/> <u>Interceptor parameters:</u>
 *
 * <!-- START SNIPPET: parameters -->
 *
 * <ul>
 *
 * <li>threadPriority (optional) - the priority to assign the thread. Default is <code>Thread.NORM_PRIORITY</code>.</li>
 * <li>delay (optional) - an initial delay in millis to wait before the wait page is shown (returning <code>wait</code> as result code). Default is no initial delay.</li>
 * <li>delaySleepInterval (optional) - only used with delay. Used for waking up at certain intervals to check if the background process is already done. Default is 100 millis.</li>
 *
 * </ul>
 *
 * <!-- END SNIPPET: parameters -->
 *
 * <p/> <u>Extending the interceptor:</u>
 *
 * <p/>
 *
 * <!-- START SNIPPET: extending -->
 *
 * If you wish to make special preparations before and/or after the invocation of the background thread, you can extend
 * the BackgroundProcess class and implement the beforeInvocation() and afterInvocation() methods. This may be useful
 * for obtaining and releasing resources that the background process will need to execute successfully. To use your
 * background process extension, extend ExecuteAndWaitInterceptor and implement the getNewBackgroundProcess() method.
 *
 * <!-- END SNIPPET: extending -->
 *
 * <p/> <u>Example code:</u>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * &lt;action name="someAction" class="com.examples.SomeAction"&gt;
 *     &lt;interceptor-ref name="completeStack"/&gt;
 *     &lt;interceptor-ref name="execAndWait"/&gt;
 *     &lt;result name="wait"&gt;longRunningAction-wait.jsp&lt;/result&gt;
 *     &lt;result name="success"&gt;longRunningAction-success.jsp&lt;/result&gt;
 * &lt;/action&gt;
 *
 * &lt;%@ taglib prefix="s" uri="/struts" %&gt;
 * &lt;html&gt;
 *   &lt;head&gt;
 *     &lt;title&gt;Please wait&lt;/title&gt;
 *     &lt;meta http-equiv="refresh" content="5;url=&lt;a:url includeParams="all" /&gt;"/&gt;
 *   &lt;/head&gt;
 *   &lt;body&gt;
 *     Please wait while we process your request.
 *     Click &lt;a href="&lt;a:url includeParams="all" /&gt;">&lt;/a&gt; if this page does not reload automatically.
 *   &lt;/body&gt;
 * &lt;/html&gt;
 * </pre>
 *
 * <p/> <u>Example code2:</u>
 * This example will wait 2 second (2000 millis) before the wait page is shown to the user. Therefore
 * if the long process didn't last long anyway the user isn't shown a wait page.
 *
 * <pre>
 * &lt;action name="someAction" class="com.examples.SomeAction"&gt;
 *     &lt;interceptor-ref name="completeStack"/&gt;
 *     &lt;interceptor-ref name="execAndWait"&gt;
 *         &lt;param name="delay"&gt;2000&lt;param&gt;
 *     &lt;interceptor-ref&gt;
 *     &lt;result name="wait"&gt;longRunningAction-wait.jsp&lt;/result&gt;
 *     &lt;result name="success"&gt;longRunningAction-success.jsp&lt;/result&gt;
 * &lt;/action&gt;
 * </pre>
 *
 * <p/> <u>Example code3:</u>
 * This example will wait 1 second (1000 millis) before the wait page is shown to the user.
 * And at every 50 millis this interceptor will check if the background process is done, if so
 * it will return before the 1 second has elapsed, and the user isn't shown a wait page.
 *
 * <pre>
 * &lt;action name="someAction" class="com.examples.SomeAction"&gt;
 *     &lt;interceptor-ref name="completeStack"/&gt;
 *     &lt;interceptor-ref name="execAndWait"&gt;
 *         &lt;param name="delay"&gt;1000&lt;param&gt;
 *         &lt;param name="delaySleepInterval"&gt;50&lt;param&gt;
 *     &lt;interceptor-ref&gt;
 *     &lt;result name="wait"&gt;longRunningAction-wait.jsp&lt;/result&gt;
 *     &lt;result name="success"&gt;longRunningAction-success.jsp&lt;/result&gt;
 * &lt;/action&gt;
 * </pre>
 *
 * <!-- END SNIPPET: example -->
 *
 */
public class ExecuteAndWaitInterceptor extends MethodFilterInterceptor {
	
	private static final long serialVersionUID = -2754639196749652512L;

	private static final Log LOG = LogFactory.getLog(ExecuteAndWaitInterceptor.class);

    public static final String KEY = "__execWait";
    public static final String WAIT = "wait";
    protected int delay;
    protected int delaySleepInterval = 100; // default sleep 100 millis before checking if background process is done

    private int threadPriority = Thread.NORM_PRIORITY;

    /* (non-Javadoc)
     * @see com.opensymphony.xwork2.interceptor.Interceptor#init()
     */
    public void init() {
    }

    /**
     * Creates a new background process
     * 
     * @param name The process name
     * @param actionInvocation The action invocation
     * @param threadPriority The thread priority
     * @return The new process
     */
    protected BackgroundProcess getNewBackgroundProcess(String name, ActionInvocation actionInvocation, int threadPriority) {
        return new BackgroundProcess(name + "BackgroundThread", actionInvocation, threadPriority);
    }

    /* (non-Javadoc)
     * @see com.opensymphony.xwork2.interceptor.MethodFilterInterceptor#doIntercept(com.opensymphony.xwork2.ActionInvocation)
     */
    protected String doIntercept(ActionInvocation actionInvocation) throws Exception {
        ActionProxy proxy = actionInvocation.getProxy();
        String name = proxy.getActionName();
        ActionContext context = actionInvocation.getInvocationContext();
        Map session = context.getSession();

        Boolean secondTime = (Boolean) context.get(KEY);
        if (secondTime == null) {
            context.put(KEY, true);
            secondTime = false;
        } else {
            secondTime = true;
        }

        synchronized (session) {
            BackgroundProcess bp = (BackgroundProcess) session.get(KEY + name);

            if (secondTime && bp == null) {
                bp = getNewBackgroundProcess(name, actionInvocation, threadPriority);
                session.put(KEY + name, bp);
                performInitialDelay(bp); // first time let some time pass before showing wait page
                secondTime = false;
            }

            if (!secondTime && bp != null && !bp.isDone()) {
                actionInvocation.getStack().push(bp.getAction());
                Map results = proxy.getConfig().getResults();
                if (!results.containsKey(WAIT)) {
                    LOG.warn("ExecuteAndWait interceptor has detected that no result named 'wait' is available. " +
                            "Defaulting to a plain built-in wait page. It is highly recommend you " +
                            "provide an action-specific or global result named '" + WAIT +
                            "'! This requires FreeMarker support and won't work if you don't have it installed");
                    // no wait result? hmm -- let's try to do dynamically put it in for you!
                    ResultConfig rc = new ResultConfig(WAIT, "org.apache.struts2.views.freemarker.FreemarkerResult",
                            Collections.singletonMap("location", "/org/apache/struts2/interceptor/wait.ftl"));
                    results.put(WAIT, rc);
                }

                return WAIT;
            } else if (!secondTime && bp != null && bp.isDone()) {
                session.remove(KEY + name);
                actionInvocation.getStack().push(bp.getAction());

                // if an exception occured during action execution, throw it here
                if (bp.getException() != null) {
                    throw bp.getException();
                }

                return bp.getResult();
            } else {
                // this is the first instance of the interceptor and there is no existing action
                // already run in the background, so let's just let this pass through. We assume
                // the action invocation will be run in the background on the subsequent pass through
                // this interceptor
                return actionInvocation.invoke();
            }
        }
    }


    /* (non-Javadoc)
     * @see com.opensymphony.xwork2.interceptor.Interceptor#destroy()
     */
    public void destroy() {
    }

    /**
     * Performs the initial delay.
     * <p/>
     * When this interceptor is executed for the first time this methods handles any provided initial delay.
     * An initial delay is a time in miliseconds we let the server wait before we continue.
     * <br/> During the wait this interceptor will wake every 100 millis to check if the background
     * process is done premature, thus if the job for some reason doesn't take to long the wait
     * page is not shown to the user.
     *
     * @param bp the background process
     * @throws InterruptedException is thrown by Thread.sleep
     */
    protected void performInitialDelay(BackgroundProcess bp) throws InterruptedException {
        if (delay <= 0 || delaySleepInterval <= 0) {
            return;
        }

        int steps = delay / delaySleepInterval;
        if (LOG.isDebugEnabled()) {
            LOG.debug("Delaying for " + delay + " millis. (using " + steps + " steps)");
        }
        int step;
        for (step = 0; step < steps && !bp.isDone(); step++) {
            Thread.sleep(delaySleepInterval);
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug("Sleeping ended after " + step + " steps and the background process is " + (bp.isDone() ? " done" : " not done"));
        }
    }

    /**
     * Sets the thread priority of the background process.
     *
     * @param threadPriority the priority from <code>Thread.XXX</code>
     */
    public void setThreadPriority(int threadPriority) {
        this.threadPriority = threadPriority;
    }

    /**
     * Sets the initial delay in millis (msec).
     *
     * @param delay in millis. (0 for not used)
     */
    public void setDelay(int delay) {
        this.delay = delay;
    }

    /**
     * Sets the sleep interval in millis (msec) when performing the initial delay.
     *
     * @param delaySleepInterval in millis (0 for not used)
     */
    public void setDelaySleepInterval(int delaySleepInterval) {
        this.delaySleepInterval = delaySleepInterval;
    }
}
"
core/src/main/java/org/apache/struts2/interceptor/FileUploadInterceptor.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.interceptor;

import java.io.File;
import java.util.Collection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;

import javax.servlet.http.HttpServletRequest;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.ServletActionContext;
import org.apache.struts2.dispatcher.multipart.MultiPartRequestWrapper;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.ActionProxy;
import com.opensymphony.xwork2.ValidationAware;
import com.opensymphony.xwork2.interceptor.AbstractInterceptor;
import com.opensymphony.xwork2.util.LocalizedTextUtil;

/**
 * <!-- START SNIPPET: description -->
 *
 * Interceptor that is based off of {@link MultiPartRequestWrapper}, which is automatically applied for any request that
 * includes a file. It adds the following parameters, where [File Name] is the name given to the file uploaded by the
 * HTML form:
 *
 * <ul>
 *
 * <li>[File Name] : File - the actual File</li>
 *
 * <li>[File Name]ContentType : String - the content type of the file</li>
 *
 * <li>[File Name]FileName : String - the actual name of the file uploaded (not the HTML name)</li>
 *
 * </ul>
 *
 * <p/> You can get access to these files by merely providing setters in your action that correspond to any of the three
 * patterns above, such as setDocument(File document), setDocumentContentType(String contentType), etc.
 * <br/>See the example code section.
 *
 * <p/> This interceptor will add several field errors, assuming that the action implements {@link ValidationAware}.
 * These error messages are based on several i18n values stored in struts-messages.properties, a default i18n file
 * processed for all i18n requests. You can override the text of these messages by providing text for the following
 * keys:
 *
 * <ul>
 *
 * <li>struts.messages.error.uploading - a general error that occurs when the file could not be uploaded</li>
 *
 * <li>struts.messages.error.file.too.large - occurs when the uploaded file is too large</li>
 *
 * <li>struts.messages.error.content.type.not.allowed - occurs when the uploaded file does not match the expected
 * content types specified</li>
 *
 * </ul>
 *
 * <!-- END SNIPPET: description -->
 *
 * <p/> <u>Interceptor parameters:</u>
 *
 * <!-- START SNIPPET: parameters -->
 *
 * <ul>
 *
 * <li>maximumSize (optional) - the maximum size (in bytes) that the interceptor will allow a file reference to be set
 * on the action. Note, this is <b>not</b> related to the various properties found in struts.properties.
 * Default to approximately 2MB.</li>
 *
 * <li>allowedTypes (optional) - a comma separated list of content types (ie: text/html) that the interceptor will allow
 * a file reference to be set on the action. If none is specified allow all types to be uploaded.</li>
 *
 * </ul>
 *
 * <!-- END SNIPPET: parameters -->
 *
 * <p/> <u>Extending the interceptor:</u>
 *
 * <p/>
 *
 * <!-- START SNIPPET: extending -->
 *
 * You can extend this interceptor and override the {@link #acceptFile} method to provide more control over which files
 * are supported and which are not.
 *
 * <!-- END SNIPPET: extending -->
 *
 * <p/> <u>Example code:</u>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * &lt;action name="doUpload" class="com.examples.UploadAction"&gt;
 *     &lt;interceptor-ref name="fileUpload"/&gt;
 *     &lt;interceptor-ref name="basicStack"/&gt;
 *     &lt;result name="success"&gt;good_result.ftl&lt;/result&gt;
 * &lt;/action&gt;
 * </pre>
 *
 * And then you need to set encoding <code>multipart/form-data</code> in the form where the user selects the file to upload.
 * <pre>
 *   &lt;a:form action="doUpload" method="post" enctype="multipart/form-data"&gt;
 *       &lt;a:file name="upload" label="File"/&gt;
 *       &lt;a:submit/&gt;
 *   &lt;/a:form&gt;
 * </pre>
 *
 * And then in your action code you'll have access to the File object if you provide setters according to the
 * naming convention documented in the start.
 *
 * <pre>
 *    public com.examples.UploadAction implemements Action {
 *       private File file;
 *       private String contentType;
 *       private String filename;
 *
 *       public void setUpload(File file) {
 *          this.file = file;
 *       }
 *
 *       public void setUploadContentType(String contentType) {
 *          this.contentType = contentType;
 *       }
 *
 *       public void setUploadFileName(String filename) {
 *          this.filename = filename;
 *       }
 *
 *       ...
 *  }
 * </pre>
 * <!-- END SNIPPET: example -->
 *
 */
public class FileUploadInterceptor extends AbstractInterceptor {
	
	private static final long serialVersionUID = -4764627478894962478L;
	
	protected static final Log log = LogFactory.getLog(FileUploadInterceptor.class);
    private static final String DEFAULT_DELIMITER = ",";
    private static final String DEFAULT_MESSAGE = "no.message.found";

    protected Long maximumSize;
    protected String allowedTypes;
    protected Set allowedTypesSet = Collections.EMPTY_SET;

    /**
     * Sets the allowed mimetypes
     * 
     * @param allowedTypes A comma-delimited list of types
     */
    public void setAllowedTypes(String allowedTypes) {
        this.allowedTypes = allowedTypes;

        // set the allowedTypes as a collection for easier access later
        allowedTypesSet = getDelimitedValues(allowedTypes);
    }

    /**
     * Sets the maximum size of an uploaded file
     * 
     * @param maximumSize The maximum size in bytes
     */
    public void setMaximumSize(Long maximumSize) {
        this.maximumSize = maximumSize;
    }

    /* (non-Javadoc)
     * @see com.opensymphony.xwork2.interceptor.Interceptor#intercept(com.opensymphony.xwork2.ActionInvocation)
     */
    public String intercept(ActionInvocation invocation) throws Exception {
        ActionContext ac = invocation.getInvocationContext();
        HttpServletRequest request = (HttpServletRequest) ac.get(ServletActionContext.HTTP_REQUEST);

        if (!(request instanceof MultiPartRequestWrapper)) {
            if (log.isDebugEnabled()) {
                ActionProxy proxy = invocation.getProxy();
                log.debug(getTextMessage("struts.messages.bypass.request", new Object[]{proxy.getNamespace(), proxy.getActionName()}, ActionContext.getContext().getLocale()));
            }

            return invocation.invoke();
        }

        final Object action = invocation.getAction();
        ValidationAware validation = null;

        if (action instanceof ValidationAware) {
            validation = (ValidationAware) action;
        }

        MultiPartRequestWrapper multiWrapper = (MultiPartRequestWrapper) request;

        if (multiWrapper.hasErrors()) {
            for (Iterator errorIter = multiWrapper.getErrors().iterator(); errorIter.hasNext();) {
                String error = (String) errorIter.next();

                if (validation != null) {
                    validation.addActionError(error);
                }

                log.error(error);
            }
        }

        Map parameters = ac.getParameters();

        // Bind allowed Files
        Enumeration fileParameterNames = multiWrapper.getFileParameterNames();
        while (fileParameterNames != null && fileParameterNames.hasMoreElements()) {
            // get the value of this input tag
            String inputName = (String) fileParameterNames.nextElement();

            // get the content type
            String[] contentType = multiWrapper.getContentTypes(inputName);

            if (isNonEmpty(contentType)) {
                // get the name of the file from the input tag
                String[] fileName = multiWrapper.getFileNames(inputName);

                if (isNonEmpty(fileName)) {
                    // Get a File object for the uploaded File
                    File[] files = multiWrapper.getFiles(inputName);
                    if (files != null) {
                        for (int index = 0; index < files.length; index++) {
                            getTextMessage("struts.messages.current.file", new Object[]{inputName, contentType[index], fileName[index], files[index]}, ActionContext.getContext().getLocale());

                            if (acceptFile(files[0], contentType[0], inputName, validation, ac.getLocale())) {
                                parameters.put(inputName, files);
                                parameters.put(inputName + "ContentType", contentType);
                                parameters.put(inputName + "FileName", fileName);
                            }
                        }
                    }
                } else {
                    log.error(getTextMessage("struts.messages.invalid.file", new Object[]{inputName}, ActionContext.getContext().getLocale()));
                }
            } else {
                log.error(getTextMessage("struts.messages.invalid.content.type", new Object[]{inputName}, ActionContext.getContext().getLocale()));
            }
        }

        // invoke action
        String result = invocation.invoke();

        // cleanup
        fileParameterNames = multiWrapper.getFileParameterNames();
        while (fileParameterNames != null && fileParameterNames.hasMoreElements()) {
            String inputValue = (String) fileParameterNames.nextElement();
            File[] file = multiWrapper.getFiles(inputValue);
            for (int index = 0; index < file.length; index++) {
                File currentFile = file[index];
                log.info(getTextMessage("struts.messages.removing.file", new Object[]{inputValue, currentFile}, ActionContext.getContext().getLocale()));

                if ((currentFile != null) && currentFile.isFile()) {
                    currentFile.delete();
                }
            }
        }

        return result;
    }

    /**
     * Override for added functionality. Checks if the proposed file is acceptable based on contentType and size.
     *
     * @param file        - proposed upload file.
     * @param contentType - contentType of the file.
     * @param inputName   - inputName of the file.
     * @param validation  - Non-null ValidationAware if the action implements ValidationAware, allowing for better
     *                    logging.
     * @param locale
     * @return true if the proposed file is acceptable by contentType and size.
     */
    protected boolean acceptFile(File file, String contentType, String inputName, ValidationAware validation, Locale locale) {
        boolean fileIsAcceptable = false;

        // If it's null the upload failed
        if (file == null) {
            String errMsg = getTextMessage("struts.messages.error.uploading", new Object[]{inputName}, locale);
            if (validation != null) {
                validation.addFieldError(inputName, errMsg);
            }

            log.error(errMsg);
        } else if (maximumSize != null && maximumSize.longValue() < file.length()) {
            String errMsg = getTextMessage("struts.messages.error.file.too.large", new Object[]{inputName, file.getName(), "" + file.length()}, locale);
            if (validation != null) {
                validation.addFieldError(inputName, errMsg);
            }

            log.error(errMsg);
        } else if ((! allowedTypesSet.isEmpty()) && (!containsItem(allowedTypesSet, contentType))) {
            String errMsg = getTextMessage("struts.messages.error.content.type.not.allowed", new Object[]{inputName, file.getName(), contentType}, locale);
            if (validation != null) {
                validation.addFieldError(inputName, errMsg);
            }

            log.error(errMsg);
        } else {
            fileIsAcceptable = true;
        }

        return fileIsAcceptable;
    }

    /**
     * @param itemCollection - Collection of string items (all lowercase).
     * @param key            - Key to search for.
     * @return true if itemCollection contains the key, false otherwise.
     */
    private static boolean containsItem(Collection itemCollection, String key) {
        return itemCollection.contains(key.toLowerCase());
    }

    private static Set getDelimitedValues(String delimitedString) {
        Set<String> delimitedValues = new HashSet<String>();
        if (delimitedString != null) {
            StringTokenizer stringTokenizer = new StringTokenizer(delimitedString, DEFAULT_DELIMITER);
            while (stringTokenizer.hasMoreTokens()) {
                String nextToken = stringTokenizer.nextToken().toLowerCase().trim();
                if (nextToken.length() > 0) {
                    delimitedValues.add(nextToken);
                }
            }
        }
        return delimitedValues;
    }

    private static boolean isNonEmpty(Object[] objArray) {
        boolean result = false;
        for (int index = 0; index < objArray.length && !result; index++) {
            if (objArray[index] != null) {
                result = true;
            }
        }
        return result;
    }

    private String getTextMessage(String messageKey, Object[] args, Locale locale) {
        if (args == null || args.length == 0) {
            return LocalizedTextUtil.findText(this.getClass(), messageKey, locale);
        } else {
            return LocalizedTextUtil.findText(this.getClass(), messageKey, locale, DEFAULT_MESSAGE, args);
        }
    }
}
"
core/src/main/java/org/apache/struts2/interceptor/MessageStoreInterceptor.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.interceptor;

import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.ValidationAware;
import com.opensymphony.xwork2.interceptor.Interceptor;

/**
 * <!-- START SNIPPET: description -->
 * 
 * An interceptor to store {@link ValidationAware} action's messages / errors and field errors into 
 * Http Session, such that it will be retrieveable at a later stage. This allows the action's message /
 * errors and field errors to be available longer that just the particular http request.
 * 
 * <p/>
 * 
 * In the 'STORE' mode, the interceptor will store the {@link ValidationAware} action's message / errors 
 * and field errors into Http session.
 * 
 * <p/>
 * 
 * In the 'RETRIEVE' mode, the interceptor will retrieve the stored action's message / errors  and field
 * errors and put them back into the {@link ValidationAware} action.
 * 
 * <p/>
 * 
 * The interceptor does nothing in the 'NONE' mode, which is the default.
 * 
 * <p/>
 * 
 * The operation mode could be switched using :- <p/>
 * 1] Setting the iterceptor parameter eg.
 * <pre>
 *   &lt;action name="submitApplication" ...&gt;
 *      &lt;interceptor-ref name="store"&gt;
 *         &lt;param name="operationMode"&gtl;STORE&lt;/param&gt;
 *      &lt;/interceptor-ref&gt;
 *      &lt;interceptor-ref name="defaultStack" /&gt;
 *      ....
 *   &lt;/action&gt;
 * </pre>
 * 
 * 2] Through request parameter (allowRequestParameterSwitch must be 'true' which is the default)
 * <pre>
 *   // the request will have the operation mode in 'STORE'
 *   http://localhost:8080/context/submitApplication.action?operationMode=STORE
 * </pre>
 * 
 * <!-- END SNIPPET: description -->
 * 
 * 
 * <!-- START SNIPPET: parameters -->
 * 
 * <ul>
 * 		<li>allowRequestParameterSwitch - To enable request parameter that could switch the operation mode 
 * 										  of this interceptor. </li>
 * 		<li>requestParameterSwitch - The request parameter that will indicate what mode this 
 * 									 interceptor is in. </li>
 * 		<li>operationMode - The operation mode this interceptor should be in 
 * 							(either 'STORE', 'RETRIEVE' or 'NONE'). 'NONE' being the default.</li>
 * </ul>
 * 
 * <!-- END SNIPPET: parameters -->
 * 
 * <p/>
 * 
 * <!-- START SNIPPET: extending -->
 * 
 * The following method could be overriden :-
 * <ul>
 * 	<li>getRequestOperationMode - get the operation mode of this interceptor based on the request parameters</li>
 *  <li>mergeCollection - merge two collections</li>
 *  <li>mergeMap - merge two map</li>
 * </ul>
 * 
 * <!-- END SNIPPET: extending -->
 * 
 * <pre>
 * <!-- START SNIPPET: example -->
 * 
 * &lt;action name="submitApplication" ....&gt;
 *    &lt;interceptor-ref name="store"&gt;
 *    	&lt;param name="operationMode">STORE&lt;/param&gt;
 *    &lt;/interceptor-ref&gt;
 *    &lt;interceptor-ref name="defaultStack" /&gt;
 *    &lt;result name="input" type="redirect">applicationFailed.action&lt;/result&gt;
 *    &lt;result type="dispatcher"&gt;applicationSuccess.jsp&lt;/result&gt;
 * &lt;/action&gt;
 * 
 * &lt;action name="applicationFailed" ....&gt;
 *    &lt;interceptor-ref name="store"&gt;
 *       &lt;param name="operationMode"&gt;RETRIEVE&lt;/param&gt;
 *    &lt;/interceptor-ref&gt;
 *    &lt;result&gt;applicationFailed.jsp&lt;/result&gt;
 * &lt;/action&gt;
 * 
 * <!-- END SNIPPET: example -->
 * </pre>
 * 
 * <!-- START SNIPPET: exampleDescription -->
 * 
 * With the example above, 'submitApplication.action' will have the action messages / errors / field errors stored
 * in the Http Session. Later when needed, (in this case, when 'applicationFailed.action' is fired, it
 * will get the action messages / errors / field errors stored in the Http Session and put them back into 
 * the action. 
 * 
 * <!-- END SNIPPET: exampleDescription -->
 * 
 * @version $Date$ $Id$
 */
public class MessageStoreInterceptor implements Interceptor {

	private static final long serialVersionUID = 4491997514314242420L;
	
	private static final Log _log = LogFactory.getLog(MessageStoreInterceptor.class);
	
	
	public static final String STORE_MODE = "STORE";
	public static final String RETRIEVE_MODE = "RETRIEVE";
	public static final String NONE = "NONE";
	
	private boolean allowRequestParameterSwitch = true;
	private String requestParameterSwitch = "operationMode";
	private String operationMode = NONE;
	
	public static String fieldErrorsSessionKey = "__MessageStoreInterceptor_FieldErrors_SessionKey";
	public static String actionErrorsSessionKey = "__MessageStoreInterceptor_ActionErrors_SessionKey";
	public static String actionMessagesSessionKey = "__MessageStoreInterceptor_ActionMessages_SessionKey";
	
	
	
	public void setAllowRequestParameterSwitch(boolean allowRequestParameterSwitch) {
		this.allowRequestParameterSwitch = allowRequestParameterSwitch;
	}
	public boolean getAllowRequestParameterSwitch() {
		return this.allowRequestParameterSwitch;
	}
	
	
	public void setRequestParameterSwitch(String requestParameterSwitch) {
		this.requestParameterSwitch = requestParameterSwitch;
	}
	public String getRequestParameterSwitch() {
		return this.requestParameterSwitch;
	}
	
	
	
	public void setOperationMode(String operationMode) {
		this.operationMode = operationMode;
	}
	public String getOperationModel() {
		return this.operationMode;
	}
	

	public void destroy() {
	}

	public void init() {
	}

	public String intercept(ActionInvocation invocation) throws Exception {
		_log.debug("entering MessageStoreInterceptor ...");
		
		before(invocation);
		String result = invocation.invoke();
		after(invocation, result);
		
		_log.debug("exit executing MessageStoreInterceptor");
		return result;
	}
	
	/**
	 * Handle the retrieving of field errors / action messages / field errors, which is
	 * done before action invocation, and the <code>operationMode</code> is 'RETRIEVE'.
	 * 
	 * @param invocation
	 * @throws Exception
	 */
	protected void before(ActionInvocation invocation) throws Exception {
		String reqOperationMode = getRequestOperationMode(invocation);
		
		if (RETRIEVE_MODE.equalsIgnoreCase(reqOperationMode) || 
				RETRIEVE_MODE.equalsIgnoreCase(operationMode)) {
			
			Object action = invocation.getAction();
			if (action instanceof ValidationAware) {
				// retrieve error / message from session
				Map session = (Map) invocation.getInvocationContext().get(ActionContext.SESSION);
				ValidationAware validationAwareAction = (ValidationAware) action;
				
				_log.debug("retrieve error / message from session to populate into action ["+action+"]");
				
				Collection actionErrors = (Collection) session.get(actionErrorsSessionKey);
				Collection actionMessages = (Collection) session.get(actionMessagesSessionKey);
				Map fieldErrors = (Map) session.get(fieldErrorsSessionKey);
				
				if (actionErrors != null && actionErrors.size() > 0) {
					Collection mergedActionErrors = mergeCollection(validationAwareAction.getActionErrors(), actionErrors);
					validationAwareAction.setActionErrors(mergedActionErrors);
				}
				
				if (actionMessages != null && actionMessages.size() > 0) {
					Collection mergedActionMessages = mergeCollection(validationAwareAction.getActionMessages(), actionMessages);
					validationAwareAction.setActionMessages(mergedActionMessages);
				}
				
				if (fieldErrors != null && fieldErrors.size() > 0) {
					Map mergedFieldErrors = mergeMap(validationAwareAction.getFieldErrors(), fieldErrors);
					validationAwareAction.setFieldErrors(mergedFieldErrors);
				}
				session.remove(actionErrorsSessionKey);
				session.remove(actionMessagesSessionKey);
				session.remove(fieldErrorsSessionKey);
			}
		}
	}
	
	/**
	 * Handle the storing of field errors / action messages / field errors, which is
	 * done after action invocation, and the <code>operationMode</code> is in 'STORE'.
	 * 
	 * @param invocation
	 * @param result
	 * @throws Exception
	 */
	protected void after(ActionInvocation invocation, String result) throws Exception {
		
		String reqOperationMode = getRequestOperationMode(invocation);
		if (STORE_MODE.equalsIgnoreCase(reqOperationMode) ||
				STORE_MODE.equalsIgnoreCase(operationMode)) {
			
			Object action = invocation.getAction();
			if (action instanceof ValidationAware) {
				// store error / messages into session
				Map session = (Map) invocation.getInvocationContext().get(ActionContext.SESSION);
				
				_log.debug("store action ["+action+"] error/messages into session ");
				
				ValidationAware validationAwareAction = (ValidationAware) action;
				session.put(actionErrorsSessionKey, validationAwareAction.getActionErrors());
				session.put(actionMessagesSessionKey, validationAwareAction.getActionMessages());
				session.put(fieldErrorsSessionKey, validationAwareAction.getFieldErrors());
			}
			else {
				_log.debug("Action ["+action+"] is not ValidationAware, no message / error that are storeable");
			}
		}
	}
	
	
	/**
	 * Get the operationMode through request paramter, if <code>allowRequestParameterSwitch</code>
	 * is 'true', else it simply returns 'NONE', meaning its neither in the 'STORE_MODE' nor
	 * 'RETRIEVE_MODE'.
	 * 
	 * @return String
	 */
	protected String getRequestOperationMode(ActionInvocation invocation) {
		String reqOperationMode = NONE;
		if (allowRequestParameterSwitch) {
			Map reqParams = (Map) invocation.getInvocationContext().get(ActionContext.PARAMETERS);
			boolean containsParameter = reqParams.containsKey(requestParameterSwitch);
			if (containsParameter) {
				String[] reqParamsArr = (String[]) reqParams.get(requestParameterSwitch);
				if (reqParamsArr != null && reqParamsArr.length > 0) {
					reqOperationMode = reqParamsArr[0];
				}
			}
		}
		return reqOperationMode;
	}
	
	/**
	 * Merge <code>col1</code> and <code>col2</code> and return the composite 
	 * <code>Collection</code>.
	 * 
	 * @param col1
	 * @param col2
	 * @return Collection
	 */
	protected Collection mergeCollection(Collection col1, Collection col2) {
		Collection _col1 = (col1 == null ? new ArrayList() : col1);
		Collection _col2 = (col2 == null ? new ArrayList() : col2);
		_col1.addAll(_col2);
		return _col1;
	}
	
	/**
	 * Merge <code>map1</code> and <code>map2</code> and return the composite
	 * <code>Map</code>
	 * 
	 * @param map1
	 * @param map2
	 * @return Map
	 */
	protected Map mergeMap(Map map1, Map map2) {
		Map _map1 = (map1 == null ? new LinkedHashMap() : map1);
		Map _map2 = (map2 == null ? new LinkedHashMap() : map2);
		_map1.putAll(_map2);
		return _map1;
	}

}
"
core/src/main/java/org/apache/struts2/interceptor/NoParameters.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.interceptor;


/**
 * This marker interface should be implemented by actions that do not want any parameters set on
 * them automatically. This may be useful if one is using the action tag and want to supply
 * the parameters to the action manually using the param tag. It may also be useful if one for
 * security reasons wants to make sure that parameters cannot be set by malicious users.
 *
 */
public interface NoParameters extends com.opensymphony.xwork2.interceptor.NoParameters {
}
"
core/src/main/java/org/apache/struts2/interceptor/ParameterAware.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.interceptor;

import java.util.Map;


/**
 * This interface gives actions an alternative way of receiving input parameters. The map will
 * contain all input parameters as name/value entries. Actions that need this should simply implement it. <p>
 * <p/>
 * One common use for this is to have the action propagate parameters to internally instantiated data
 * objects. <p>
 * <p/>
 * Note that all parameter values for a given name will be returned, so the type of the objects in
 * the map is <tt>java.lang.String[]</tt>.
 *
 */
public interface ParameterAware {

    /**
     * Sets the  map of input parameters in the implementing class.
     *
     * @param parameters a Map of parameters (name/value Strings).
     */
    public void setParameters(Map parameters);
}
"
core/src/main/java/org/apache/struts2/interceptor/PrincipalAware.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.interceptor;

/**
 * Actions that want access to the Principal information from HttpServletRequest object
 * should implement this interface.
 *
 * <p>This interface is only relevant if the Action is used in a servlet environment.
 * By using this interface you will not become tied to servlet environment.</p>
 *
 */
public interface PrincipalAware {
    void setPrincipalProxy(PrincipalProxy principalProxy);
}
"
core/src/main/java/org/apache/struts2/interceptor/PrincipalProxy.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.interceptor;

import java.security.Principal;

import javax.servlet.http.HttpServletRequest;

/**
 * Proxy class used together with PrincipalAware interface. It allows to get indirect access to
 * HttpServletRequest Principal related methods.
 *
 */
public class PrincipalProxy {
    private HttpServletRequest request;

    /**
     * Constructs a proxy
     * 
     * @param request The underlying request
     */
    public PrincipalProxy(HttpServletRequest request) {
        this.request = request;
    }

    /**
     * True if the user is in the given role
     * 
     * @param role The role
     * @return True if the user is in that role
     */
    public boolean isUserInRole(String role) {
        return request.isUserInRole(role);
    }

    /**
     * Gets the user principal
     * 
     * @return The principal
     */
    public Principal getUserPrincipal() {
        return request.getUserPrincipal();
    }

    /**
     * Gets the user id
     * 
     * @return The user id
     */
    public String getRemoteUser() {
        return request.getRemoteUser();
    }

    /**
     * Is the request using https?
     * 
     * @return True if using https
     */
    public boolean isRequestSecure() {
        return request.isSecure();
    }

    /**
     * Gets the request
     * 
     * @return The request
     */
    public HttpServletRequest getRequest() {
        return request;
    }
}
"
core/src/main/java/org/apache/struts2/interceptor/RequestAware.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.interceptor;

import java.util.Map;

/**
 * Actions that want access to the current serlvet request attributes should implement this interface.<p />
 * 
 * This interface is only relevant if the Action is used in a servlet environment.<p/>
 * 
 * Note that using this interface makes the Action tied to a servlet environment, so it should be
 * avoided if possible since things like unit testing will become more difficult.
 */
public interface RequestAware {

	/**
     * Sets the Map of request attributes in the implementing class.
     *
     * @param request a Map of HTTP request attribute name/value pairs.
     */
    public void setRequest(Map request);
}
"
core/src/main/java/org/apache/struts2/interceptor/ScopeInterceptor.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.interceptor;

import java.util.IdentityHashMap;
import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.ServletActionContext;
import org.apache.struts2.StrutsException;
import org.apache.struts2.dispatcher.SessionMap;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.ActionProxy;
import com.opensymphony.xwork2.interceptor.AbstractInterceptor;
import com.opensymphony.xwork2.interceptor.PreResultListener;
import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: description -->
 *
 * This is designed to solve a few simple issues related to wizard-like functionality in Struts. One of those issues is
 * that some applications have a application-wide parameters commonly used, such <i>pageLen</i> (used for records per
 * page). Rather than requiring that each action check if such parameters are supplied, this interceptor can look for
 * specified parameters and pull them out of the session.
 *
 * <p/> This works by setting listed properties at action start with values from session/application attributes keyed
 * after the action's class, the action's name, or any supplied key. After action is executed all the listed properties
 * are taken back and put in session or application context.
 *
 * <p/> To make sure that each execution of the action is consistent it makes use of session-level locking. This way it
 * guarantees that each action execution is atomic at the session level. It doesn't guarantee application level
 * consistency however there has yet to be enough reasons to do so. Application level consistency would also be a big
 * performance overkill.
 *
 * <p/> Note that this interceptor takes a snapshot of action properties just before result is presented (using a {@link
 * PreResultListener}), rather than after action is invoked. There is a reason for that: At this moment we know that
 * action's state is "complete" as it's values may depend on the rest of the stack and specifically - on the values of
 * nested interceptors.
 *
 * <!-- END SNIPPET: description -->
 *
 * <p/> <u>Interceptor parameters:</u>
 *
 * <!-- START SNIPPET: parameters -->
 *
 * <ul>
 *
 * <li>session - a list of action properties to be bound to session scope</li>
 *
 * <li>application - a list of action properties to be bound to application scope</li>
 *
 * <li>key - a session/application attribute key prefix, can contain following values:</li>
 *
 * <ul>
 *
 * <li>CLASS - that creates a unique key prefix based on action namespace and action class, it's a default value</li>
 *
 * <li>ACTION - creates a unique key prefix based on action namespace and action name</li>
 *
 * <li>any other value is taken literally as key prefix</li>
 *
 * </ul>
 *
 * <li>type - with one of the following</li>
 *
 * <ul>
 *
 * <li>start - means it's a start action of the wizard-like action sequence and all session scoped properties are reset
 * to their defaults</li>
 *
 * <li>end - means that session scoped properties are removed from session after action is run</li>
 *
 * <li>any other value or no value means that it's in-the-middle action that is set with session properties before it's
 * executed, and it's properties are put back to session after execution</li>
 *
 * </ul>
 *
 * <li>sessionReset - boolean value causing all session values to be reset to action's default values or application
 * scope values, note that it is similliar to type="start" and in fact it does the same, but in our team it is sometimes
 * semantically preferred. We use session scope in two patterns - sometimes there are wizzard-like action sequences that
 * have start and end, and sometimes we just want simply reset current session values.</li>
 *
 * </ul>
 *
 * <!-- END SNIPPET: parameters -->
 *
 * <p/> <u>Extending the interceptor:</u>
 *
 * <p/>
 *
 * <!-- START SNIPPET: extending -->
 *
 * There are no know extension points for this interceptor.
 *
 * <!-- END SNIPPET: extending -->
 *
 * <p/> <u>Example code:</u>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * &lt;!-- As the filter and orderBy parameters are common for all my browse-type actions,
 *      you can move control to the scope interceptor. In the session parameter you can list
 *      action properties that are going to be automatically managed over session. You can
 *      do the same for application-scoped variables--&gt;
 * &lt;action name="someAction" class="com.examples.SomeAction"&gt;
 *     &lt;interceptor-ref name="basicStack"/&gt;
 *     &lt;interceptor-ref name="hibernate"/&gt;
 *     &lt;interceptor-ref name="scope"&gt;
 *         &lt;param name="session"&gt;filter,orderBy&lt;/param&gt;
 *         &lt;param name="autoCreateSession"&gt;true&lt;/param&gt;
 *     &lt;/interceptor-ref&gt;
 *     &lt;result name="success"&gt;good_result.ftl&lt;/result&gt;
 * &lt;/action&gt;
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 */
public class ScopeInterceptor extends AbstractInterceptor implements PreResultListener {

	private static final long serialVersionUID = 9120762699600054395L;

	private static final Log LOG = LogFactory.getLog(ScopeInterceptor.class);

    private String[] application = null;
    private String[] session = null;
    private String key;
    private String type = null;
    private boolean autoCreateSession = true;
    private String sessionReset = "session.reset";
    private boolean reset = false;

    /**
     * Sets a list of application scoped properties
     * 
     * @param s A comma-delimited list
     */
    public void setApplication(String s) {
        if (s != null) {
            application = s.split(" *, *");
        }
    }

    /**
     * Sets a list of session scoped properties
     * 
     * @param s A comma-delimited list
     */
    public void setSession(String s) {
        if (s != null) {
            session = s.split(" *, *");
        }
    }

    /**
     * Sets if the session should be automatically created
     * 
     * @param value True if it should be created
     */
    public void setAutoCreateSession(String value) {
        if (value != null && value.length() > 0) {
            this.autoCreateSession = new Boolean(value).booleanValue();
        }
    }

    private String getKey(ActionInvocation invocation) {
        ActionProxy proxy = invocation.getProxy();
        if (key == null || "CLASS".equals(key)) {
            return "struts.ScopeInterceptor:" + proxy.getAction().getClass();
        } else if ("ACTION".equals(key)) {
            return "struts.ScopeInterceptor:" + proxy.getNamespace() + ":" + proxy.getActionName();
        }
        return key;
    }

    /**
     * The constructor
     */
    public ScopeInterceptor() {
        super();
    }


    private static final Object NULL = new Object() {
        public String toString() {
            return "NULL";
        }
    };

    private static final Object nullConvert(Object o) {
        if (o == null) {
            return NULL;
        }

        if (o == NULL) {
            return null;
        }

        return o;
    }


    private static Map locks = new IdentityHashMap();

    static final void lock(Object o, ActionInvocation invocation) throws Exception {
        synchronized (o) {
            int count = 3;
            Object previous = null;
            while ((previous = locks.get(o)) != null) {
                if (previous == invocation) {
                    return;
                }
                if (count-- <= 0) {
                    locks.remove(o);
                    o.notify();

                    throw new StrutsException("Deadlock in session lock");
                }
                o.wait(10000);
            }
            ;
            locks.put(o, invocation);
        }
    }

    static final void unlock(Object o) {
        synchronized (o) {
            locks.remove(o);
            o.notify();
        }
    }

    protected void after(ActionInvocation invocation, String result) throws Exception {
        Map ses = ActionContext.getContext().getSession();
        if ( ses != null) {
            unlock(ses);
        }
    }


    protected void before(ActionInvocation invocation) throws Exception {
        invocation.addPreResultListener(this);
        Map ses = ActionContext.getContext().getSession();
        if (ses == null && autoCreateSession) {
            ses = new SessionMap(ServletActionContext.getRequest());
            ActionContext.getContext().setSession(ses);
        }

        if ( ses != null) {
            lock(ses, invocation);
        }

        String key = getKey(invocation);
        Map app = ActionContext.getContext().getApplication();
        final OgnlValueStack stack = ActionContext.getContext().getValueStack();

        if (LOG.isDebugEnabled()) {
            LOG.debug("scope interceptor before");
        }

        if (application != null)
            for (int i = 0; i < application.length; i++) {
                String string = application[i];
                Object attribute = app.get(key + string);
                if (attribute != null) {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug("application scoped variable set " + string + " = " + String.valueOf(attribute));
                    }

                    stack.setValue(string, nullConvert(attribute));
                }
            }

        if (ActionContext.getContext().getParameters().get(sessionReset) != null) {
            return;
        }

        if (reset) {
            return;
        }

        if (ses == null) {
            LOG.debug("No HttpSession created... Cannot set session scoped variables");
            return;
        }

        if (session != null && (!"start".equals(type))) {
            for (int i = 0; i < session.length; i++) {
                String string = session[i];
                Object attribute = ses.get(key + string);
                if (attribute != null) {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug("session scoped variable set " + string + " = " + String.valueOf(attribute));
                    }
                    stack.setValue(string, nullConvert(attribute));
                }
            }
        }
    }

    public void setKey(String key) {
        this.key = key;
    }

    /* (non-Javadoc)
     * @see com.opensymphony.xwork2.interceptor.PreResultListener#beforeResult(com.opensymphony.xwork2.ActionInvocation, java.lang.String)
     */
    public void beforeResult(ActionInvocation invocation, String resultCode) {
        String key = getKey(invocation);
        Map app = ActionContext.getContext().getApplication();
        final OgnlValueStack stack = ActionContext.getContext().getValueStack();

        if (application != null)
            for (int i = 0; i < application.length; i++) {
                String string = application[i];
                Object value = stack.findValue(string);
                if (LOG.isDebugEnabled()) {
                    LOG.debug("application scoped variable saved " + string + " = " + String.valueOf(value));
                }

                //if( value != null)
                app.put(key + string, nullConvert(value));
            }

        boolean ends = "end".equals(type);

        Map ses = ActionContext.getContext().getSession();
        if (ses != null) {

            if (session != null) {
                for (int i = 0; i < session.length; i++) {
                    String string = session[i];
                    if (ends) {
                        ses.remove(key + string);
                    } else {
                        Object value = stack.findValue(string);

                        if (LOG.isDebugEnabled()) {
                            LOG.debug("session scoped variable saved " + string + " = " + String.valueOf(value));
                        }

                        // Null value should be scoped too
                        //if( value != null)
                        ses.put(key + string, nullConvert(value));
                    }
                }
            }
            unlock(ses);
        } else {
            LOG.debug("No HttpSession created... Cannot save session scoped variables.");
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug("scope interceptor after (before result)");
        }
    }

    /**
     * @return The type of scope operation, "start" or "end"
     */      
    public String getType() {
        return type;
    }

    /**
     * Sets the type of scope operation
     * 
     * @param type Either "start" or "end"
     */
    public void setType(String type) {
        type = type.toLowerCase();
        if ("start".equals(type) || "end".equals(type)) {
            this.type = type;
        } else {
            throw new IllegalArgumentException("Only start or end are allowed arguments for type");
        }
    }

    /**
     * @return Gets the session reset parameter name
     */
    public String getSessionReset() {
        return sessionReset;
    }

    /**
     * @param sessionReset The session reset parameter name
     */
    public void setSessionReset(String sessionReset) {
        this.sessionReset = sessionReset;
    }

    /* (non-Javadoc)
     * @see com.opensymphony.xwork2.interceptor.Interceptor#intercept(com.opensymphony.xwork2.ActionInvocation)
     */
    public String intercept(ActionInvocation invocation) throws Exception {
        String result = null;
        Map ses = ActionContext.getContext().getSession();
        before(invocation);
        try {
            result = invocation.invoke();
            after(invocation, result);
        } finally {
            if (ses != null) {
                unlock(ses);
            }
        }

        return result;
    }

    /**
     * @return True if the scope is reset
     */
    public boolean isReset() {
        return reset;
    }

    /**
     * @param reset True if the scope should be reset
     */
    public void setReset(boolean reset) {
        this.reset = reset;
    }
}
"
core/src/main/java/org/apache/struts2/interceptor/ServletConfigInterceptor.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.interceptor;

import java.util.Map;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.StrutsStatics;
import org.apache.struts2.util.ServletContextAware;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.interceptor.AbstractInterceptor;


/**
 * <!-- START SNIPPET: description -->
 *
 * An interceptor which sets action properties based on the interfaces an action implements. For example, if the action
 * implements {@link ParameterAware} then the action context's parameter map will be set on it.
 *
 * <p/> This interceptor is designed to set all properties an action needs if it's aware of servlet parameters, the
 * servlet context, the session, etc. Interfaces that it supports are:
 *
 * <ul>
 *
 * <li>{@link ServletContextAware}</li>
 *
 * <li>{@link ServletRequestAware}</li>
 *
 * <li>{@link ServletResponseAware}</li>
 *
 * <li>{@link ParameterAware}</li>
 * 
 * <li>{@link RequestAware}</li>
 *
 * <li>{@link SessionAware}</li>
 *
 * <li>{@link ApplicationAware}</li>
 *
 * <li>{@link PrincipalAware}</li>
 *
 * </ul>
 *
 * <!-- END SNIPPET: description -->
 *
 * <p/> <u>Interceptor parameters:</u>
 *
 * <!-- START SNIPPET: parameters -->
 *
 * <ul>
 *
 * <li>None</li>
 *
 * </ul>
 *
 * <!-- END SNIPPET: parameters -->
 *
 * <p/> <u>Extending the interceptor:</u>
 *
 * <p/>
 *
 * <!-- START SNIPPET: extending -->
 *
 * There are no known extension points for this interceptor.
 *
 * <!-- END SNIPPET: extending -->
 *
 * <p/> <u>Example code:</u>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * &lt;action name="someAction" class="com.examples.SomeAction"&gt;
 *     &lt;interceptor-ref name="servlet-config"/&gt;
 *     &lt;interceptor-ref name="basicStack"/&gt;
 *     &lt;result name="success"&gt;good_result.ftl&lt;/result&gt;
 * &lt;/action&gt;
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @see ServletContextAware
 * @see ServletRequestAware
 * @see ServletResponseAware
 * @see ParameterAware
 * @see SessionAware
 * @see ApplicationAware
 * @see PrincipalAware
 */
public class ServletConfigInterceptor extends AbstractInterceptor implements StrutsStatics {
	
	private static final long serialVersionUID = 605261777858676638L;

    /**
     * Sets action properties based on the interfaces an action implements. Things like application properties,
     * parameters, session attributes, etc are set based on the implementing interface.
     *
     * @param invocation an encapsulation of the action execution state.
     * @throws Exception if an error occurs when setting action properties.
     */
    public String intercept(ActionInvocation invocation) throws Exception {
        final Object action = invocation.getAction();
        final ActionContext context = invocation.getInvocationContext();

        if (action instanceof ServletRequestAware) {
            HttpServletRequest request = (HttpServletRequest) context.get(HTTP_REQUEST);
            ((ServletRequestAware) action).setServletRequest(request);
        }

        if (action instanceof ServletResponseAware) {
            HttpServletResponse response = (HttpServletResponse) context.get(HTTP_RESPONSE);
            ((ServletResponseAware) action).setServletResponse(response);
        }

        if (action instanceof ParameterAware) {
            ((ParameterAware) action).setParameters(context.getParameters());
        }
        
        if (action instanceof RequestAware) {
        	((RequestAware) action).setRequest((Map) context.get("request"));
        }

        if (action instanceof SessionAware) {
            ((SessionAware) action).setSession(context.getSession());
        }

        if (action instanceof ApplicationAware) {
            ((ApplicationAware) action).setApplication(context.getApplication());
        }

        if (action instanceof PrincipalAware) {
            HttpServletRequest request = (HttpServletRequest) context.get(HTTP_REQUEST);
            ((PrincipalAware) action).setPrincipalProxy(new PrincipalProxy(request));
        }
        if (action instanceof ServletContextAware) {
            ServletContext servletContext = (ServletContext) context.get(SERVLET_CONTEXT);
            ((ServletContextAware) action).setServletContext(servletContext);
        }
        return invocation.invoke();
    }
}
"
core/src/main/java/org/apache/struts2/interceptor/ServletRequestAware.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.interceptor;

import javax.servlet.http.HttpServletRequest;


/**
 * All Actions that want to have access to the servlet request object must implement this interface.<p>
 * <p/>
 * This interface is only relevant if the Action is used in a servlet environment. <p>
 * <p/>
 * Note that using this interface makes the Action tied to a servlet environment, so it should be
 * avoided if possible since things like unit testing will become more difficult.
 *
 */
public interface ServletRequestAware {

    /**
     * Sets the HTTP request object in implementing classes.
     *
     * @param request the HTTP request.
     */
    public void setServletRequest(HttpServletRequest request);
}
"
core/src/main/java/org/apache/struts2/interceptor/ServletResponseAware.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.interceptor;

import javax.servlet.http.HttpServletResponse;


/**
 * All Actions that want to have access to the servlet response object must implement this interface.<p>
 * <p/>
 * This interface is only relevant if the Action is used in a servlet environment.<p>
 * <p/>
 * Note that using this interface makes the Action tied to a servlet environment, so it should be
 * avoided if possible since things like unit testing will become more difficult.
 *
 */
public interface ServletResponseAware {

    /**
     * Sets the HTTP response object in implementing classes.
     *
     * @param response the HTTP response.
     */
    public void setServletResponse(HttpServletResponse response);
}
"
core/src/main/java/org/apache/struts2/interceptor/SessionAware.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.interceptor;

import java.util.Map;


/**
 * Actions that want access to the user's HTTP session should implement this interface.<p>
 * <p/>
 * This interface is only relevant if the Action is used in a servlet environment.<p>
 * <p/>
 * Note that using this interface makes the Action tied to a servlet environment, so it should be
 * avoided if possible since things like unit testing will become more difficult.
 *
 */
public interface SessionAware {

    /**
     * Sets the Map of session attributes in the implementing class.
     *
     * @param session a Map of HTTP session attribute name/value pairs.
     */
    public void setSession(Map session);
}
"
core/src/main/java/org/apache/struts2/interceptor/StrutsConversionErrorInterceptor.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.interceptor;

import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.interceptor.ConversionErrorInterceptor;
import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * <!-- START SNIPPET: description -->
 *
 * This interceptor extends {@link ConversionErrorInterceptor} but only adds conversion errors from the ActionContext to
 * the field errors of the action if the field value is not null, "", or {""} (a size 1 String array with only an empty
 * String). See {@link ConversionErrorInterceptor} for more information, as well as the Type Conversion documentation.
 *
 * <!-- END SNIPPET: description -->
 *
 * <p/> <u>Interceptor parameters:</u>
 *
 * <!-- START SNIPPET: parameters -->
 *
 * <ul>
 *
 * <li>None</li>
 *
 * </ul>
 *
 * <!-- END SNIPPET: parameters -->
 *
 * <p/> <u>Extending the interceptor:</u>
 *
 * <p/>
 *
 * <!-- START SNIPPET: extending -->
 *
 * There are no known extension points for this interceptor.
 *
 * <!-- END SNIPPET: extending -->
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * &lt;action name="someAction" class="com.examples.SomeAction"&gt;
 *     &lt;interceptor-ref name="params"/&gt;
 *     &lt;interceptor-ref name="conversionError"/&gt;
 *     &lt;result name="success"&gt;good_result.ftl&lt;/result&gt;
 * &lt;/action&gt;
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @see com.opensymphony.xwork2.ActionContext#getConversionErrors()
 * @see ConversionErrorInterceptor
 */
public class StrutsConversionErrorInterceptor extends ConversionErrorInterceptor {
	
	private static final long serialVersionUID = 2759744840082921602L;

	protected Object getOverrideExpr(ActionInvocation invocation, Object value) {
        OgnlValueStack stack = invocation.getStack();

        try {
            stack.push(value);

            return "'" + stack.findValue("top", String.class) + "'";
        } finally {
            stack.pop();
        }
    }

    /**
     * Returns <tt>false</tt> if the value is null, "", or {""} (array of size 1 with a blank element). Returns
     * <tt>true</tt> otherwise.
     *
     * @param propertyName the name of the property to check.
     * @param value        the value to error check.
     * @return <tt>false</tt>  if the value is null, "", or {""}, <tt>true</tt> otherwise.
     */
    protected boolean shouldAddError(String propertyName, Object value) {
        if (value == null) {
            return false;
        }

        if ("".equals(value)) {
            return false;
        }

        if (value instanceof String[]) {
            String[] array = (String[]) value;

            if (array.length == 0) {
                return false;
            }

            if (array.length > 1) {
                return true;
            }

            String str = array[0];

            if ("".equals(str)) {
                return false;
            }
        }

        return true;
    }
}
"
core/src/main/java/org/apache/struts2/interceptor/TokenInterceptor.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.interceptor;

import java.util.Map;

import org.apache.struts2.util.TokenHelper;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.ValidationAware;
import com.opensymphony.xwork2.interceptor.MethodFilterInterceptor;
import com.opensymphony.xwork2.util.LocalizedTextUtil;

/**
 * <!-- START SNIPPET: description -->
 *
 * Ensures that only one request per token is processed. This interceptor can make sure that back buttons and double
 * clicks don't cause un-intended side affects. For example, you can use this to prevent careless users who might double
 * click on a "checkout" button at an online store. This interceptor uses a fairly primitive technique for when an
 * invalid token is found: it returns the result <b>invalid.token</b>, which can be mapped in your action configuration.
 * A more complex implementation, {@link TokenSessionStoreInterceptor}, can provide much better logic for when invalid
 * tokens are found.
 * 
 * <p/>
 *
 * <b>Note:</b> To set a token in your form, you should use the <b>token tag</b>. This tag is required and must be used
 * in the forms that submit to actions protected by this interceptor. Any request that does not provide a token (using
 * the token tag) will be processed as a request with an invalid token.
 * 
 * <p/>
 * 
 * <b>Internationalization Note:</b> The following key could be used to internationalized the action errors generated
 * by this token interceptor
 * 
 * <ul>
 *    <li>struts.messages.invalid.token</li>
 * </ul>
 * 
 * <p/>
 * 
 * <b>NOTE:</b> As this method extends off MethodFilterInterceptor, it is capable of
 * deciding if it is applicable only to selective methods in the action class. See
 * <code>MethodFilterInterceptor</code> for more info.
 *
 * <!-- END SNIPPET: description -->
 *
 * <p/> <u>Interceptor parameters:</u>
 *
 * <!-- START SNIPPET: parameters -->
 *
 * <ul>
 *
 * <li>None</li>
 *
 * </ul>
 *
 * <!-- END SNIPPET: parameters -->
 *
 * <p/> <u>Extending the interceptor:</u>
 *
 * <p/>
 *
 * <!-- START SNIPPET: extending -->
 *
 * While not very common for users to extend, this interceptor is extended by the {@link TokenSessionStoreInterceptor}.
 * The {@link #handleInvalidToken}  and {@link #handleValidToken} methods are protected and available for more
 * interesting logic, such as done with the token session interceptor.
 *
 * <!-- END SNIPPET: extending -->
 *
 * <p/> <u>Example code:</u>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * 
 * &lt;action name="someAction" class="com.examples.SomeAction"&gt;
 *     &lt;interceptor-ref name="token"/&gt;
 *     &lt;interceptor-ref name="basicStack"/&gt;
 *     &lt;result name="success"&gt;good_result.ftl&lt;/result&gt;
 * &lt;/action&gt;
 * 
 * &lt;-- In this case, myMethod of the action class will not 
 *        get checked for invalidity of token --&gt;
 * &lt;action name="someAction" class="com.examples.SomeAction"&gt;
 *     &lt;interceptor-ref name="token"&gt;
 *     	  &lt;param name="excludeMethods"&gt;myMethod&lt;/param&gt;
 *     &lt;/interceptor-ref name="token"/&gt;
 *     &lt;interceptor-ref name="basicStack"/&gt;
 *     &lt;result name="success"&gt;good_result.ftl&lt;/result&gt;
 * &lt;/action&gt;
 * 
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 * @see TokenSessionStoreInterceptor
 * @see TokenHelper
 */
public class TokenInterceptor extends MethodFilterInterceptor {
	
	private static final long serialVersionUID = -6680894220590585506L;
	
	public static final String INVALID_TOKEN_CODE = "invalid.token";

    /**
     * @see com.opensymphony.xwork2.interceptor.MethodFilterInterceptor#doIntercept(com.opensymphony.xwork2.ActionInvocation)
     */
    protected String doIntercept(ActionInvocation invocation) throws Exception {
        if (log.isDebugEnabled()) {
            log.debug("Intercepting invocation to check for valid transaction token.");
        }

        Map session = ActionContext.getContext().getSession();

        synchronized (session) {
            if (!TokenHelper.validToken()) {
                return handleInvalidToken(invocation);
            }

            return handleValidToken(invocation);
        }
    }

    /**
     * Determines what to do if an invalida token is provided. If the action implements {@link ValidationAware}
     *
     * @param invocation the action invocation where the invalid token failed
     * @return the return code to indicate should be processed
     * @throws Exception when any unexpected error occurs.
     */
    protected String handleInvalidToken(ActionInvocation invocation) throws Exception {
        Object action = invocation.getAction();
        String errorMessage = LocalizedTextUtil.findText(this.getClass(), "struts.messages.invalid.token",
                invocation.getInvocationContext().getLocale(),
                "The form has already been processed or no token was supplied, please try again.", new Object[0]);

        if (action instanceof ValidationAware) {
            ((ValidationAware) action).addActionError(errorMessage);
        } else {
            log.warn(errorMessage);
        }

        return INVALID_TOKEN_CODE;
    }

    /**
     * Called when a valid token is found. This method invokes the action by can be changed to do something more
     * interesting.
     *
     * @param invocation the action invocation
     * @throws Exception when any unexpected error occurs.
     */
    protected String handleValidToken(ActionInvocation invocation) throws Exception {
        return invocation.invoke();
    }
}
"
core/src/main/java/org/apache/struts2/interceptor/TokenSessionStoreInterceptor.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.interceptor;

import java.util.Map;

import javax.servlet.http.HttpServletRequest;

import org.apache.struts2.ServletActionContext;
import org.apache.struts2.util.InvocationSessionStore;
import org.apache.struts2.util.TokenHelper;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.Result;
import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * <!-- START SNIPPET: description -->
 *
 * This interceptor builds off of the {@link TokenInterceptor}, providing advanced logic for handling invalid tokens.
 * Unlike the normal token interceptor, this interceptor will attempt to provide intelligent fail-over in the event of
 * multiple requests using the same session. That is, it will block subsequent requests until the first request is
 * complete, and then instead of returning the <i>invalid.token</i> code, it will attempt to display the same response
 * that the original, valid action invocation would have displayed if no multiple requests were submitted in the first
 * place.
 * 
 * <p/>
 * 
 * <b>NOTE:</b> As this method extends off MethodFilterInterceptor, it is capable of
 * deciding if it is applicable only to selective methods in the action class. See
 * <code>MethodFilterInterceptor</code> for more info.
 *
 * <!-- END SNIPPET: description -->
 *
 * <p/> <u>Interceptor parameters:</u>
 *
 * <!-- START SNIPPET: parameters -->
 *
 * <ul>
 *
 * <li>None</li>
 *
 * </ul>
 *
 * <!-- END SNIPPET: parameters -->
 *
 * <p/> <u>Extending the interceptor:</u>
 *
 * <p/>
 *
 * <!-- START SNIPPET: extending -->
 *
 * There are no known extension points for this interceptor.
 *
 * <!-- END SNIPPET: extending -->
 *
 * <p/> <u>Example code:</u>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * 
 * &lt;action name="someAction" class="com.examples.SomeAction"&gt;
 *     &lt;interceptor-ref name="token-session/&gt;
 *     &lt;interceptor-ref name="basicStack"/&gt;
 *     &lt;result name="success"&gt;good_result.ftl&lt;/result&gt;
 * &lt;/action&gt;
 * 
 * &lt;-- In this case, myMethod of the action class will not 
 *        get checked for invalidity of token --&gt;
 * &lt;action name="someAction" class="com.examples.SomeAction"&gt;
 *     &lt;interceptor-ref name="token-session&gt;
 *         &lt;param name="excludeMethods"&gt;myMethod&lt;/param&gt;
 *     &lt;/interceptor-ref name="token-session&gt;
 *     &lt;interceptor-ref name="basicStack"/&gt;
 *     &lt;result name="success"&gt;good_result.ftl&lt;/result&gt;
 * &lt;/action&gt;
 * 
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 */
public class TokenSessionStoreInterceptor extends TokenInterceptor {
	
	private static final long serialVersionUID = -9032347965469098195L;

	/* (non-Javadoc)
	 * @see org.apache.struts2.interceptor.TokenInterceptor#handleInvalidToken(com.opensymphony.xwork2.ActionInvocation)
	 */
	protected String handleInvalidToken(ActionInvocation invocation) throws Exception {
        ActionContext ac = invocation.getInvocationContext();

        HttpServletRequest request = (HttpServletRequest) ac.get(ServletActionContext.HTTP_REQUEST);
        String tokenName = TokenHelper.getTokenName();
        String token = TokenHelper.getToken(tokenName);

        Map params = ac.getParameters();
        params.remove(tokenName);
        params.remove(TokenHelper.TOKEN_NAME_FIELD);

        if ((tokenName != null) && (token != null)) {
            ActionInvocation savedInvocation = InvocationSessionStore.loadInvocation(tokenName, token);

            if (savedInvocation != null) {
                // set the valuestack to the request scope
                OgnlValueStack stack = savedInvocation.getStack();
                request.setAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY, stack);

                Result result = savedInvocation.getResult();

                if ((result != null) && (savedInvocation.getProxy().getExecuteResult())) {
                    result.execute(savedInvocation);
                }

                // turn off execution of this invocations result
                invocation.getProxy().setExecuteResult(false);

                return savedInvocation.getResultCode();
            }
        }

        return INVALID_TOKEN_CODE;
    }

    /* (non-Javadoc)
     * @see org.apache.struts2.interceptor.TokenInterceptor#handleValidToken(com.opensymphony.xwork2.ActionInvocation)
     */
    protected String handleValidToken(ActionInvocation invocation) throws Exception {
        // we know the token name and token must be there
        String key = TokenHelper.getTokenName();
        String token = TokenHelper.getToken(key);
        InvocationSessionStore.storeInvocation(key, token, invocation);

        return invocation.invoke();
    }
}
"
core/src/main/java/org/apache/struts2/interceptor/debugging/DebuggingInterceptor.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.interceptor.debugging;

import java.beans.BeanInfo;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.ServletActionContext;
import org.apache.struts2.views.freemarker.FreemarkerResult;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.interceptor.Interceptor;
import com.opensymphony.xwork2.interceptor.PreResultListener;
import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * Provides several different debugging screens to provide insight into the
 * data behind the page. The value of the 'debug' request parameter determines
 * the screen:
 * <ul>
 * <li> <code>xml</code> - Dumps the parameters, context, session, and value
 * stack as an XML document.</li>
 * <li> <code>console</code> - Shows a popup 'OGNL Console' that allows the
 * user to test OGNL expressions against the value stack. The XML data from
 * the 'xml' mode is inserted at the top of the page.</li>
 * <li> <code>command</code> - Tests an OGNL expression and returns the
 * string result. Only used by the OGNL console.</li>
 * </ul>
 * <p/>
 * <p/>
 * This interceptor only is activated when devMode is enabled in
 * struts.properties. The 'debug' parameter is removed from the parameter list
 * before the action is executed. All operations occur before the natural
 * Result has a chance to execute. </p>
 */
public class DebuggingInterceptor implements Interceptor {

    private static final long serialVersionUID = -3097324155953078783L;

    private final static Log log = LogFactory.getLog(DebuggingInterceptor.class);

    private String[] ignorePrefixes = new String[]{"org.apache.struts.",
            "com.opensymphony.xwork2.", "xwork."};
    private String[] _ignoreKeys = new String[]{"application", "session",
            "parameters", "request"};
    private HashSet<String> ignoreKeys = new HashSet<String>(Arrays.asList(_ignoreKeys));

    private final static String XML_MODE = "xml";
    private final static String CONSOLE_MODE = "console";
    private final static String COMMAND_MODE = "command";

    private final static String SESSION_KEY = "org.apache.struts2.interceptor.debugging.VALUE_STACK";

    private final static String DEBUG_PARAM = "debug";
    private final static String EXPRESSION_PARAM = "expression";


    /**
     * Unused.
     */
    public void init() {
    }


    /**
     * Unused.
     */
    public void destroy() {
    }


    /*
     * (non-Javadoc)
     *
     * @see com.opensymphony.xwork2.interceptor.Interceptor#invoke(com.opensymphony.xwork2.ActionInvocation)
     */
    public String intercept(ActionInvocation inv) throws Exception {

        Boolean devMode = (Boolean) ActionContext.getContext().get(
                ActionContext.DEV_MODE);
        boolean cont = true;
        if (devMode) {
            final ActionContext ctx = ActionContext.getContext();
            String type = getParameter(DEBUG_PARAM);
            ctx.getParameters().remove(DEBUG_PARAM);
            if (XML_MODE.equals(type)) {
                inv.addPreResultListener(
                        new PreResultListener() {
                            public void beforeResult(ActionInvocation inv, String result) {
                                printContext();
                            }
                        });
            } else if (CONSOLE_MODE.equals(type)) {
                inv.addPreResultListener(
                        new PreResultListener() {
                            public void beforeResult(ActionInvocation inv, String actionResult) {
                                StringWriter writer = new StringWriter();
                                printContext(new PrettyPrintWriter(writer));
                                String xml = writer.toString();
                                xml = xml.replaceAll("&", "&amp;");
                                xml = xml.replaceAll(">", "&gt;");
                                xml = xml.replaceAll("<", "&lt;");
                                ActionContext.getContext().put("debugXML", xml);

                                FreemarkerResult result = new FreemarkerResult();
                                result.setContentType("text/html");
                                result.setLocation("/org/apache/struts2/interceptor/debugging/console.ftl");
                                result.setParse(false);
                                try {
                                    result.execute(inv);
                                } catch (Exception ex) {
                                    log.error("Unable to create debugging console", ex);
                                }

                            }
                        });
            } else if (COMMAND_MODE.equals(type)) {
                OgnlValueStack stack = (OgnlValueStack) ctx.getSession().get(SESSION_KEY);
                String cmd = getParameter(EXPRESSION_PARAM);

                HttpServletResponse res = ServletActionContext.getResponse();
                res.setContentType("text/plain");

                try {
                    PrintWriter writer =
                            ServletActionContext.getResponse().getWriter();
                    writer.print(stack.findValue(cmd));
                    writer.close();
                } catch (IOException ex) {
                    ex.printStackTrace();
                }
                cont = false;
            }
        }
        if (cont) {
            try {
                return inv.invoke();
            } finally {
                if (devMode) {
                    final ActionContext ctx = ActionContext.getContext();
                    ctx.getSession().put(SESSION_KEY, ctx.get(ActionContext.VALUE_STACK));
                }
            }
        } else {
            return null;
        }
    }


    /**
     * Gets a single string from the request parameters
     *
     * @param key The key
     * @return The parameter value
     */
    private String getParameter(String key) {
        String[] arr = (String[]) ActionContext.getContext().getParameters().get(key);
        if (arr != null && arr.length > 0) {
            return arr[0];
        }
        return null;
    }


    /**
     * Prints the current context to the response in XML format.
     */
    protected void printContext() {
        HttpServletResponse res = ServletActionContext.getResponse();
        res.setContentType("text/xml");

        try {
            PrettyPrintWriter writer = new PrettyPrintWriter(
                    ServletActionContext.getResponse().getWriter());
            printContext(writer);
            writer.close();
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }


    /**
     * Prints the current request to the existing writer.
     *
     * @param writer The XML writer
     */
    protected void printContext(PrettyPrintWriter writer) {
        ActionContext ctx = ActionContext.getContext();
        writer.startNode(DEBUG_PARAM);
        serializeIt(ctx.getParameters(), "parameters", writer,
                new ArrayList<Object>());
        writer.startNode("context");
        String key;
        Map ctxMap = ctx.getContextMap();
        for (Object o : ctxMap.keySet()) {
            key = o.toString();
            boolean print = !ignoreKeys.contains(key);

            for (String ignorePrefixe : ignorePrefixes) {
                if (key.startsWith(ignorePrefixe)) {
                    print = false;
                    break;
                }
            }
            if (print) {
                serializeIt(ctxMap.get(key), key, writer, new ArrayList<Object>());
            }
        }
        writer.endNode();
        serializeIt(ctx.getSession(), "request", writer, new ArrayList<Object>());
        serializeIt(ctx.getSession(), "session", writer, new ArrayList<Object>());

        OgnlValueStack stack = (OgnlValueStack) ctx.get(ActionContext.VALUE_STACK);
        serializeIt(stack.getRoot(), "valueStack", writer, new ArrayList<Object>());
        writer.endNode();
    }


    /**
     * Recursive function to serialize objects to XML. Currently it will
     * serialize Collections, maps, Arrays, and JavaBeans. It maintains a stack
     * of objects serialized already in the current functioncall. This is used
     * to avoid looping (stack overflow) of circular linked objects. Struts and
     * XWork objects are ignored.
     *
     * @param bean   The object you want serialized.
     * @param name   The name of the object, used for element &lt;name/&gt;
     * @param writer The XML writer
     * @param stack  List of objects we're serializing since the first calling
     *               of this function (to prevent looping on circular references).
     */
    protected void serializeIt(Object bean, String name,
                               PrettyPrintWriter writer, List<Object> stack) {
        writer.flush();
        // Check stack for this object
        if ((bean != null) && (stack.contains(bean))) {
            if (log.isInfoEnabled()) {
                log.info("Circular reference detected, not serializing object: "
                        + name);
            }
            return;
        } else if (bean != null) {
            // Push object onto stack.
            // Don't push null objects ( handled below)
            stack.add(bean);
        }
        if (bean == null) {
            return;
        }
        String clsName = bean.getClass().getName();

        writer.startNode(name);

        // It depends on the object and it's value what todo next:
        if (bean instanceof Collection) {
            Collection col = (Collection) bean;

            // Iterate through components, and call ourselves to process
            // elements
            for (Object aCol : col) {
                serializeIt(aCol, "value", writer, stack);
            }
        } else if (bean instanceof Map) {

            Map map = (Map) bean;

            // Loop through keys and call ourselves
            for (Object key : map.keySet()) {
                Object Objvalue = map.get(key);
                serializeIt(Objvalue, key.toString(), writer, stack);
            }
        } else if (bean.getClass().isArray()) {
            // It's an array, loop through it and keep calling ourselves
            for (int i = 0; i < Array.getLength(bean); i++) {
                serializeIt(Array.get(bean, i), "arrayitem", writer, stack);
            }
        } else {
            if (clsName.startsWith("java.lang")) {
                writer.setValue(bean.toString());
            } else {
                // Not java.lang, so we can call ourselves with this object's
                // values
                try {
                    BeanInfo info = Introspector.getBeanInfo(bean.getClass());
                    PropertyDescriptor[] props = info.getPropertyDescriptors();

                    for (PropertyDescriptor prop : props) {
                        String n = prop.getName();
                        Method m = prop.getReadMethod();

                        // Call ourselves with the result of the method
                        // invocation
                        if (m != null) {
                            serializeIt(m.invoke(bean), n, writer, stack);
                        }
                    }
                } catch (Exception e) {
                    log.error(e, e);
                }
            }
        }

        writer.endNode();

        // Remove object from stack
        stack.remove(bean);
    }

}

"
core/src/main/java/org/apache/struts2/interceptor/debugging/PrettyPrintWriter.java,false,"package org.apache.struts2.interceptor.debugging;

import java.io.PrintWriter;
import java.io.Writer;
import java.util.Stack;

/**
 * A simple writer that outputs XML in a pretty-printed indented stream.
 *
 * <p>By default, the chars <code><xmp>& < > " ' \r</xmp></code> are escaped and replaced with a suitable XML entity.
 * To alter this behavior, override the the {@link #writeText(com.thoughtworks.xstream.core.util.QuickWriter, String)}
 * and {@link #writeAttributeValue(com.thoughtworks.xstream.core.util.QuickWriter, String)} methods.</p>
 *
 * <p>This code was taken from the XStream project under the BSD license.</p>
 *
 */
public class PrettyPrintWriter {

    private final PrintWriter writer;
    private final Stack<String> elementStack = new Stack<String>();
    private final char[] lineIndenter;

    private boolean tagInProgress;
    private int depth;
    private boolean readyForNewLine;
    private boolean tagIsEmpty;
    private String newLine;

    private static final char[] NULL = "&#x0;".toCharArray();
    private static final char[] AMP = "&amp;".toCharArray();
    private static final char[] LT = "&lt;".toCharArray();
    private static final char[] GT = "&gt;".toCharArray();
    private static final char[] SLASH_R = "&#x0D;".toCharArray();
    private static final char[] QUOT = "&quot;".toCharArray();
    private static final char[] APOS = "&apos;".toCharArray();
    private static final char[] CLOSE = "</".toCharArray();

    public PrettyPrintWriter(Writer writer, char[] lineIndenter, String newLine) {
        this.writer = new PrintWriter(writer);
        this.lineIndenter = lineIndenter;
        this.newLine = newLine;
    }

    public PrettyPrintWriter(Writer writer, char[] lineIndenter) {
        this(writer, lineIndenter, "\n");
    }

    public PrettyPrintWriter(Writer writer, String lineIndenter, String newLine) {
        this(writer, lineIndenter.toCharArray(), newLine);
    }

    public PrettyPrintWriter(Writer writer, String lineIndenter) {
        this(writer, lineIndenter.toCharArray());
    }

    public PrettyPrintWriter(Writer writer) {
        this(writer, new char[]{' ', ' '});
    }

    public void startNode(String name) {
        tagIsEmpty = false;
        finishTag();
        writer.write('<');
        writer.write(name);
        elementStack.push(name);
        tagInProgress = true;
        depth++;
        readyForNewLine = true;
        tagIsEmpty = true;
    }

    public void setValue(String text) {
        readyForNewLine = false;
        tagIsEmpty = false;
        finishTag();

        writeText(writer, text);
    }

    public void addAttribute(String key, String value) {
        writer.write(' ');
        writer.write(key);
        writer.write('=');
        writer.write('\"');
        writeAttributeValue(writer, value);
        writer.write('\"');
    }

    protected void writeAttributeValue(PrintWriter writer, String text) {
        writeText(text);
    }

    protected void writeText(PrintWriter writer, String text) {
        writeText(text);
    }

    private void writeText(String text) {
        int length = text.length();
        for (int i = 0; i < length; i++) {
            char c = text.charAt(i);
            switch (c) {
                case '\0':
                    this.writer.write(NULL);
                    break;
                case '&':
                    this.writer.write(AMP);
                    break;
                case '<':
                    this.writer.write(LT);
                    break;
                case '>':
                    this.writer.write(GT);
                    break;
                case '"':
                    this.writer.write(QUOT);
                    break;
                case '\'':
                    this.writer.write(APOS);
                    break;
                case '\r':
                    this.writer.write(SLASH_R);
                    break;
                default:
                    this.writer.write(c);
            }
        }
    }

    public void endNode() {
        depth--;
        if (tagIsEmpty) {
            writer.write('/');
            readyForNewLine = false;
            finishTag();
            elementStack.pop();
        } else {
            finishTag();
            writer.write(CLOSE);
            writer.write((String)elementStack.pop());
            writer.write('>');
        }
        readyForNewLine = true;
        if (depth == 0 ) {
            writer.flush();
        }
    }

    private void finishTag() {
        if (tagInProgress) {
            writer.write('>');
        }
        tagInProgress = false;
        if (readyForNewLine) {
            endOfLine();
        }
        readyForNewLine = false;
        tagIsEmpty = false;
    }

    protected void endOfLine() {
        writer.write(newLine);
        for (int i = 0; i < depth; i++) {
            writer.write(lineIndenter);
        }
    }

    public void flush() {
        writer.flush();
    }

    public void close() {
        writer.close();
    }
}
"
core/src/main/java/org/apache/struts2/jsf/ApplyRequestValuesInterceptor.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.jsf;

import javax.faces.FacesException;
import javax.faces.context.FacesContext;
import javax.faces.event.PhaseId;

/**
 * Applies the request values to the component tree
 */
public class ApplyRequestValuesInterceptor extends FacesInterceptor {

    private static final long serialVersionUID = -1471180154211835323L;

    /**
     * Apply Request Values (JSF.2.2.2)
     * 
     * @param viewId
     *            The view id
     * @param facesContext
     *            The faces context
     * @return true, if response is complete
     */
    protected boolean executePhase(String viewId, FacesContext facesContext)
            throws FacesException {
        boolean skipFurtherProcessing = false;
        if (log.isTraceEnabled())
            log.trace("entering applyRequestValues");

        informPhaseListenersBefore(facesContext, PhaseId.APPLY_REQUEST_VALUES);

        try {
            if (isResponseComplete(facesContext, "applyRequestValues", true)) {
                // have to return right away
                return true;
            }
            if (shouldRenderResponse(facesContext, "applyRequestValues", true)) {
                skipFurtherProcessing = true;
            }

            facesContext.getViewRoot().processDecodes(facesContext);
        } finally {
            informPhaseListenersAfter(facesContext,
                    PhaseId.APPLY_REQUEST_VALUES);
        }

        if (isResponseComplete(facesContext, "applyRequestValues", false)
                || shouldRenderResponse(facesContext, "applyRequestValues",
                        false)) {
            // since this phase is completed we don't need to return right away
            // even if the response is completed
            skipFurtherProcessing = true;
        }

        if (!skipFurtherProcessing && log.isTraceEnabled())
            log.trace("exiting applyRequestValues");
        return skipFurtherProcessing;
    }
}
"
core/src/main/java/org/apache/struts2/jsf/FacesInterceptor.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.jsf;

import javax.faces.context.FacesContext;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.interceptor.Interceptor;

/**
 * Translates JSF phases into individual interceptors, and adapts their expected
 * workflow to Action 2
 */
public class FacesInterceptor extends FacesSupport implements Interceptor {

    private static final long serialVersionUID = -5418255964277566516L;

    /**
     * Not used
     */
    public void init() {
    }

    /**
     * Adapts the phase workflow to Action 2
     * 
     * @param invocation
     *            The action invocation
     * @return The string result code
     */
    public String intercept(ActionInvocation invocation) throws Exception {

        if (isFacesEnabled(invocation.getInvocationContext())) {
            FacesContext context = FacesContext.getCurrentInstance();

            if (context.getRenderResponse()) {
                return invocation.invoke();
            } else {

                String viewId = invocation.getProxy().getNamespace() + '/'
                        + invocation.getProxy().getActionName();
                executePhase(viewId, context);

                if (context.getResponseComplete()) {
                    // Abort the chain as the result is done
                    return null;
                } else {
                    if (invocation.getResultCode() != null) {
                        return invocation.getResultCode();
                    } else {
                        return invocation.invoke();
                    }
                }
            }
        } else {
            return invocation.invoke();
        }
    }

    /**
     * Executes the specific phase. The phase id is constructed as a composite
     * of the namespace and action name.
     * 
     * @param viewId
     *            The view id
     * @param facesContext
     *            The current faces context
     * @return True if the next phases should be skipped
     */
    protected boolean executePhase(String viewId, FacesContext facesContext) {
        return false;
    }

    /**
     * Not used
     */
    public void destroy() {
    }

    /**
     * Determines whether to process this request with the JSF phases
     * 
     * @param ctx The current action context
     * @return True if it is a faces-enabled request
     */
    protected boolean isFacesEnabled(ActionContext ctx) {
        return ctx.get(FACES_ENABLED) != null;
    }

}"
core/src/main/java/org/apache/struts2/jsf/FacesRender.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.jsf;

import java.io.IOException;

import javax.faces.FacesException;
import javax.faces.application.Application;
import javax.faces.application.ViewHandler;
import javax.faces.context.FacesContext;
import javax.faces.event.PhaseId;

/**
 * Performs the JSF render lifecycle phase.
 *
 */
public class FacesRender extends FacesSupport {

	/**
     * Executes the render phase, borrowed from MyFaces
     * 
     * @param facesContext
     *            The faces context
     * @throws FacesException
     *             If anything goes wrong
     */
    public void render(FacesContext facesContext) throws FacesException {
        // if the response is complete we should not be invoking the phase
        // listeners
        if (isResponseComplete(facesContext, "render", true)) {
            return;
        }
        if (log.isTraceEnabled())
            log.trace("entering renderResponse");

        informPhaseListenersBefore(facesContext, PhaseId.RENDER_RESPONSE);
        try {
            // also possible that one of the listeners completed the response
            if (isResponseComplete(facesContext, "render", true)) {
                return;
            }
            Application application = facesContext.getApplication();
            ViewHandler viewHandler = application.getViewHandler();
            try {
                viewHandler
                        .renderView(facesContext, facesContext.getViewRoot());
            } catch (IOException e) {
                throw new FacesException(e.getMessage(), e);
            }
        } finally {
            informPhaseListenersAfter(facesContext, PhaseId.RENDER_RESPONSE);
        }
        if (log.isTraceEnabled()) {
            // Note: DebugUtils Logger must also be in trace level
            // DebugUtils.traceView("View after rendering");
        }

        if (log.isTraceEnabled())
            log.trace("exiting renderResponse");
    }
}
"
core/src/main/java/org/apache/struts2/jsf/FacesResult.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.jsf;

import javax.faces.application.ViewHandler;
import javax.faces.component.UIViewRoot;
import javax.faces.context.FacesContext;

import org.apache.struts2.dispatcher.StrutsResultSupport;

import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.Result;

/**
 * Executes the JSF render phase
 */
public class FacesResult extends StrutsResultSupport implements Result {

    private static final long serialVersionUID = -3548970638740937804L;

    /**
     * Checks to see if we need to build a new JSF ViewId from the Struts Result
     * config and then renders the result by delegating to the
     * FacesRender.render().
     * 
     * @see org.apache.struts2.dispatcher.StrutsResultSupport#doExecute(java.lang.String,
     *      com.opensymphony.
     */
    protected void doExecute(String finalLocation, ActionInvocation invocation)
            throws Exception {
        performNavigation(finalLocation, FacesContext.getCurrentInstance());
        new FacesRender().render(FacesContext.getCurrentInstance());
    }

    /**
     * Compares the Struts Result uri to the faces viewId. If they are different
     * use the Struts uri to build a new faces viewId.
     * 
     * @param finalLocation
     *            The result uri
     * @param facesContext
     *            The FacesContext
     */
    private void performNavigation(String finalLocation,
            FacesContext facesContext) {
        String facesViewId = facesContext.getViewRoot().getViewId();
        if (finalLocation != null) {
            if (finalLocation.equals(facesViewId) == false) {
                ViewHandler viewHandler = facesContext.getApplication()
                        .getViewHandler();
                UIViewRoot viewRoot = viewHandler.createView(facesContext,
                        finalLocation);
                facesContext.setViewRoot(viewRoot);
                facesContext.renderResponse();
            }
        }
    }

}
"
core/src/main/java/org/apache/struts2/jsf/FacesSetupInterceptor.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.jsf;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;

import javax.faces.FactoryFinder;
import javax.faces.application.Application;
import javax.faces.application.ApplicationFactory;
import javax.faces.application.NavigationHandler;
import javax.faces.application.StateManager;
import javax.faces.application.ViewHandler;
import javax.faces.context.FacesContext;
import javax.faces.context.FacesContextFactory;
import javax.faces.el.PropertyResolver;
import javax.faces.el.VariableResolver;
import javax.faces.event.ActionListener;
import javax.faces.lifecycle.Lifecycle;
import javax.faces.lifecycle.LifecycleFactory;

import org.apache.struts2.ServletActionContext;
import org.apache.struts2.StrutsException;
import org.apache.struts2.util.ClassLoaderUtils;

import com.opensymphony.xwork2.Action;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.config.entities.ActionConfig;
import com.opensymphony.xwork2.config.entities.ResultConfig;
import com.opensymphony.xwork2.interceptor.Interceptor;

/**
 * * Initializes the JSF context for this request.
 * <p>
 * </P>
 * The JSF Application can additionaly be configured from the Struts.xml by
 * adding &lt;param&gt; tags to the jsfSetup &lt;interceptor-ref&gt;.
 * <p>
 * </p>
 * <b>Example struts.xml configuration:</b>
 * 
 * <pre>
 *   &lt;interceptor-ref name=&quot;jsfSetup&quot;&gt;
 *       &lt;param name=&quot;actionListener&quot;&gt;&lt;/param&gt;
 *       &lt;param name=&quot;defaultRenderKitId&quot;&gt;&lt;/param&gt;
 *       &lt;param name=&quot;supportedLocale&quot;&gt;&lt;/param&gt;
 *       &lt;param name=&quot;defaultLocale&quot;&gt;&lt;/param&gt;
 *       &lt;param name=&quot;messageBundle&quot;&gt;&lt;/param&gt;
 *       &lt;param name=&quot;navigationHandler&quot;&gt;org.apache.struts2.jsf.StrutsNavigationHandler&lt;/param&gt;
 *       &lt;param name=&quot;propertyResolver&quot;&gt;&lt;/param&gt;
 *       &lt;param name=&quot;stateManager&quot;&gt;&lt;/param&gt;
 *       &lt;param name=&quot;variableResolver&quot;&gt;
 *           org.apache.myfaces.el.VariableResolverImpl
 *          ,org.apache.struts2.jsf.StrutsVariableResolver
 *       &lt;/param&gt;
 *       &lt;param name=&quot;viewHandler;&quot;&gt;org.apache.shale.tiles.TilesViewHandler&lt;/param&gt;
 *   &lt;/interceptor-ref&gt;
 * </pre>
 * 
 * <p>
 * </p>
 * <b>Note: None of the parameters are required but all are shown in the example
 * for completeness.</b>
 */
public class FacesSetupInterceptor extends FacesSupport implements Interceptor {

    private static final long serialVersionUID = -621512342655103941L;

    private String lifecycleId = LifecycleFactory.DEFAULT_LIFECYCLE;

    private FacesContextFactory facesContextFactory;

    private Lifecycle lifecycle;

    // jsf Application configuration
    private List<String> actionListener;

    private String defaultRenderKitId;

    private List<String> supportedLocale;

    private String defaultLocale;

    private String messageBundle;

    private List<String> navigationHandler;

    private List<String> propertyResolver;

    private List<String> stateManager;

    private List<String> variableResolver;

    private List<String> viewHandler;

    /**
     * Sets the lifecycle id
     * 
     * @param id
     *            The id
     */
    public void setLifecycleId(String id) {
        this.lifecycleId = id;
    }

    /**
     * Initializes the lifecycle and factories
     */
    public void init() {
        try {
            facesContextFactory = (FacesContextFactory) FactoryFinder
                    .getFactory(FactoryFinder.FACES_CONTEXT_FACTORY);
        } catch (Exception ex) {
            log.debug("Unable to initialize faces", ex);
            return;
        }

        // Javadoc says: Lifecycle instance is shared across multiple
        // simultaneous requests, it must be implemented in a thread-safe
        // manner.
        // So we can acquire it here once:
        LifecycleFactory lifecycleFactory = (LifecycleFactory) FactoryFinder
                .getFactory(FactoryFinder.LIFECYCLE_FACTORY);
        lifecycle = lifecycleFactory.getLifecycle(lifecycleId);

        Application application = ((ApplicationFactory) FactoryFinder
                .getFactory(FactoryFinder.APPLICATION_FACTORY))
                .getApplication();

        if (actionListener != null) {
            Iterator i = actionListener.iterator();
            application
                    .setActionListener((ActionListener) getApplicationObject(
                            ActionListener.class, i, application
                                    .getActionListener()));
        }
        if (defaultRenderKitId != null && defaultRenderKitId.length() > 0) {
            application.setDefaultRenderKitId(defaultRenderKitId);
        }
        if (messageBundle != null && messageBundle.length() > 0) {
            application.setMessageBundle(messageBundle);
        }
        if (supportedLocale != null) {
            List<Locale> locales = new ArrayList<Locale>();
            for (Iterator i = supportedLocale.iterator(); i.hasNext();) {
                locales.add(toLocale((String) i.next()));
            }
            application.setSupportedLocales(locales);
        }
        if (defaultLocale != null && defaultLocale.length() > 0) {
            application.setDefaultLocale(toLocale(defaultLocale));
        }
        if (navigationHandler != null) {
            Iterator i = navigationHandler.iterator();
            application
                    .setNavigationHandler((NavigationHandler) getApplicationObject(
                            NavigationHandler.class, i, application
                                    .getNavigationHandler()));
        }
        if (propertyResolver != null) {
            Iterator i = propertyResolver.iterator();
            application
                    .setPropertyResolver((PropertyResolver) getApplicationObject(
                            PropertyResolver.class, i, application
                                    .getPropertyResolver()));
        }
        if (stateManager != null) {
            Iterator i = stateManager.iterator();
            application.setStateManager((StateManager) getApplicationObject(
                    StateManager.class, i, application.getStateManager()));
        }
        if (variableResolver != null) {
            Iterator i = variableResolver.iterator();
            application
                    .setVariableResolver((VariableResolver) getApplicationObject(
                            VariableResolver.class, i, application
                                    .getVariableResolver()));
        }
        if (viewHandler != null) {
            Iterator i = viewHandler.iterator();
            application.setViewHandler((ViewHandler) getApplicationObject(
                    ViewHandler.class, i, application.getViewHandler()));
        }
    }

    /**
     * Creates the faces context for other phases.
     * 
     * @param invocation
     *            The action invocation
     */
    public String intercept(ActionInvocation invocation) throws Exception {
        if (facesContextFactory != null) {
            if (isFacesAction(invocation)) {

                invocation.getInvocationContext().put(
                        FacesInterceptor.FACES_ENABLED, Boolean.TRUE);

                FacesContext facesContext = facesContextFactory
                        .getFacesContext(ServletActionContext
                                .getServletContext(), ServletActionContext
                                .getRequest(), ServletActionContext
                                .getResponse(), lifecycle);

                setLifecycle(lifecycle);

                try {
                    return invocation.invoke();
                } finally {
                    facesContext.release();
                }
            }
        } else {
            throw new StrutsException(
                    "Unable to initialize jsf interceptors probably due missing JSF implementation libraries",
                    invocation.getProxy().getConfig());
        }
        return invocation.invoke();
    }

    /**
     * Cleans up the lifecycle and factories
     */
    public void destroy() {
        facesContextFactory = null;
        lifecycle = null;
    }

    /**
     * Determines if this action mapping will be have a JSF view
     * 
     * @param inv
     *            The action invocation
     * @return True if the JSF interceptors should fire
     */
    protected boolean isFacesAction(ActionInvocation inv) {
        ActionConfig config = inv.getProxy().getConfig();
        if (config != null) {
            ResultConfig resultConfig = config.getResults().get(Action.SUCCESS);
            Class resClass = null;
            try {
                resClass = Class.forName(resultConfig.getClassName());
            } catch (ClassNotFoundException ex) {
                log.warn(
                        "Can't find result class, ignoring as a faces request",
                        ex);
            }
            if (resClass != null) {
                if (resClass.isAssignableFrom(FacesResult.class)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Constructs an object from a list of class names. This method supports
     * creating the objects using constructor delegation, if the requested class
     * supports it. Classes will be imbedded from top to bottom in the list with
     * the last class listed being the one that will be returned.
     * 
     * @param interfaceClass
     *            The Class type that is expected to be returned
     * @param classNamesIterator
     *            An Iterator for a list of Strings that represent the class
     *            names
     * @param defaultObject
     *            The current Object that the jsf Application has set
     * @return
     */
    private Object getApplicationObject(Class interfaceClass,
            Iterator classNamesIterator, Object defaultObject) {
        Object current = defaultObject;

        while (classNamesIterator.hasNext()) {
            String implClassName = (String) classNamesIterator.next();
            Class implClass = null;

            try {
                implClass = ClassLoaderUtils.loadClass(implClassName, this
                        .getClass());
            } catch (ClassNotFoundException e1) {
                throw new IllegalArgumentException("Class " + implClassName
                        + " was not found.");
            }

            // check, if class is of expected interface type
            if (!interfaceClass.isAssignableFrom(implClass)) {
                throw new IllegalArgumentException("Class " + implClassName
                        + " is no " + interfaceClass.getName());
            }

            if (current == null) {
                // nothing to decorate
                try {
                    current = implClass.newInstance();
                } catch (InstantiationException e) {
                    log.error(e.getMessage(), e);
                    throw new StrutsException(e);
                } catch (IllegalAccessException e) {
                    log.error(e.getMessage(), e);
                    throw new StrutsException(e);
                }
            } else {
                // let's check if class supports the decorator pattern
                try {
                    Constructor delegationConstructor = implClass
                            .getConstructor(new Class[] { interfaceClass });
                    // impl class supports decorator pattern,
                    try {
                        // create new decorator wrapping current
                        current = delegationConstructor
                                .newInstance(new Object[] { current });
                    } catch (InstantiationException e) {
                        log.error(e.getMessage(), e);
                        throw new StrutsException(e);
                    } catch (IllegalAccessException e) {
                        log.error(e.getMessage(), e);
                        throw new StrutsException(e);
                    } catch (InvocationTargetException e) {
                        log.error(e.getMessage(), e);
                        throw new StrutsException(e);
                    }
                } catch (NoSuchMethodException e) {
                    // no decorator pattern support
                    try {
                        current = implClass.newInstance();
                    } catch (InstantiationException e1) {
                        log.error(e.getMessage(), e);
                        throw new StrutsException(e);
                    } catch (IllegalAccessException e1) {
                        log.error(e.getMessage(), e);
                        throw new StrutsException(e);
                    }
                }
            }
        }

        return current;
    }

    /**
     * Takes a comma delimited string of class names and stores the names in an
     * <code>ArrayList</code>. The incoming <code>String</code> will be
     * cleaned of any whitespace characters before the class names are stored.
     * 
     * @param actionListener
     *            A comma delimited string of class names
     */
    public void setActionListener(String actionListener) {
        if (this.actionListener == null) {
            this.actionListener = new ArrayList<String>();
        }
        String clean = actionListener.replaceAll("[ \t\r\n]", "");
        String[] actionListenerNames = clean.split(",");

        for (int i = 0; i < actionListenerNames.length; i++) {
            this.actionListener.add(actionListenerNames[i]);
        }
    }

    /**
     * A <code>String</code> to be used as the defaultRenderKitId for the jsf
     * application. The incoming <code>String</code> will be cleaned of
     * whitespace characters.
     * 
     * @param defaultRenderKitId
     *            The defaultRenderKitId
     */
    public void setDefaultRenderKitId(String defaultRenderKitId) {
        String clean = defaultRenderKitId.replaceAll("[ \t\r\n]", "");
        this.defaultRenderKitId = clean;
    }

    /**
     * Takes a comma delimited string of local names and stores the names in an
     * <code>ArrayList</code>. The incoming <code>String</code> will be
     * cleaned of any whitespace characters before the class names are stored.
     * 
     * @param supportedLocale
     *            A comma delimited string of local names
     */
    public void setSupportedLocale(String supportedLocale) {
        if (this.supportedLocale == null) {
            this.supportedLocale = new ArrayList<String>();
        }
        String clean = supportedLocale.replaceAll("[ \t\r\n]", "");
        String[] supportedLocaleNames = clean.split(",");

        for (int i = 0; i < supportedLocaleNames.length; i++) {
            this.supportedLocale.add(supportedLocaleNames[i]);
        }
    }

    /**
     * Stores a String representation of the defaultLocale. The incoming
     * <code>String</code> will be cleaned of any whitespace characters before
     * the class names are stored.
     * 
     * @param defaultLocale
     *            The default local
     */
    public void setDefaultLocale(String defaultLocale) {
        String clean = defaultLocale.replaceAll("[ \t\r\n]", "");
        this.defaultLocale = clean;
    }

    /**
     * Stores the messageBundle to be used to configure the jsf Application.
     * 
     * @param messageBundle
     *            The messageBundle
     */
    public void setMessageBundle(String messageBundle) {
        String clean = messageBundle.replaceAll("[ \t\r\n]", "");
        this.messageBundle = clean;
    }

    /**
     * Takes a comma delimited string of class names and stores the names in an
     * <code>ArrayList</code>. The incoming <code>String</code> will be
     * cleaned of any whitespace characters before the class names are stored.
     * 
     * @param navigationHandlerName
     *            A comma delimited string of class names
     */
    public void setNavigationHandler(String navigationHandlerName) {
        if (navigationHandler == null) {
            navigationHandler = new ArrayList<String>();
        }
        String clean = navigationHandlerName.replaceAll("[ \t\r\n]", "");
        String[] navigationHandlerNames = clean.split(",");

        for (int i = 0; i < navigationHandlerNames.length; i++) {
            navigationHandler.add(navigationHandlerNames[i]);
        }
    }

    /**
     * Takes a comma delimited string of class names and stores the names in an
     * <code>ArrayList</code>. The incoming <code>String</code> will be
     * cleaned of any whitespace characters before the class names are stored.
     * 
     * @param propertyResolverName
     *            A comma delimited string of class names
     */
    public void setPropertyResolver(String propertyResolverName) {
        if (propertyResolver == null) {
            propertyResolver = new ArrayList<String>();
        }
        String clean = propertyResolverName.replaceAll("[ \t\r\n]", "");
        String[] propertyResolverNames = clean.split(",");

        for (int i = 0; i < propertyResolverNames.length; i++) {
            propertyResolver.add(propertyResolverNames[i]);
        }
    }

    /**
     * Takes a comma delimited string of class names and stores the names in an
     * <code>ArrayList</code>. The incoming <code>String</code> will be
     * cleaned of any whitespace characters before the class names are stored.
     * 
     * @param stateManagerName
     *            A comma delimited string of class names
     */
    public void setStateManager(String stateManagerName) {
        if (stateManager == null) {
            stateManager = new ArrayList<String>();
        }
        String clean = stateManagerName.replaceAll("[ \t\r\n]", "");
        String[] stateManagerNames = clean.split(",");

        for (int i = 0; i < stateManagerNames.length; i++) {
            stateManager.add(stateManagerNames[i]);
        }
    }

    /**
     * Takes a comma delimited string of class names and stores the names in an
     * <code>ArrayList</code>. The incoming <code>String</code> will be
     * cleaned of any whitespace characters before the class names are stored.
     * 
     * @param variableResolverName
     *            A comma delimited string of class names
     */
    public void setVariableResolver(String variableResolverName) {
        if (variableResolver == null) {
            variableResolver = new ArrayList<String>();
        }
        String clean = variableResolverName.replaceAll("[ \t\r\n]", "");
        String[] variableResolverNames = clean.split(",");

        for (int i = 0; i < variableResolverNames.length; i++) {
            variableResolver.add(variableResolverNames[i]);
        }
    }

    /**
     * Takes a comma delimited string of class names and stores the names in an
     * <code>ArrayList</code>. The incoming <code>String</code> will be
     * cleaned of any whitespace characters before the class names are stored.
     * 
     * @param viewHandlerName
     *            A comma delimited string of class names
     */
    public void setViewHandler(String viewHandlerName) {
        if (viewHandler == null) {
            viewHandler = new ArrayList<String>();
        }
        String[] viewHandlerNames = viewHandlerName
                .split(",^[ \t\r\n]+|[ \t\r\n]+$");

        for (int i = 0; i < viewHandlerNames.length; i++) {
            viewHandler.add(viewHandlerNames[i]);
        }
    }

    /**
     * Converts a locale string to <code>Locale</code> class. Accepts both '_'
     * and '-' as separators for locale components.
     * 
     * @param localeString
     *            string representation of a locale
     * @return Locale instance, compatible with the string representation
     */
    private Locale toLocale(String localeString) {
        if ((localeString == null) || (localeString.length() == 0)) {
            Locale locale = Locale.getDefault();
            if (log.isWarnEnabled())
                log
                        .warn("Locale name in faces-config.xml null or empty, setting locale to default locale : "
                                + locale.toString());
            return locale;
        }

        int separatorCountry = localeString.indexOf('_');
        char separator;
        if (separatorCountry >= 0) {
            separator = '_';
        } else {
            separatorCountry = localeString.indexOf('-');
            separator = '-';
        }

        String language, country, variant;
        if (separatorCountry < 0) {
            language = localeString;
            country = variant = "";
        } else {
            language = localeString.substring(0, separatorCountry);

            int separatorVariant = localeString.indexOf(separator,
                    separatorCountry + 1);
            if (separatorVariant < 0) {
                country = localeString.substring(separatorCountry + 1);
                variant = "";
            } else {
                country = localeString.substring(separatorCountry + 1,
                        separatorVariant);
                variant = localeString.substring(separatorVariant + 1);
            }
        }

        return new Locale(language, country, variant);
    }
}
"
core/src/main/java/org/apache/struts2/jsf/FacesSupport.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.jsf;

import javax.faces.context.FacesContext;
import javax.faces.event.PhaseEvent;
import javax.faces.event.PhaseId;
import javax.faces.event.PhaseListener;
import javax.faces.lifecycle.Lifecycle;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.opensymphony.xwork2.ActionContext;

/**
 * Provides common lifecycle phase methods needed by interceptors and results.
 */
public class FacesSupport {

	private static final String LIFECYCLE_KEY = "lifecycle";

	/** Log instance for each class */
	protected Log log;

    /**
     * Marker key for the ActionContext to dictate whether to treat the request
     * as a JSF faces request and therefore process the Faces phases
     */
    protected static final String FACES_ENABLED = "facesEnabled";

    /** Initializes log instance for the instance object */
    protected FacesSupport() {
        log = LogFactory.getLog(getClass());
    }

	/**
	 * Gets the shared lifecycle for this request
	 *
	 * @return The lifecycle
	 */
	private Lifecycle getLifecycle() {
		return (Lifecycle) ActionContext.getContext().get(LIFECYCLE_KEY);
	}

	/**
	 * Sets the lifecycle for this request
	 *
	 * @param lifecycle
	 *            The lifecycle
	 */
	protected void setLifecycle(Lifecycle lifecycle) {
		ActionContext.getContext().put(LIFECYCLE_KEY, lifecycle);
	}

	/**
	 * Informs phase listeners before a phase is executed
	 *
	 * @param facesContext
	 *            The current faces context
	 * @param phaseId
	 *            The phase id about to be executed
	 */
	protected void informPhaseListenersBefore(FacesContext facesContext,
			PhaseId phaseId) {
		Lifecycle lifecycle = getLifecycle();
		PhaseListener[] phaseListeners = lifecycle.getPhaseListeners();
		for (int i = 0; i < phaseListeners.length; i++) {
			PhaseListener phaseListener = phaseListeners[i];
			int listenerPhaseId = phaseListener.getPhaseId().getOrdinal();
			if (listenerPhaseId == PhaseId.ANY_PHASE.getOrdinal()
					|| listenerPhaseId == phaseId.getOrdinal()) {
				phaseListener.beforePhase(new PhaseEvent(FacesContext
						.getCurrentInstance(), phaseId, lifecycle));
			}
		}

	}

	/**
	 * Informs phase listeners after a phase is executed
	 *
	 * @param facesContext
	 *            The current faces context
	 * @param phaseId
	 *            The phase id that was executed
	 */
	protected void informPhaseListenersAfter(FacesContext facesContext,
			PhaseId phaseId) {
		Lifecycle lifecycle = getLifecycle();
		PhaseListener[] phaseListeners = lifecycle.getPhaseListeners();
		for (int i = 0; i < phaseListeners.length; i++) {
			PhaseListener phaseListener = phaseListeners[i];
			int listenerPhaseId = phaseListener.getPhaseId().getOrdinal();
			if (listenerPhaseId == PhaseId.ANY_PHASE.getOrdinal()
					|| listenerPhaseId == phaseId.getOrdinal()) {
				phaseListener.afterPhase(new PhaseEvent(FacesContext
						.getCurrentInstance(), phaseId, lifecycle));
			}
		}

	}

	/**
	 * Checks to see if the response has been completed. Mainly used for better
	 * debugging messages.
	 *
	 * @param facesContext
	 *            The current faces context
	 * @param phase
	 *            The phase id in execution
	 * @param before
	 *            Whether the phase has been executed or not
	 * @return True if the response is complete
	 */
	protected boolean isResponseComplete(FacesContext facesContext,
			String phase, boolean before) {
		boolean flag = false;
		if (facesContext.getResponseComplete()) {
			if (log.isDebugEnabled())
				log
						.debug("exiting from lifecycle.execute in "
								+ phase
								+ " because getResponseComplete is true from one of the "
								+ (before ? "before" : "after") + " listeners");
			flag = true;
		}
		return flag;
	}

	/**
	 * Checks to see the render phase should be executed next. Mainly used for
	 * better debugging messages.
	 *
	 * @param facesContext
	 *            The current faces context
	 * @param phase
	 *            The phase id in execution
	 * @param before
	 *            Whether the phase has been executed or not
	 * @return True if the response is complete
	 */
	protected boolean shouldRenderResponse(FacesContext facesContext,
			String phase, boolean before) {
		boolean flag = false;
		if (facesContext.getRenderResponse()) {
			if (log.isDebugEnabled())
				log.debug("exiting from lifecycle.execute in " + phase
						+ " because getRenderResponse is true from one of the "
						+ (before ? "before" : "after") + " listeners");
			flag = true;
		}
		return flag;
	}
}
"
core/src/main/java/org/apache/struts2/jsf/InvokeApplicationInterceptor.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.jsf;

import javax.faces.FacesException;
import javax.faces.context.FacesContext;
import javax.faces.event.PhaseId;

/**
 * Invokes the application
 */
public class InvokeApplicationInterceptor extends FacesInterceptor {

    private static final long serialVersionUID = -7388153356410171208L;

    /**
     * Invoke Application (JSF.2.2.5)
     * 
     * @param viewId
     *            The view id
     * @param facesContext
     *            The faces context
     * @return true, if response is complete
     */
    protected boolean executePhase(String viewId, FacesContext facesContext)
            throws FacesException {
        boolean skipFurtherProcessing = false;
        if (log.isTraceEnabled())
            log.trace("entering invokeApplication");

        informPhaseListenersBefore(facesContext, PhaseId.INVOKE_APPLICATION);

        try {
            if (isResponseComplete(facesContext, "invokeApplication", true)) {
                // have to return right away
                return true;
            }
            if (shouldRenderResponse(facesContext, "invokeApplication", true)) {
                skipFurtherProcessing = true;
            }

            facesContext.getViewRoot().processApplication(facesContext);
        } finally {
            informPhaseListenersAfter(facesContext, PhaseId.INVOKE_APPLICATION);
        }

        if (isResponseComplete(facesContext, "invokeApplication", false)
                || shouldRenderResponse(facesContext, "invokeApplication",
                        false)) {
            // since this phase is completed we don't need to return right away
            // even if the response is completed
            skipFurtherProcessing = true;
        }

        if (!skipFurtherProcessing && log.isTraceEnabled())
            log.trace("exiting invokeApplication ");

        return skipFurtherProcessing;
    }
}
"
core/src/main/java/org/apache/struts2/jsf/ProcessValidationsInterceptor.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.jsf;

import javax.faces.FacesException;
import javax.faces.context.FacesContext;
import javax.faces.event.PhaseId;

/**
 * Processes validations on the component tree
 */
public class ProcessValidationsInterceptor extends FacesInterceptor {

	private static final long serialVersionUID = 8785236570688278147L;

	/**
	 * Process Validations (JSF.2.2.3)
	 * 
	 * @param viewId
	 *            The view id
	 * @param facesContext
	 *            The faces context
	 * @return true, if response is complete
	 */
	protected boolean executePhase(String viewId, FacesContext facesContext)
			throws FacesException {
		boolean skipFurtherProcessing = false;
		if (log.isTraceEnabled())
			log.trace("entering processValidations");

		informPhaseListenersBefore(facesContext, PhaseId.PROCESS_VALIDATIONS);

        try {
        		if (isResponseComplete(facesContext, "processValidations", true)) {
        			// have to return right away
        			return true;
        		}
        		if (shouldRenderResponse(facesContext, "processValidations", true)) {
        			skipFurtherProcessing = true;
        		}
        
        		facesContext.getViewRoot().processValidators(facesContext);
        } finally {
            informPhaseListenersAfter(facesContext, PhaseId.PROCESS_VALIDATIONS);
        }

		if (isResponseComplete(facesContext, "processValidations", false)
				|| shouldRenderResponse(facesContext, "processValidations",
						false)) {
			// since this phase is completed we don't need to return right away
			// even if the response is completed
			skipFurtherProcessing = true;
		}

		if (!skipFurtherProcessing && log.isTraceEnabled())
			log.trace("exiting processValidations");
		return skipFurtherProcessing;
	}
}
"
core/src/main/java/org/apache/struts2/jsf/RestoreViewInterceptor.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.jsf;

import java.io.IOException;
import java.lang.reflect.Method;
import java.util.Iterator;

import javax.faces.FacesException;
import javax.faces.application.Application;
import javax.faces.application.ViewHandler;
import javax.faces.component.UIComponent;
import javax.faces.component.UIInput;
import javax.faces.component.UIViewRoot;
import javax.faces.context.ExternalContext;
import javax.faces.context.FacesContext;
import javax.faces.el.ValueBinding;
import javax.faces.event.PhaseId;

/**
 * Restores the view or component tree
 */
public class RestoreViewInterceptor extends FacesInterceptor {

    private static final long serialVersionUID = -1500785113037140668L;

    /**
     * Restore View (JSF.2.2.1)
     * 
     * @param viewId
     *            The view id
     * @param facesContext
     *            The faces context
     * @return true, if immediate rendering should occur
     */
    protected boolean executePhase(String viewId, FacesContext facesContext) {
        boolean skipFurtherProcessing = false;
        if (log.isTraceEnabled())
            log.trace("entering restoreView");

        informPhaseListenersBefore(facesContext, PhaseId.RESTORE_VIEW);

        try {
            if (isResponseComplete(facesContext, "restoreView", true)) {
                // have to skips this phase
                return true;
            }
            if (shouldRenderResponse(facesContext, "restoreView", true)) {
                skipFurtherProcessing = true;
            }

            ExternalContext externalContext = facesContext.getExternalContext();
            String defaultSuffix = externalContext
                    .getInitParameter(ViewHandler.DEFAULT_SUFFIX_PARAM_NAME);
            String suffix = defaultSuffix != null ? defaultSuffix
                    : ViewHandler.DEFAULT_SUFFIX;
            if (viewId != null) {
                viewId += suffix;
            }

            if (viewId == null) {
                if (!externalContext.getRequestServletPath().endsWith("/")) {
                    try {
                        externalContext.redirect(externalContext
                                .getRequestServletPath()
                                + "/");
                        facesContext.responseComplete();
                        return true;
                    } catch (IOException e) {
                        throw new FacesException("redirect failed", e);
                    }
                }
            }

            Application application = facesContext.getApplication();
            ViewHandler viewHandler = application.getViewHandler();

            // boolean viewCreated = false;
            UIViewRoot viewRoot = viewHandler.restoreView(facesContext, viewId);
            if (viewRoot == null) {
                viewRoot = viewHandler.createView(facesContext, viewId);
                viewRoot.setViewId(viewId);
                facesContext.renderResponse();
                // viewCreated = true;
            }

            facesContext.setViewRoot(viewRoot);

            /*
             * This section has been disabled because it causes some bug. Be
             * careful if you need to re-enable it. Furthermore, for an unknown
             * reason, it seems that by default it is executed (i.e.
             * log.isTraceEnabled() is true). Bug example : This traceView
             * causes DebugUtil.printComponent to print all the attributes of
             * the view components. And if you have a data table within an
             * aliasBean, this causes the data table to initialize it's value
             * attribute while the alias isn't set. So, the value initializes
             * with an UIData.EMPTY_DATA_MODEL, and not with the aliased one.
             * But as it's initialized, it will not try to get the value from
             * the ValueBinding next time it needs to. I expect this to cause
             * more similar bugs. TODO : Completely remove or be SURE by default
             * it's not executed, and it has no more side-effects.
             * 
             * if (log.isTraceEnabled()) { //Note: DebugUtils Logger must also
             * be in trace level DebugUtils.traceView(viewCreated ? "Newly
             * created view" : "Restored view"); }
             */

            if (facesContext.getExternalContext().getRequestParameterMap()
                    .isEmpty()) {
                // no POST or query parameters --> set render response flag
                facesContext.renderResponse();
            }

            recursivelyHandleComponentReferencesAndSetValid(facesContext,
                    viewRoot);
        } finally {
            informPhaseListenersAfter(facesContext, PhaseId.RESTORE_VIEW);
        }

        if (isResponseComplete(facesContext, "restoreView", false)
                || shouldRenderResponse(facesContext, "restoreView", false)) {
            // since this phase is completed we don't need to return right away
            // even if the response is completed
            skipFurtherProcessing = true;
        }

        if (!skipFurtherProcessing && log.isTraceEnabled())
            log.trace("exiting restoreView ");
        return skipFurtherProcessing;
    }

    /**
     * Walk the component tree, executing any component-bindings to reattach
     * components to their backing beans. Also, any UIInput component is marked
     * as Valid.
     * <p>
     * Note that this method effectively breaks encapsulation; instead of asking
     * each component to update itself and its children, this method just
     * reaches into each component. That makes it impossible for any component
     * to customise its behaviour at this point.
     * <p>
     * This has been filed as an issue against the spec. Until this issue is
     * resolved, we'll add a new marker-interface for components to allow them
     * to define their interest in handling children bindings themselves.
     */
    protected void recursivelyHandleComponentReferencesAndSetValid(
            FacesContext facesContext, UIComponent parent) {
        recursivelyHandleComponentReferencesAndSetValid(facesContext, parent,
                false);
    }

    protected void recursivelyHandleComponentReferencesAndSetValid(
            FacesContext facesContext, UIComponent parent, boolean forceHandle) {
        Method handleBindingsMethod = getBindingMethod(parent);

        if (handleBindingsMethod != null && !forceHandle) {
            try {
                handleBindingsMethod.invoke(parent, new Object[] {});
            } catch (Throwable th) {
                log.error(
                        "Exception while invoking handleBindings on component with client-id:"
                                + parent.getClientId(facesContext), th);
            }
        } else {
            for (Iterator it = parent.getFacetsAndChildren(); it.hasNext();) {
                UIComponent component = (UIComponent) it.next();

                ValueBinding binding = component.getValueBinding("binding"); // TODO:
                // constant
                if (binding != null && !binding.isReadOnly(facesContext)) {
                    binding.setValue(facesContext, component);
                }

                if (component instanceof UIInput) {
                    ((UIInput) component).setValid(true);
                }

                recursivelyHandleComponentReferencesAndSetValid(facesContext,
                        component);
            }
        }
    }

    /**
     * This is all a hack to work around a spec-bug which will be fixed in
     * JSF2.0
     * 
     * @param parent
     * @return true if this component is bindingAware (e.g. aliasBean)
     */
    private static Method getBindingMethod(UIComponent parent) {
        Class[] clazzes = parent.getClass().getInterfaces();

        for (int i = 0; i < clazzes.length; i++) {
            Class clazz = clazzes[i];

            if (clazz.getName().indexOf("BindingAware") != -1) {
                try {
                    return parent.getClass().getMethod("handleBindings",
                            new Class[] {});
                } catch (NoSuchMethodException e) {
                    // return
                }
            }
        }

        return null;
    }
}
"
core/src/main/java/org/apache/struts2/jsf/StrutsNavigationHandler.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.jsf;

import java.util.Map;

import javax.faces.application.NavigationHandler;
import javax.faces.context.FacesContext;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.config.entities.ActionConfig;
import com.opensymphony.xwork2.config.entities.ResultConfig;

/**
 * Overrides the JFS navigation by delegating the result to handling by the core
 * result code lookup and execution.  If a result cannot be found, the previous
 * NavigationHandler is called.
 */
public class StrutsNavigationHandler extends NavigationHandler {
    
    private NavigationHandler parent;
    
    /**
     * Creates the handler
     * 
     * @param handler The old NavigationHandler to possibly delegate to
     */
    public StrutsNavigationHandler(NavigationHandler handler) {
        this.parent = handler;
    }

	/**
	 * Stores any outcomes as the result code, failing over to the old
     * NavigationHandler
	 * 
	 * @param facesContext The faces context
	 * @param fromAction The action we are coming from
	 * @param outcome The String return code
	 */
	@Override
	public void handleNavigation(FacesContext facesContext, String fromAction, String outcome) {
		ActionContext ctx = ActionContext.getContext();
		if (outcome != null) {
            ActionConfig config = ctx.getActionInvocation().getProxy().getConfig();
            Map results = config.getResults();

            ResultConfig resultConfig = null;

            synchronized (config) {
                try {
                    resultConfig = (ResultConfig) results.get(outcome);
                } catch (NullPointerException e) {
                }
                if (resultConfig == null) {
                    // If no result is found for the given resultCode, try to get a wildcard '*' match.
                    resultConfig = (ResultConfig) results.get("*");
                }
            }
            if (resultConfig != null) {
                ctx.getActionInvocation().setResultCode(outcome);
            } else {
                // Failing over to parent handler
                parent.handleNavigation(facesContext, fromAction, outcome);
            }
		}
	}

}
"
core/src/main/java/org/apache/struts2/jsf/StrutsVariableResolver.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.jsf;

import javax.faces.context.FacesContext;
import javax.faces.el.EvaluationException;
import javax.faces.el.VariableResolver;

import com.opensymphony.xwork2.util.OgnlValueStack;
import com.opensymphony.xwork2.ActionContext;

/**
 * Will return a reference to the current action if the action name matches the
 * requested variable name. Otherwise it will attempt to resolve the name from
 * the value stack. Otherwise it will delegate to the original jsf resolver.
 */
public class StrutsVariableResolver extends VariableResolver {

    /** The original <code>VariableResolver</code> passed to our constructor. */
    private VariableResolver original = null;

    /** The variable name of our Struts action */
    private static final String STRUTS_VARIABLE_NAME = "action";

    /**
     * Constructor
     * 
     * @param original
     *            Original resolver to delegate to.
     */
    public StrutsVariableResolver(VariableResolver original) {

        this.original = original;

    }

    /**
     * <p>
     * Will return a reference to the current action if the action name matches
     * the requested variable name. Otherwise it will attempt to resolve the
     * name from the value stack. Otherwise it will delegate to the original jsf
     * resolver.
     * </p>
     * 
     * @param name
     *            Variable name to be resolved
     */
    public Object resolveVariable(FacesContext context, String name)
            throws EvaluationException {

        if (STRUTS_VARIABLE_NAME.equals(name)) {
            return ActionContext.getContext().getActionInvocation().getAction();
        }
        
        Object obj = ActionContext.getContext().getValueStack().findValue(name);
        if (obj != null) {
            return obj;
        } else {
            return original.resolveVariable(context, name);
        }

    }

}
"
core/src/main/java/org/apache/struts2/jsf/UpdateModelValuesInterceptor.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.jsf;

import javax.faces.FacesException;
import javax.faces.context.FacesContext;
import javax.faces.event.PhaseId;

/**
 * Updates the model values from the component tree
 */
public class UpdateModelValuesInterceptor extends FacesInterceptor {

    private static final long serialVersionUID = 4011504235094251077L;

    /**
     * Update Model Values (JSF.2.2.4)
     * 
     * @param viewId
     *            The view id
     * @param facesContext
     *            The faces context
     * @return true, if response is complete
     */
    protected boolean executePhase(String viewId, FacesContext facesContext)
            throws FacesException {
        boolean skipFurtherProcessing = false;
        if (log.isTraceEnabled())
            log.trace("entering updateModelValues");

        informPhaseListenersBefore(facesContext, PhaseId.UPDATE_MODEL_VALUES);

        try {
            if (isResponseComplete(facesContext, "updateModelValues", true)) {
                // have to return right away
                return true;
            }
            if (shouldRenderResponse(facesContext, "updateModelValues", true)) {
                skipFurtherProcessing = true;
            }

            facesContext.getViewRoot().processUpdates(facesContext);
        } finally {
            informPhaseListenersAfter(facesContext, PhaseId.UPDATE_MODEL_VALUES);
        }

        if (isResponseComplete(facesContext, "updateModelValues", false)
                || shouldRenderResponse(facesContext, "updateModelValues",
                        false)) {
            // since this phase is completed we don't need to return right away
            // even if the response is completed
            skipFurtherProcessing = true;
        }

        if (!skipFurtherProcessing && log.isTraceEnabled())
            log.trace("exiting updateModelValues");

        return skipFurtherProcessing;
    }
}
"
core/src/main/java/org/apache/struts2/plexus/PlexusFilter.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.plexus;

import java.io.IOException;
import java.util.Collections;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.codehaus.plexus.PlexusContainer;

/**
 * Creates a plexus container for the application, session, and request
 */
public class PlexusFilter implements Filter {
    private static final Log log = LogFactory.getLog(PlexusObjectFactory.class);
    private static final String CHILD_CONTAINER_NAME = "request";

    private static boolean loaded = false;

    private ServletContext ctx;

    /**
     * @return Returns if the container is loaded.
     */
    public static boolean isLoaded() {
        return loaded;
    }

    /* (non-Javadoc)
     * @see javax.servlet.Filter#init(javax.servlet.FilterConfig)
     */
    public void init(FilterConfig filterConfig) throws ServletException {
        ctx = filterConfig.getServletContext();
        loaded = true;
    }

    /* (non-Javadoc)
     * @see javax.servlet.Filter#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain)
     */
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
        PlexusContainer child = null;
        try {
            try {
                HttpServletRequest request = (HttpServletRequest) req;
                HttpSession session = request.getSession(false);
                PlexusContainer parent;
                if (session != null) {
                    parent = (PlexusContainer) session.getAttribute(PlexusLifecycleListener.KEY);
                } else {
                    parent = (PlexusContainer) ctx.getAttribute(PlexusLifecycleListener.KEY);
                }

                if (parent.hasChildContainer(CHILD_CONTAINER_NAME)) {
                    log.warn("Plexus container (scope: request) alredy exist.");
                    child = parent.getChildContainer(CHILD_CONTAINER_NAME);
                } else {
                    child = parent.createChildContainer(CHILD_CONTAINER_NAME, Collections.EMPTY_LIST, Collections.EMPTY_MAP);
                    PlexusUtils.configure(child, "plexus-request.xml");
                    child.initialize();
                    child.start();
                }
                PlexusThreadLocal.setPlexusContainer(child);
            } catch (Exception e) {
                log.error("Error initializing plexus container (scope: request)", e);
            }

            chain.doFilter(req, res);
        }
        finally {
            try {
                if (child != null) {
                    child.dispose();
                }
                PlexusThreadLocal.setPlexusContainer(null);
            } catch (Exception e) {
                log.error("Error disposing plexus container (scope: request)", e);
            }
        }
    }

    /* (non-Javadoc)
     * @see javax.servlet.Filter#destroy()
     */
    public void destroy() {
    }
}
"
core/src/main/java/org/apache/struts2/plexus/PlexusLifecycleListener.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.plexus;

import java.util.Collections;

import javax.servlet.ServletContext;
import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.http.HttpSession;
import javax.servlet.http.HttpSessionEvent;
import javax.servlet.http.HttpSessionListener;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.codehaus.plexus.DefaultPlexusContainer;
import org.codehaus.plexus.PlexusContainer;

/**
 * Manages the Plexus lifecycle for the servlet and session contexts
 */
public class PlexusLifecycleListener implements ServletContextListener, HttpSessionListener {
    private static final Log log = LogFactory.getLog(PlexusObjectFactory.class);

    private static boolean loaded = false;
    public static final String KEY = "struts.plexus.container";

    /**
     * @return Returns if the container is loaded.
     */
    public static boolean isLoaded() {
        return loaded;
    }

    /* (non-Javadoc)
     * @see javax.servlet.ServletContextListener#contextInitialized(javax.servlet.ServletContextEvent)
     */
    public void contextInitialized(ServletContextEvent servletContextEvent) {
        loaded = true;

        try {
            PlexusContainer pc = new DefaultPlexusContainer();
            PlexusUtils.configure(pc, "plexus-application.xml");
            ServletContext ctx = servletContextEvent.getServletContext();
            ctx.setAttribute(KEY, pc);

            pc.initialize();
            pc.start();
        } catch (Exception e) {
            log.error("Error initializing plexus container (scope: application)", e);
        }
    }

    /* (non-Javadoc)
     * @see javax.servlet.ServletContextListener#contextDestroyed(javax.servlet.ServletContextEvent)
     */
    public void contextDestroyed(ServletContextEvent servletContextEvent) {
        try {
            ServletContext ctx = servletContextEvent.getServletContext();
            PlexusContainer pc = (PlexusContainer) ctx.getAttribute(KEY);
            pc.dispose();
        } catch (Exception e) {
            log.error("Error disposing plexus container (scope: application)", e);
        }
    }

    /* (non-Javadoc)
     * @see javax.servlet.http.HttpSessionListener#sessionCreated(javax.servlet.http.HttpSessionEvent)
     */
    public void sessionCreated(HttpSessionEvent httpSessionEvent) {
        try {
            HttpSession session = httpSessionEvent.getSession();
            ServletContext ctx = session.getServletContext();
            PlexusContainer parent = (PlexusContainer) ctx.getAttribute(KEY);
            PlexusContainer child = parent.createChildContainer("session", Collections.EMPTY_LIST, Collections.EMPTY_MAP);
            session.setAttribute(KEY, child);
            PlexusUtils.configure(child, "plexus-session.xml");
            child.initialize();
            child.start();
        } catch (Exception e) {
            log.error("Error initializing plexus container (scope: session)", e);
        }
    }

    /* (non-Javadoc)
     * @see javax.servlet.http.HttpSessionListener#sessionDestroyed(javax.servlet.http.HttpSessionEvent)
     */
    public void sessionDestroyed(HttpSessionEvent httpSessionEvent) {
        try {
            HttpSession session = httpSessionEvent.getSession();
            PlexusContainer child = (PlexusContainer) session.getAttribute(KEY);
            child.dispose();
        } catch (Exception e) {
            log.error("Error initializing plexus container (scope: session)", e);
        }
    }
}
"
core/src/main/java/org/apache/struts2/plexus/PlexusObjectFactory.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.plexus;

import java.util.HashMap;
import java.util.Map;

import javax.servlet.ServletContext;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.util.ObjectFactoryInitializable;
import org.codehaus.plexus.PlexusContainer;

import com.opensymphony.xwork2.Action;
import com.opensymphony.xwork2.ObjectFactory;
import com.opensymphony.xwork2.Result;
import com.opensymphony.xwork2.config.ConfigurationException;
import com.opensymphony.xwork2.config.entities.ActionConfig;
import com.opensymphony.xwork2.config.entities.InterceptorConfig;
import com.opensymphony.xwork2.config.entities.ResultConfig;
import com.opensymphony.xwork2.interceptor.Interceptor;
import com.opensymphony.xwork2.util.OgnlUtil;
import com.opensymphony.xwork2.validator.Validator;

/**
 * Plexus integartion. You need three optional files: plexus-request.xml, plexus-session.xml, and
 * plexus-application.xml.
 * <p/>
 * The syntax of these files is:
 * <p/>
 * <pre>
 * &lt;plexus&gt;
 * &lt;components&gt;
 *  &lt;component&gt;
 *      &lt;role&gt;com.acme.MyBean&lt;/role&gt;
 *      &lt;implementation&gt;com.acme.MyBean|com.acme.MyBeanImpl&lt;/implementation&gt;
 *      &lt;componentComposer&gt;field|setter|?&lt;/componentComposer&gt;
 *      &lt;requirements&gt;
 *          &lt;requirement&gt;
 *              &lt;role&gt;com.acme.MyOtherBean&lt;/role&gt;
 *          &lt;/requirement&gt;
 *      &lt;/requirements&gt;
 *      &lt;configuration&gt;
 *          &lt;foo&gt;123&lt;/foo&gt;
 *          &lt;bar&gt;hello, world&lt;/bar&gt;
 *      &lt;/configuration&gt;
 *      &lt;/component&gt;
 *  &lt;/components&gt;
 * &lt;/plexus&gt;
 * </pre>
 *
 * @author <a href="mailto:evenisse@apache.org">Emmanuel Venisse</a>
 */
public class PlexusObjectFactory extends ObjectFactory implements ObjectFactoryInitializable {
    private static final Log log = LogFactory.getLog(PlexusObjectFactory.class);

    private static final String PLEXUS_COMPONENT_TYPE = "plexus.component.type";

    private PlexusContainer base;

    /* (non-Javadoc)
     * @see org.apache.struts2.util.ObjectFactoryInitializable#init(javax.servlet.ServletContext)
     */
    public void init(ServletContext servletContext) {
        if (!PlexusLifecycleListener.isLoaded() || !PlexusFilter.isLoaded()) {
            // uh oh! looks like the lifecycle listener wasn't installed. Let's inform the user
            String message = "********** FATAL ERROR STARTING UP PLEXUS-STRUTS INTEGRATION **********\n" +
                    "Looks like the Plexus listener was not configured for your web app! \n" +
                    "You need to add the following to web.xml: \n" +
                    "\n" +
                    "    <!-- this should be before the Struts filter -->\n" +
                    "    <filter>\n" +
                    "        <filter-name>plexus</filter-name>\n" +
                    "        <filter-class>org.apache.struts2.plexus.PlexusFilter</filter-class>\n" +
                    "    </filter>\n" +
                    "\n" +
                    "...\n" +
                    "\n" +
                    "    <!-- this should be before the Struts filter -->\n" +
                    "    <filter-mapping>\n" +
                    "        <filter-name>plexus</filter-name>\n" +
                    "        <url-pattern>/*</url-pattern>\n" +
                    "    </filter-mapping>\n" +
                    "\n" +
                    "...\n" +
                    "\n" +
                    "    <listener>\n" +
                    "        <listener-class>org.apache.struts2.plexus.PlexusLifecycleListener</listener-class>\n" +
                    "    </listener>";
            log.fatal(message);
            return;
        }

        base = (PlexusContainer) servletContext.getAttribute(PlexusLifecycleListener.KEY);
    }

    /* (non-Javadoc)
     * @see com.opensymphony.xwork2.ObjectFactory#buildAction(java.lang.String, java.lang.String, com.opensymphony.xwork2.config.entities.ActionConfig, java.util.Map)
     */
    public Object buildAction(String actionName, String namespace, ActionConfig config, Map extraContext)
            throws Exception {
        if (extraContext == null) {
            extraContext = new HashMap();
        }

        extraContext.put(PLEXUS_COMPONENT_TYPE, Action.class.getName());

        return super.buildAction(actionName, namespace, config, extraContext);
    }

    /* (non-Javadoc)
     * @see com.opensymphony.xwork2.ObjectFactory#buildInterceptor(com.opensymphony.xwork2.config.entities.InterceptorConfig, java.util.Map)
     */
    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map interceptorRefParams)
            throws ConfigurationException {
        String interceptorClassName = interceptorConfig.getClassName();
        Map thisInterceptorClassParams = interceptorConfig.getParams();
        Map params = (thisInterceptorClassParams == null) ? new HashMap() : new HashMap(thisInterceptorClassParams);
        params.putAll(interceptorRefParams);

        String message;
        Throwable cause;

        try {
            Map extraContext = new HashMap();
            extraContext.put(PLEXUS_COMPONENT_TYPE, Interceptor.class.getName());
            Interceptor interceptor = (Interceptor) buildBean(interceptorClassName, extraContext);
            OgnlUtil.setProperties(params, interceptor);
            interceptor.init();

            return interceptor;
        }
        catch (InstantiationException e) {
            cause = e;
            message = "Unable to instantiate an instance of Interceptor class [" + interceptorClassName + "].";
        }
        catch (IllegalAccessException e) {
            cause = e;
            message = "IllegalAccessException while attempting to instantiate an instance of Interceptor class [" + interceptorClassName + "].";
        }
        catch (ClassCastException e) {
            cause = e;
            message = "Class [" + interceptorClassName + "] does not implement com.opensymphony.xwork2.interceptor.Interceptor";
        }
        catch (Exception e) {
            cause = e;
            message = "Caught Exception while registering Interceptor class " + interceptorClassName;
        }
        catch (NoClassDefFoundError e) {
            cause = e;
            message = "Could not load class " + interceptorClassName + ". Perhaps it exists but certain dependencies are not available?";
        }

        throw new ConfigurationException(message, cause);
    }

    /* (non-Javadoc)
     * @see com.opensymphony.xwork2.ObjectFactory#buildResult(com.opensymphony.xwork2.config.entities.ResultConfig, java.util.Map)
     */
    public Result buildResult(ResultConfig resultConfig, Map extraContext)
            throws Exception {
        if (extraContext == null) {
            extraContext = new HashMap();
        }

        extraContext.put(PLEXUS_COMPONENT_TYPE, Result.class.getName());

        return super.buildResult(resultConfig, extraContext);
    }

    /* (non-Javadoc)
     * @see com.opensymphony.xwork2.ObjectFactory#buildValidator(java.lang.String, java.util.Map, java.util.Map)
     */
    public Validator buildValidator(String className, Map params, Map extraContext)
            throws Exception {
        Map context = new HashMap();
        context.put(PLEXUS_COMPONENT_TYPE, Validator.class.getName());
        Validator validator = (Validator) buildBean(className, context);
        OgnlUtil.setProperties(params, validator);

        return validator;
    }

    /* (non-Javadoc)
     * @see com.opensymphony.xwork2.ObjectFactory#buildBean(java.lang.Class, java.util.Map)
     */
    public Object buildBean(Class clazz, Map extraContext)
            throws Exception {
        try {
            return lookup(clazz.getName(), extraContext);
        }
        catch (Exception e) {
            if (extraContext != null) {
                String type = (String) extraContext.get(PLEXUS_COMPONENT_TYPE);

                if (type != null) {
                    return lookup(type, clazz.getName(), extraContext);
                }
            }

            throw e;
        }
    }

    /* (non-Javadoc)
     * @see com.opensymphony.xwork2.ObjectFactory#getClassInstance(java.lang.String)
     */
    public Class getClassInstance(String className)
            throws ClassNotFoundException {
        PlexusContainer pc = PlexusThreadLocal.getPlexusContainer();

        if (pc == null) {
            pc = base;
        }

        try {
            return pc.lookup(className).getClass();
        }
        catch (Exception e1) {
            try {
                return pc.lookup(Action.class.getName(), className).getClass();
            }
            catch (Exception e2) {
                try {
                    return pc.lookup(Interceptor.class.getName(), className).getClass();
                }
                catch (Exception e3) {
                    try {
                        return pc.lookup(Validator.class.getName(), className).getClass();
                    }
                    catch (Exception e4) {
                        try {
                            return pc.lookup(Result.class.getName(), className).getClass();
                        }
                        catch (Exception e5) {
                            return super.getClassInstance(className);
                        }
                    }
                }
            }
        }
    }

    /**
     * Looks up an object
     * 
     * @param role The role name
     * @param extraContext The extra context
     * @return The object
     * @throws Exception If the lookup fails
     */
    private Object lookup(String role, Map extraContext)
            throws Exception {
        return lookup(role, null, extraContext);
    }

    /**
     * Looks up an object
     * 
     * @param role The role name
     * @param roleHint The role hint
     * @param extraContext The extra context
     * @return The object
     * @throws Exception If the lookup fails
     */
    private Object lookup(String role, String roleHint, Map extraContext)
            throws Exception {
        PlexusContainer pc = PlexusThreadLocal.getPlexusContainer();

        if (pc == null) {
            pc = base;
        }

        try {
            return pc.lookup(role, roleHint);
        }
        catch (Exception e) {
            log.debug("Can't load component (" + role + "/" + roleHint + ") with plexus, try now with struts.", e);
            Object o = super.buildBean(super.getClassInstance(role), extraContext);
            pc.autowire(o);
            return o;
        }
    }
}
"
core/src/main/java/org/apache/struts2/plexus/PlexusThreadLocal.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.plexus;

import org.codehaus.plexus.PlexusContainer;

/**
 * Stores and retrieves the plexus container in the thread
 */
public class PlexusThreadLocal {
    private static ThreadLocal<PlexusContainer> ptl = new ThreadLocal<PlexusContainer>();

    /**
     * @param pc The plexus container for this thread
     */
    public static void setPlexusContainer(PlexusContainer pc) {
        ptl.set(pc);
    }

    /**
     * @return The plexus container for this thread
     */
    public static PlexusContainer getPlexusContainer() {
        return ptl.get();
    }
}
"
core/src/main/java/org/apache/struts2/plexus/PlexusUtils.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.plexus;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.codehaus.plexus.PlexusContainer;
import org.codehaus.plexus.configuration.PlexusConfigurationResourceException;

/**
 * Utility methods for dealing with Plexus
 */
public class PlexusUtils {
    private static final Log log = LogFactory.getLog(PlexusObjectFactory.class);

    /**
     * Configures the container with the configuration file
     * 
     * @param pc The plexus container
     * @param file The file path
     * @throws PlexusConfigurationResourceException If the plexus configuration can't be loaded
     */
    public static void configure(PlexusContainer pc, String file) throws PlexusConfigurationResourceException {
        InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(file);
        if (is == null) {
            log.info("Could not find " + file + ", skipping");
            is = new ByteArrayInputStream("<plexus><components></components></plexus>".getBytes());
        }
        pc.setConfigurationResource(new InputStreamReader(is));
    }
}
"
core/src/main/java/org/apache/struts2/portlet/PortletActionConstants.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.portlet;

/**
 * Interface defining some constants used in the Struts portlet implementation
 * 
 */
public interface PortletActionConstants {
	/**
	 * Default action name to use when no default action has been configured in the portlet
	 * init parameters.
	 */
	String DEFAULT_ACTION_NAME = "default";
	
	/**
	 * Action name parameter name
	 */
	String ACTION_PARAM = "struts.portlet.action"; 
	
	/**
	 * Key for parameter holding the last executed portlet mode.
	 */
	String MODE_PARAM = "struts.portlet.mode";
	
	/**
     * Key used for looking up and storing the portlet phase
     */
    String PHASE = "struts.portlet.phase";

    /**
     * Constant used for the render phase (
     * {@link javax.portlet.Portlet#render(javax.portlet.RenderRequest, javax.portlet.RenderResponse)})
     */
    Integer RENDER_PHASE = new Integer(1);

    /**
     * Constant used for the event phase (
     * {@link javax.portlet.Portlet#processAction(javax.portlet.ActionRequest, javax.portlet.ActionResponse)})
     */
    Integer EVENT_PHASE = new Integer(2);

    /**
     * Key used for looking up and storing the
     * {@link javax.portlet.PortletRequest}
     */
    String REQUEST = "struts.portlet.request";

    /**
     * Key used for looking up and storing the
     * {@link javax.portlet.PortletResponse}
     */
    String RESPONSE = "struts.portlet.response";
    
    /**
     * Key used for looking up and storing the action that was invoked in the event phase.
     */
    String EVENT_ACTION = "struts.portlet.eventAction";

    /**
     * Key used for looking up and storing the
     * {@link javax.portlet.PortletConfig}
     */
    String PORTLET_CONFIG = "struts.portlet.config";

    /**
     * Name of the action used as error handler
     */
    String ERROR_ACTION = "errorHandler";

    /**
     * Key for the portlet namespace stored in the 
     * {@link org.apache.struts2.portlet.context.PortletActionContext}.
     */
    String PORTLET_NAMESPACE = "struts.portlet.portletNamespace";
    
    /**
     * Key for the mode-to-namespace map stored in the 
     * {@link org.apache.struts2.portlet.context.PortletActionContext}.
     */
    String MODE_NAMESPACE_MAP = "struts.portlet.modeNamespaceMap";
    
    /**
     * Key for the default action name for the portlet, stored in the 
     * {@link org.apache.struts2.portlet.context.PortletActionContext}.
     */
    String DEFAULT_ACTION_FOR_MODE = "struts.portlet.defaultActionForMode";
}
"
core/src/main/java/org/apache/struts2/portlet/PortletApplicationMap.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.portlet;

import java.io.Serializable;
import java.util.AbstractMap;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import javax.portlet.PortletContext;

/**
 * Portlet specific {@link java.util.Map} implementation representing the
 * {@link javax.portlet.PortletContext} of a Portlet.
 * 
 */
public class PortletApplicationMap extends AbstractMap implements Serializable {

	private static final long serialVersionUID = 2296107511063504414L;

    private PortletContext context;

	private Set<Object> entries;

	/**
	 * Creates a new map object given the {@link PortletContext}.
	 * 
	 * @param ctx The portlet context.
	 */
	public PortletApplicationMap(PortletContext ctx) {
		this.context = ctx;
	}

	/**
	 * Removes all entries from the Map and removes all attributes from the
	 * portlet context.
	 */
	public void clear() {
		entries = null;

		Enumeration e = context.getAttributeNames();

		while (e.hasMoreElements()) {
			context.removeAttribute(e.nextElement().toString());
		}
	}

	/**
	 * Creates a Set of all portlet context attributes as well as context init
	 * parameters.
	 * 
	 * @return a Set of all portlet context attributes as well as context init
	 *         parameters.
	 */
	public Set entrySet() {
		if (entries == null) {
			entries = new HashSet<Object>();

			// Add portlet context attributes
			Enumeration enumeration = context.getAttributeNames();

			while (enumeration.hasMoreElements()) {
				final String key = enumeration.nextElement().toString();
				final Object value = context.getAttribute(key);
				entries.add(new Map.Entry() {
					public boolean equals(Object obj) {
						Map.Entry entry = (Map.Entry) obj;

						return ((key == null) ? (entry.getKey() == null) : key
								.equals(entry.getKey()))
								&& ((value == null) ? (entry.getValue() == null)
										: value.equals(entry.getValue()));
					}

					public int hashCode() {
						return ((key == null) ? 0 : key.hashCode())
								^ ((value == null) ? 0 : value.hashCode());
					}

					public Object getKey() {
						return key;
					}

					public Object getValue() {
						return value;
					}

					public Object setValue(Object obj) {
						context.setAttribute(key.toString(), obj);

						return value;
					}
				});
			}

			// Add portlet context init params
			enumeration = context.getInitParameterNames();

			while (enumeration.hasMoreElements()) {
				final String key = enumeration.nextElement().toString();
				final Object value = context.getInitParameter(key);
				entries.add(new Map.Entry() {
					public boolean equals(Object obj) {
						Map.Entry entry = (Map.Entry) obj;

						return ((key == null) ? (entry.getKey() == null) : key
								.equals(entry.getKey()))
								&& ((value == null) ? (entry.getValue() == null)
										: value.equals(entry.getValue()));
					}

					public int hashCode() {
						return ((key == null) ? 0 : key.hashCode())
								^ ((value == null) ? 0 : value.hashCode());
					}

					public Object getKey() {
						return key;
					}

					public Object getValue() {
						return value;
					}

					public Object setValue(Object obj) {
						context.setAttribute(key.toString(), obj);

						return value;
					}
				});
			}
		}

		return entries;
	}

	/**
	 * Returns the portlet context attribute or init parameter based on the
	 * given key. If the entry is not found, <tt>null</tt> is returned.
	 * 
	 * @param key
	 *            the entry key.
	 * @return the portlet context attribute or init parameter or <tt>null</tt>
	 *         if the entry is not found.
	 */
	public Object get(Object key) {
		// Try context attributes first, then init params
		// This gives the proper shadowing effects
		String keyString = key.toString();
		Object value = context.getAttribute(keyString);

		return (value == null) ? context.getInitParameter(keyString) : value;
	}

	/**
	 * Sets a portlet context attribute given a attribute name and value.
	 * 
	 * @param key
	 *            the name of the attribute.
	 * @param value
	 *            the value to set.
	 * @return the attribute that was just set.
	 */
	public Object put(Object key, Object value) {
		entries = null;
		context.setAttribute(key.toString(), value);

		return get(key);
	}

	/**
	 * Removes the specified portlet context attribute.
	 * 
	 * @param key
	 *            the attribute to remove.
	 * @return the entry that was just removed.
	 */
	public Object remove(Object key) {
		entries = null;

		Object value = get(key);
		context.removeAttribute(key.toString());

		return value;
	}
}
"
core/src/main/java/org/apache/struts2/portlet/PortletRequestMap.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.portlet;

import java.util.AbstractMap;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

import javax.portlet.PortletRequest;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * A simple implementation of the {@link java.util.Map} interface to handle a collection of request attributes.
 * 
 */
public class PortletRequestMap extends AbstractMap {

    private static final Log LOG = LogFactory.getLog(PortletRequestMap.class);
    
    private Set<Object> entries = null;
    private PortletRequest request = null;

    /**
     * Saves the request to use as the backing for getting and setting values
     *
     * @param request the portlet request.
     */
    public PortletRequestMap(PortletRequest request) {
        this.request = request;
        if(LOG.isDebugEnabled()) {
            LOG.debug("Dumping request parameters: ");
            Iterator params = request.getParameterMap().keySet().iterator();
            while(params.hasNext()) {
                String key = (String)params.next();
                String val = request.getParameter(key);
                LOG.debug(key + " = " + val);
            }
        }
    }

    /**
     * Removes all attributes from the request as well as clears entries in this
     * map.
     */
    public void clear() {
        entries = null;
        Enumeration keys = request.getAttributeNames();

        while (keys.hasMoreElements()) {
            String key = (String) keys.nextElement();
            request.removeAttribute(key);
        }
    }

    /**
     * Returns a Set of attributes from the portlet request.
     * 
     * @return a Set of attributes from the portlet request.
     */
    public Set entrySet() {
        if (entries == null) {
            entries = new HashSet<Object>();

            Enumeration enumeration = request.getAttributeNames();

            while (enumeration.hasMoreElements()) {
                final String key = enumeration.nextElement().toString();
                final Object value = request.getAttribute(key);
                entries.add(new Entry() {
                    public boolean equals(Object obj) {
                        Entry entry = (Entry) obj;

                        return ((key == null) ? (entry.getKey() == null) : key
                                .equals(entry.getKey()))
                                && ((value == null) ? (entry.getValue() == null)
                                        : value.equals(entry.getValue()));
                    }

                    public int hashCode() {
                        return ((key == null) ? 0 : key.hashCode())
                                ^ ((value == null) ? 0 : value.hashCode());
                    }

                    public Object getKey() {
                        return key;
                    }

                    public Object getValue() {
                        return value;
                    }

                    public Object setValue(Object obj) {
                        request.setAttribute(key, obj);

                        return value;
                    }
                });
            }
        }

        return entries;
    }

    /**
     * Returns the request attribute associated with the given key or
     * <tt>null</tt> if it doesn't exist.
     * 
     * @param key the name of the request attribute.
     * @return the request attribute or <tt>null</tt> if it doesn't exist.
     */
    public Object get(Object key) {
        return request.getAttribute(key.toString());
    }

    /**
     * Saves an attribute in the request.
     * 
     * @param key the name of the request attribute.
     * @param value the value to set.
     * @return the object that was just set.
     */
    public Object put(Object key, Object value) {
        entries = null;
        request.setAttribute(key.toString(), value);

        return get(key);
    }

    /**
     * Removes the specified request attribute.
     * 
     * @param key the name of the attribute to remove.
     * @return the value that was removed or <tt>null</tt> if the value was
     * not found (and hence, not removed).
     */
    public Object remove(Object key) {
        entries = null;

        Object value = get(key);
        request.removeAttribute(key.toString());

        return value;
    }

}
"
core/src/main/java/org/apache/struts2/portlet/PortletSessionMap.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.portlet;

import java.util.AbstractMap;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import javax.portlet.PortletRequest;
import javax.portlet.PortletSession;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * A simple implementation of the {@link java.util.Map} interface to handle a collection of portlet session
 * attributes. The {@link #entrySet()} method enumerates over all session attributes and creates a Set of entries.
 * Note, this will occur lazily - only when the entry set is asked for.
 * 
 */
public class PortletSessionMap extends AbstractMap {
    
    private static final Log LOG = LogFactory.getLog(PortletSessionMap.class);

    private PortletSession session = null;
    private Set<Object> entries = null;

    /**
     * Creates a new session map given a portlet request. 
     *
     * @param request the portlet request object.
     */
    public PortletSessionMap(PortletRequest request) {
        this.session = request.getPortletSession();
        if(LOG.isDebugEnabled()) {
            LOG.debug("Dumping session info: ");
            Enumeration enumeration = session.getAttributeNames();
            while(enumeration.hasMoreElements()) {
                String key = (String)enumeration.nextElement();
                Object val = session.getAttribute(key);
                LOG.debug(key + " = " + val);
            }
        }
    }

    /**
     * @see java.util.Map#entrySet()
     */
    public Set entrySet() {
        synchronized (session) {
            if (entries == null) {
                entries = new HashSet<Object>();

                Enumeration enumeration = session.getAttributeNames();

                while (enumeration.hasMoreElements()) {
                    final String key = enumeration.nextElement().toString();
                    final Object value = session.getAttribute(key);
                    entries.add(new Map.Entry() {
                        public boolean equals(Object obj) {
                            Map.Entry entry = (Map.Entry) obj;

                            return ((key == null) ? (entry.getKey() == null)
                                    : key.equals(entry.getKey()))
                                    && ((value == null) ? (entry.getValue() == null)
                                            : value.equals(entry.getValue()));
                        }

                        public int hashCode() {
                            return ((key == null) ? 0 : key.hashCode())
                                    ^ ((value == null) ? 0 : value.hashCode());
                        }

                        public Object getKey() {
                            return key;
                        }

                        public Object getValue() {
                            return value;
                        }

                        public Object setValue(Object obj) {
                            session.setAttribute(key, obj);

                            return value;
                        }
                    });
                }
            }
        }

        return entries;
    }

    /**
     * Returns the session attribute associated with the given key or
     * <tt>null</tt> if it doesn't exist.
     * 
     * @param key the name of the session attribute.
     * @return the session attribute or <tt>null</tt> if it doesn't exist.
     */
    public Object get(Object key) {
        synchronized (session) {
            return session.getAttribute(key.toString());
        }
    }

    /**
     * Saves an attribute in the session.
     * 
     * @param key the name of the session attribute.
     * @param value the value to set.
     * @return the object that was just set.
     */
    public Object put(Object key, Object value) {
        synchronized (session) {
            entries = null;
            session.setAttribute(key.toString(), value);

            return get(key);
        }
    }

    /**
     * @see java.util.Map#clear()
     */
    public void clear() {
        synchronized (session) {
            entries = null;
            session.invalidate();
        }
    }

    /**
     * Removes the specified session attribute.
     * 
     * @param key the name of the attribute to remove.
     * @return the value that was removed or <tt>null</tt> if the value was
     * not found (and hence, not removed).
     */
    public Object remove(Object key) {
        synchronized (session) {
            entries = null;

            Object value = get(key);
            session.removeAttribute(key.toString());

            return value;
        }
    }
}
"
core/src/main/java/org/apache/struts2/portlet/context/PortletActionContext.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.portlet.context;

import java.util.Map;

import javax.portlet.ActionRequest;
import javax.portlet.ActionResponse;
import javax.portlet.PortletConfig;
import javax.portlet.PortletRequest;
import javax.portlet.PortletResponse;
import javax.portlet.RenderRequest;
import javax.portlet.RenderResponse;

import org.apache.struts2.portlet.PortletActionConstants;

import com.opensymphony.xwork2.ActionContext;


/**
 * PortletActionContext. ActionContext thread local for the portlet environment.
 * 
 * @version $Revision$ $Date$
 */
public class PortletActionContext implements PortletActionConstants {

    /**
     * Get the PortletConfig of the portlet that is executing.
     *
     * @return The PortletConfig of the executing portlet.
     */
    public static PortletConfig getPortletConfig() {
        return (PortletConfig) getContext().get(PORTLET_CONFIG);
    }

    /**
     * Get the RenderRequest. Can only be invoked in the render phase.
     *
     * @return The current RenderRequest.
     * @throws IllegalStateException If the method is invoked in the wrong phase.
     */
    public static RenderRequest getRenderRequest() {
        if (!isRender()) {
            throw new IllegalStateException(
                    "RenderRequest cannot be obtained in event phase");
        }
        return (RenderRequest) getContext().get(REQUEST);
    }

    /**
     * Get the RenderResponse. Can only be invoked in the render phase.
     *
     * @return The current RenderResponse.
     * @throws IllegalStateException If the method is invoked in the wrong phase.
     */
    public static RenderResponse getRenderResponse() {
        if (!isRender()) {
            throw new IllegalStateException(
                    "RenderResponse cannot be obtained in event phase");
        }
        return (RenderResponse) getContext().get(RESPONSE);
    }

    /**
     * Get the ActionRequest. Can only be invoked in the event phase.
     *
     * @return The current ActionRequest.
     * @throws IllegalStateException If the method is invoked in the wrong phase.
     */
    public static ActionRequest getActionRequest() {
        if (!isEvent()) {
            throw new IllegalStateException(
                    "ActionRequest cannot be obtained in render phase");
        }
        return (ActionRequest) getContext().get(REQUEST);
    }

    /**
     * Get the ActionRequest. Can only be invoked in the event phase.
     *
     * @return The current ActionRequest.
     * @throws IllegalStateException If the method is invoked in the wrong phase.
     */
    public static ActionResponse getActionResponse() {
        if (!isEvent()) {
            throw new IllegalStateException(
                    "ActionResponse cannot be obtained in render phase");
        }
        return (ActionResponse) getContext().get(RESPONSE);
    }
    
    /**
     * Get the action namespace of the portlet. Used to organize actions for multiple portlets in
     * the same portlet application.
     *
     * @return The portlet namespace as defined in <code>portlet.xml</code> and <code>struts.xml</code>
     */
    public static String getPortletNamespace() {
        return (String)getContext().get(PORTLET_NAMESPACE);
    }

    /**
     * Get the current PortletRequest.
     *
     * @return The current PortletRequest.
     */
    public static PortletRequest getRequest() {
        return (PortletRequest) getContext().get(REQUEST);
    }

    /**
     * Get the current PortletResponse
     *
     * @return The current PortletResponse.
     */
    public static PortletResponse getResponse() {
        return (PortletResponse) getContext().get(RESPONSE);
    }

    /**
     * Get the phase that the portlet is executing in.
     *
     * @return {@link PortletActionConstants#RENDER_PHASE} in render phase, and
     * {@link PortletActionConstants#EVENT_PHASE} in the event phase.
     */
    public static Integer getPhase() {
        return (Integer) getContext().get(PHASE);
    }

    /**
     * @return <code>true</code> if the Portlet is executing in render phase.
     */
    public static boolean isRender() {
        return PortletActionConstants.RENDER_PHASE.equals(getPhase());
    }

    /**
     * @return <code>true</code> if the Portlet is executing in the event phase.
     */
    public static boolean isEvent() {
        return PortletActionConstants.EVENT_PHASE.equals(getPhase());
    }

    /**
     * @return The current ActionContext.
     */
    private static ActionContext getContext() {
        return ActionContext.getContext();
    }
    
    /**
     * Check to see if the current request is a portlet request.
     *
     * @return <code>true</code> if the current request is a portlet request.
     */
    public static boolean isPortletRequest() {
        return getRequest() != null;
    }

    /**
     * Get the default action name for the current mode.
     *
     * @return The default action name for the current portlet mode.
     */
    public static String getDefaultActionForMode() {
        return (String)getContext().get(DEFAULT_ACTION_FOR_MODE);
    }

    /**
     * Get the namespace to mode mappings.
     * 
     * @return The map of the namespaces for each mode.
     */
    public static Map getModeNamespaceMap() {
        return (Map)getContext().get(MODE_NAMESPACE_MAP);
    }

}
"
core/src/main/java/org/apache/struts2/portlet/context/PreparatorServlet.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.portlet.context;

import java.io.IOException;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.StrutsStatics;

import com.opensymphony.xwork2.ActionContext;

/**
 * Since a portlet is not dispatched the same way as a servlet, the 
 * {@link org.apache.struts2.ServletActionContext} is not immediately available, as it 
 * depends on objects from the servlet API. However, the WW2 view implementations require access
 * to the objects in the {@link org.apache.struts2.ServletActionContext}, and this servlet
 * makes sure that these are available when the portlet actions are executing the render results.
 * 
 */
public class PreparatorServlet extends HttpServlet implements StrutsStatics {

	private static final long serialVersionUID = 1853399729352984089L;
	
	private final static Log LOG = LogFactory.getLog(PreparatorServlet.class);

    /**
     * Prepares the {@link org.apache.struts2.ServletActionContext} with the
     * {@link ServletContext}, {@link HttpServletRequest} and {@link HttpServletResponse}.
     */
    public void service(HttpServletRequest servletRequest,
            HttpServletResponse servletResponse) throws ServletException,
            IOException {
        LOG.debug("Preparing servlet objects for dispatch");
        ServletContext ctx = getServletContext();
        ActionContext.getContext().put(SERVLET_CONTEXT, ctx);
        ActionContext.getContext().put(HTTP_REQUEST, servletRequest);
        ActionContext.getContext().put(HTTP_RESPONSE, servletResponse);
        LOG.debug("Preparation complete");
    }

}
"
core/src/main/java/org/apache/struts2/portlet/context/ServletContextHolderListener.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.portlet.context;

import javax.servlet.ServletContext;
import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;

/**
 * Some of the factory/managers (e.g. the ObjectFactory) need access to 
 * the {@link org.apache.struts2.ServletActionContext} object when initializing.
 * This {@link javax.servlet.ServletContextListener} keeps a reference to the 
 * {@link javax.servlet.ServletContext} and exposes it through a <code>public static</code>
 * method.
 * 
 */
public class ServletContextHolderListener implements ServletContextListener {

    private static ServletContext context = null;

    /**
     * @return The current servlet context
     */
    public static ServletContext getServletContext() {
        return context;
    }

    /**
     * Stores the reference to the {@link ServletContext}.
     * 
     * @see javax.servlet.ServletContextListener#contextInitialized(javax.servlet.ServletContextEvent)
     */
    public void contextInitialized(ServletContextEvent event) {
        context = event.getServletContext();
        
    }

    /**
     * @see javax.servlet.ServletContextListener#contextDestroyed(javax.servlet.ServletContextEvent)
     */
    public void contextDestroyed(ServletContextEvent event) {

    }

}
"
core/src/main/java/org/apache/struts2/portlet/dispatcher/DirectRenderFromEventAction.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.portlet.dispatcher;

import com.opensymphony.xwork2.Action;

import java.io.Serializable;

/**
 * When a portlet is targetted for an <code>event</code>, the portlet will receive two
 * portlet requests, one for the <code>event</code> phase, and then followed by a <code>render</code>
 * operation. When in the <code>event</code> phase, the action that is executed can't render
 * any output. This means that if an action in the XWork configuration is executed in the event
 * phase, and the action is set up with a result that should render something, the result can't
 * immediately be executed. The portlet needs to "wait" to the render phase to do the
 * rendering.
 * <p/>
 * When the {@link org.apache.struts2.portlet.result.PortletResult} detects such a
 * scenario, instead of executing the actual view, it prepares a couple of render parameters
 * specifying this action and the location of the view, which then will be executed in the
 * following render request.
 */
public class DirectRenderFromEventAction implements Action, Serializable {

    private static final long serialVersionUID = -1814807772308405785L;

    private String location = null;

    /**
     * Get the location of the view.
     *
     * @return Returns the location.
     */
    public String getLocation() {
        return location;
    }

    /**
     * Set the location of the view.
     *
     * @param location The location to set.
     */
    public void setLocation(String location) {
        this.location = location;
    }

    /**
     * Always return success.
     *
     * @return SUCCESS
     */
    public String execute() throws Exception {
        return SUCCESS;
    }
}
"
core/src/main/java/org/apache/struts2/portlet/dispatcher/Jsr168Dispatcher.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.portlet.dispatcher;

import java.io.IOException;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

import javax.portlet.ActionRequest;
import javax.portlet.ActionResponse;
import javax.portlet.GenericPortlet;
import javax.portlet.PortletConfig;
import javax.portlet.PortletException;
import javax.portlet.PortletMode;
import javax.portlet.PortletRequest;
import javax.portlet.PortletResponse;
import javax.portlet.RenderRequest;
import javax.portlet.RenderResponse;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.StrutsConstants;
import org.apache.struts2.StrutsStatics;
import org.apache.struts2.config.Settings;
import org.apache.struts2.dispatcher.ApplicationMap;
import org.apache.struts2.dispatcher.Dispatcher;
import org.apache.struts2.dispatcher.RequestMap;
import org.apache.struts2.dispatcher.SessionMap;
import org.apache.struts2.dispatcher.mapper.ActionMapping;
import org.apache.struts2.portlet.PortletActionConstants;
import org.apache.struts2.portlet.PortletApplicationMap;
import org.apache.struts2.portlet.PortletRequestMap;
import org.apache.struts2.portlet.PortletSessionMap;
import org.apache.struts2.portlet.context.PortletActionContext;
import org.apache.struts2.portlet.context.ServletContextHolderListener;
import org.apache.struts2.util.AttributeMap;
import org.apache.struts2.util.ObjectFactoryInitializable;

import com.opensymphony.xwork2.util.ClassLoaderUtil;
import com.opensymphony.xwork2.util.FileManager;
import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionProxy;
import com.opensymphony.xwork2.ActionProxyFactory;
import com.opensymphony.xwork2.ObjectFactory;
import com.opensymphony.xwork2.config.ConfigurationException;
import com.opensymphony.xwork2.config.Configuration;
import com.opensymphony.xwork2.util.LocalizedTextUtil;
import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: javadoc -->
 * <p>
 * Struts JSR-168 portlet dispatcher. Similar to the WW2 Servlet dispatcher,
 * but adjusted to a portal environment. The portlet is configured through the <tt>portlet.xml</tt>
 * descriptor. Examples and descriptions follow below:
 * </p>
 * <!-- END SNIPPET: javadoc --> 
 * 
 * @author <a href="nils-helge.garli@bekk.no">Nils-Helge Garli </a>
 * @author Rainer Hermanns
 * 
 * <p><b>Init parameters</b></p>
 * <!-- START SNIPPET: params -->
 * <table class="confluenceTable">
 * <tr>
 * 	<th class="confluenceTh">Name</th>
 * <th class="confluenceTh">Description</th>
 * <th class="confluenceTh">Default value</th>
 * </tr>
 * <tr>
 * 	<td class="confluenceTd">portletNamespace</td><td class="confluenceTd">The namespace for the portlet in the xwork configuration. This 
 * 		namespace is prepended to all action lookups, and makes it possible to host multiple 
 * 		portlets in the same portlet application. If this parameter is set, the complete namespace 
 * 		will be <tt>/portletNamespace/modeNamespace/actionName</tt></td><td class="confluenceTd">The default namespace</td>
 * </tr>
 * <tr>
 *  <td class="confluenceTd">viewNamespace</td><td class="confluenceTd">Base namespace in the xwork configuration for the <tt>view</tt> portlet 
 * 		mode</td><td class="confluenceTd">The default namespace</td>
 * </tr>
 * <tr>
 *  <td class="confluenceTd">editNamespace</td><td class="confluenceTd">Base namespace in the xwork configuration for the <tt>edit</tt> portlet 
 * 		mode</td><td class="confluenceTd">The default namespace</td>
 * </tr>
 * <tr>
 *  <td class="confluenceTd">helpNamespace</td><td class="confluenceTd">Base namespace in the xwork configuration for the <tt>help</tt> portlet 
 * 		mode</td><td class="confluenceTd">The default namespace</td>
 * </tr>
 * <tr>
 *  <td class="confluenceTd">defaultViewAction</td><td class="confluenceTd">Default action to invoke in the <tt>view</tt> portlet mode if no action is
 * 		specified</td><td class="confluenceTd"><tt>default</tt></td>
 * </tr>
 * <tr>
 *  <td class="confluenceTd">defaultEditAction</td><td class="confluenceTd">Default action to invoke in the <tt>edit</tt> portlet mode if no action is
 * 		specified</td><td class="confluenceTd"><tt>default</tt></td>
 * </tr>
 * <tr>
 *  <td class="confluenceTd">defaultHelpAction</td><td class="confluenceTd">Default action to invoke in the <tt>help</tt> portlet mode if no action is
 * 		specified</td><td class="confluenceTd"><tt>default</tt></td>
 * </tr>
 * </table>
 * <!-- END SNIPPET: params -->
 * <p><b>Example:</b></p>
 * <pre>
 * <!-- START SNIPPET: example -->
 * 
 * &lt;init-param&gt;
 *     &lt;!-- The view mode namespace. Maps to a namespace in the xwork config file --&gt;
 *     &lt;name&gt;viewNamespace&lt;/name&gt;
 *     &lt;value&gt;/view&lt;/value&gt;
 * &lt;/init-param&gt;
 * &lt;init-param&gt;
 *    &lt;!-- The default action to invoke in view mode --&gt;
 *	  &lt;name&gt;defaultViewAction&lt;/name&gt;
 *    &lt;value&gt;index&lt;/value&gt;
 * &lt;/init-param&gt;
 * &lt;init-param&gt;
 *     &lt;!-- The view mode namespace. Maps to a namespace in the xwork config file --&gt;
 *     &lt;name&gt;editNamespace&lt;/name&gt;
 *     &lt;value&gt;/edit&lt;/value&gt;
 * &lt;/init-param&gt;
 * &lt;init-param&gt;
 *     &lt;!-- The default action to invoke in view mode --&gt;
 *     &lt;name&gt;defaultEditAction&lt;/name&gt;
 *	   &lt;value&gt;index&lt;/value&gt;
 * &lt;/init-param&gt;
 * &lt;init-param&gt;
 *     &lt;!-- The view mode namespace. Maps to a namespace in the xwork config file --&gt;
 *     &lt;name&gt;helpNamespace&lt;/name&gt;
 *     &lt;value&gt;/help&lt;/value&gt;
 * &lt;/init-param&gt;
 * &lt;init-param&gt;
 *     &lt;!-- The default action to invoke in view mode --&gt;
 *     &lt;name&gt;defaultHelpAction&lt;/name&gt;
 *     &lt;value&gt;index&lt;/value&gt;
 * &lt;/init-param&gt;
 *   
 * <!-- END SNIPPET: example -->
 * </pre>
 */
public class Jsr168Dispatcher extends GenericPortlet implements StrutsStatics,
        PortletActionConstants {

    private static final Log LOG = LogFactory.getLog(Jsr168Dispatcher.class);

    private ActionProxyFactory factory = null;

    private Map<PortletMode,String> modeMap = new HashMap<PortletMode,String>(3);

    private Map<PortletMode,ActionMapping> actionMap = new HashMap<PortletMode,ActionMapping>(3);

    private String portletNamespace = null;
    
    private Dispatcher dispatcherUtils;

    private boolean devMode = false;

    /**
     * Initialize the portlet with the init parameters from <tt>portlet.xml</tt>
     */
    public void init(PortletConfig cfg) throws PortletException {
        super.init(cfg);
        LOG.debug("Initializing portlet " + getPortletName());
        // For testability
        if (factory == null) {
            factory = ActionProxyFactory.getFactory();
        }
        portletNamespace = cfg.getInitParameter("portletNamespace");
        LOG.debug("PortletNamespace: " + portletNamespace);
        parseModeConfig(cfg, PortletMode.VIEW, "viewNamespace",
                "defaultViewAction");
        parseModeConfig(cfg, PortletMode.EDIT, "editNamespace",
                "defaultEditAction");
        parseModeConfig(cfg, PortletMode.HELP, "helpNamespace",
                "defaultHelpAction");
        parseModeConfig(cfg, new PortletMode("config"), "configNamespace",
                "defaultConfigAction");
        parseModeConfig(cfg, new PortletMode("about"), "aboutNamespace",
                "defaultAboutAction");
        parseModeConfig(cfg, new PortletMode("print"), "printNamespace",
                "defaultPrintAction");
        parseModeConfig(cfg, new PortletMode("preview"), "previewNamespace",
                "defaultPreviewAction");
        parseModeConfig(cfg, new PortletMode("edit_defaults"),
                "editDefaultsNamespace", "defaultEditDefaultsAction");
        if (StringUtils.isEmpty(portletNamespace)) {
            portletNamespace = "";
        }
        LocalizedTextUtil
                .addDefaultResourceBundle("org/apache/struts2/struts-messages");

        //check for configuration reloading
        if ("true".equalsIgnoreCase(Settings
                .get(StrutsConstants.STRUTS_CONFIGURATION_XML_RELOAD))) {
            FileManager.setReloadingConfigs(true);
        }

        if ("true".equalsIgnoreCase(Settings.get(StrutsConstants.STRUTS_DEVMODE))) {
            devMode = true;
            Settings.set(StrutsConstants.STRUTS_I18N_RELOAD, "true");
            Settings.set(StrutsConstants.STRUTS_CONFIGURATION_XML_RELOAD, "true");
        }

        if (Settings.isSet(StrutsConstants.STRUTS_OBJECTFACTORY)) {
            String className = (String) Settings
                    .get(StrutsConstants.STRUTS_OBJECTFACTORY);
            if (className.equals("spring")) {
                // note: this class name needs to be in string form so we don't put hard
                //       dependencies on spring, since it isn't technically required.
                className = "org.apache.struts2.spring.StrutsSpringObjectFactory";
            } else if (className.equals("plexus")) {
                // note: this class name needs to be in string form so we don't put hard
                //       dependencies on spring, since it isn't technically required.
                className = "org.apache.struts2.plexus.PlexusObjectFactory";
            }

            try {
                Class clazz = ClassLoaderUtil.loadClass(className,
                        Jsr168Dispatcher.class);
                ObjectFactory objectFactory = (ObjectFactory) clazz
                        .newInstance();
                if (objectFactory instanceof ObjectFactoryInitializable) {
                    ((ObjectFactoryInitializable) objectFactory)
                            .init(ServletContextHolderListener
                                    .getServletContext());
                }
                ObjectFactory.setObjectFactory(objectFactory);
            } catch (Exception e) {
                LOG.error("Could not load ObjectFactory named " + className
                        + ". Using default ObjectFactory.", e);
            }
        }
        Dispatcher.setPortletSupportActive(true);
        dispatcherUtils = new Dispatcher(ServletContextHolderListener.getServletContext());
    }

    /**
     * Parse the mode to namespace mappings configured in portlet.xml
     * @param portletConfig The PortletConfig
     * @param portletMode The PortletMode
     * @param nameSpaceParam Name of the init parameter where the namespace for the mode
     * is configured.
     * @param defaultActionParam Name of the init parameter where the default action to
     * execute for the mode is configured.
     */
    private void parseModeConfig(PortletConfig portletConfig,
            PortletMode portletMode, String nameSpaceParam,
            String defaultActionParam) {
        String namespace = portletConfig.getInitParameter(nameSpaceParam);
        if (StringUtils.isEmpty(namespace)) {
            namespace = "";
        }
        modeMap.put(portletMode, namespace);
        String defaultAction = portletConfig
                .getInitParameter(defaultActionParam);
        if (StringUtils.isEmpty(defaultAction)) {
            defaultAction = DEFAULT_ACTION_NAME;
        }
        StringBuffer fullPath = new StringBuffer();
        if (StringUtils.isNotEmpty(portletNamespace)) {
            fullPath.append(portletNamespace + "/");
        }
        if (StringUtils.isNotEmpty(namespace)) {
            fullPath.append(namespace + "/");
        }
        fullPath.append(defaultAction);
        ActionMapping mapping = new ActionMapping();
        mapping.setName(getActionName(fullPath.toString()));
        mapping.setNamespace(getNamespace(fullPath.toString()));
        actionMap.put(portletMode, mapping);
    }

    /**
     * Service an action from the <tt>event</tt> phase.
     *
     * @see javax.portlet.Portlet#processAction(javax.portlet.ActionRequest,
     *      javax.portlet.ActionResponse)
     */
    public void processAction(ActionRequest request, ActionResponse response)
            throws PortletException, IOException {
        LOG.debug("Entering processAction");
        resetActionContext();
        try {
            serviceAction(request, response, getActionMapping(request),
                    getRequestMap(request), getParameterMap(request),
                    getSessionMap(request), getApplicationMap(),
                    portletNamespace, EVENT_PHASE);
            LOG.debug("Leaving processAction");
        } finally {
            ActionContext.setContext(null);
        }
    }

    /**
     * Service an action from the <tt>render</tt> phase.
     *
     * @see javax.portlet.Portlet#render(javax.portlet.RenderRequest,
     *      javax.portlet.RenderResponse)
     */
    public void render(RenderRequest request, RenderResponse response)
            throws PortletException, IOException {

        LOG.debug("Entering render");
        resetActionContext();
        response.setTitle(getTitle(request));
        try {
            // Check to see if an event set the render to be included directly
            serviceAction(request, response, getActionMapping(request),
                    getRequestMap(request), getParameterMap(request),
                    getSessionMap(request), getApplicationMap(),
                    portletNamespace, RENDER_PHASE);
            LOG.debug("Leaving render");
        } finally {
            resetActionContext();
        }
    }

    /**
     *  Reset the action context.
     */
    private void resetActionContext() {
        ActionContext.setContext(null);
    }

    /**
     * Merges all application and portlet attributes into a single
     * <tt>HashMap</tt> to represent the entire <tt>Action</tt> context.
     *
     * @param requestMap a Map of all request attributes.
     * @param parameterMap a Map of all request parameters.
     * @param sessionMap a Map of all session attributes.
     * @param applicationMap a Map of all servlet context attributes.
     * @param request the PortletRequest object.
     * @param response the PortletResponse object.
     * @param portletConfig the PortletConfig object.
     * @param phase The portlet phase (render or action, see
     *        {@link PortletActionConstants})
     * @return a HashMap representing the <tt>Action</tt> context.
     */
    public HashMap createContextMap(Map requestMap, Map parameterMap,
            Map sessionMap, Map applicationMap, PortletRequest request,
            PortletResponse response, PortletConfig portletConfig, Integer phase) {

        // TODO Must put http request/response objects into map for use with
        // ServletActionContext
        HashMap<String,Object> extraContext = new HashMap<String,Object>();
        extraContext.put(ActionContext.PARAMETERS, parameterMap);
        extraContext.put(ActionContext.SESSION, sessionMap);
        extraContext.put(ActionContext.APPLICATION, applicationMap);

        Locale locale = null;
        if (Settings.isSet(StrutsConstants.STRUTS_LOCALE)) {
            locale = LocalizedTextUtil.localeFromString(Settings.get(StrutsConstants.STRUTS_LOCALE), request.getLocale());
        } else {
            locale = request.getLocale();
        }
        extraContext.put(ActionContext.LOCALE, locale);

        extraContext.put(StrutsStatics.STRUTS_PORTLET_CONTEXT, getPortletContext());
        extraContext.put(ActionContext.DEV_MODE, Boolean.valueOf(Settings.get(StrutsConstants.STRUTS_DEVMODE)));
        extraContext.put(REQUEST, request);
        extraContext.put(RESPONSE, response);
        extraContext.put(PORTLET_CONFIG, portletConfig);
        extraContext.put(PORTLET_NAMESPACE, portletNamespace);
        extraContext.put(DEFAULT_ACTION_FOR_MODE, actionMap.get(request.getPortletMode()));
        // helpers to get access to request/session/application scope
        extraContext.put("request", requestMap);
        extraContext.put("session", sessionMap);
        extraContext.put("application", applicationMap);
        extraContext.put("parameters", parameterMap);
        extraContext.put(MODE_NAMESPACE_MAP, modeMap);

        extraContext.put(PHASE, phase);

        AttributeMap attrMap = new AttributeMap(extraContext);
        extraContext.put("attr", attrMap);

        return extraContext;
    }

    /**
     * Loads the action and executes it. This method first creates the action
     * context from the given parameters then loads an <tt>ActionProxy</tt>
     * from the given action name and namespace. After that, the action is
     * executed and output channels throught the response object.
     *
     * @param request the HttpServletRequest object.
     * @param response the HttpServletResponse object.
     * @param mapping the action mapping.
     * @param requestMap a Map of request attributes.
     * @param parameterMap a Map of request parameters.
     * @param sessionMap a Map of all session attributes.
     * @param applicationMap a Map of all application attributes.
     * @param portletNamespace the namespace or context of the action.
     * @param phase The portlet phase (render or action, see
     *        {@link PortletActionConstants})
     */
    public void serviceAction(PortletRequest request, PortletResponse response,
            ActionMapping mapping, Map requestMap, Map parameterMap,
            Map sessionMap, Map applicationMap, String portletNamespace,
            Integer phase) throws PortletException {
        LOG.debug("serviceAction");
        Dispatcher.setInstance(dispatcherUtils);
        HashMap extraContext = createContextMap(requestMap, parameterMap,
                sessionMap, applicationMap, request, response,
                getPortletConfig(), phase);
        String actionName = mapping.getName();
        String namespace = mapping.getNamespace();
        try {
            LOG.debug("Creating action proxy for name = " + actionName
                    + ", namespace = " + namespace);
            ActionProxy proxy = factory.createActionProxy(
                    dispatcherUtils.getConfigurationManager().getConfiguration(), namespace,
                    actionName, extraContext);
            request.setAttribute("struts.valueStack", proxy.getInvocation()
                    .getStack());
            if (PortletActionConstants.RENDER_PHASE.equals(phase)
                    && StringUtils.isNotEmpty(request
                            .getParameter(EVENT_ACTION))) {

                ActionProxy action = (ActionProxy) request.getPortletSession()
                        .getAttribute(EVENT_ACTION);
                if (action != null) {
                    OgnlValueStack stack = proxy.getInvocation().getStack();
                    Object top = stack.pop();
                    stack.push(action.getInvocation().getAction());
                    stack.push(top);
                }
            }
            proxy.execute();
            if (PortletActionConstants.EVENT_PHASE.equals(phase)) {
                // Store the executed action in the session for retrieval in the
                // render phase.
                ActionResponse actionResp = (ActionResponse) response;
                request.getPortletSession().setAttribute(EVENT_ACTION, proxy);
                actionResp.setRenderParameter(EVENT_ACTION, "true");
            }
        } catch (ConfigurationException e) {
            LOG.error("Could not find action", e);
            throw new PortletException("Could not find action " + actionName, e);
        } catch (Exception e) {
            LOG.error("Could not execute action", e);
            throw new PortletException("Error executing action " + actionName,
                    e);
        }
    }

    /**
     * Returns a Map of all application attributes. Copies all attributes from
     * the {@link PortletActionContext}into an {@link ApplicationMap}.
     * 
     * @return a Map of all application attributes.
     */
    protected Map getApplicationMap() {
        return new PortletApplicationMap(getPortletContext());
    }

    /**
     * Gets the namespace of the action from the request. The namespace is the
     * same as the portlet mode. E.g, view mode is mapped to namespace
     * <code>view</code>, and edit mode is mapped to the namespace
     * <code>edit</code>
     * 
     * @param request the PortletRequest object.
     * @return the namespace of the action.
     */
    protected ActionMapping getActionMapping(PortletRequest request) {
        ActionMapping mapping = new ActionMapping();
        if (resetAction(request)) {
            mapping = (ActionMapping) actionMap.get(request.getPortletMode());
        } else {
            String actionPath = request.getParameter(ACTION_PARAM);
            if (StringUtils.isEmpty(actionPath)) {
                mapping = (ActionMapping) actionMap.get(request
                        .getPortletMode());
            } else {
                String namespace = "";
                String action = actionPath;
                int idx = actionPath.lastIndexOf('/');
                if (idx >= 0) {
                    namespace = actionPath.substring(0, idx);
                    action = actionPath.substring(idx + 1);
                }
                mapping.setName(action);
                mapping.setNamespace(namespace);
            }
        }
        return mapping;
    }

    /**
     * Get the namespace part of the action path.
     * @param actionPath Full path to action
     * @return The namespace part.
     */
    String getNamespace(String actionPath) {
        int idx = actionPath.lastIndexOf('/');
        String namespace = "";
        if (idx >= 0) {
            namespace = actionPath.substring(0, idx);
        }
        return namespace;
    }

    /**
     * Get the action name part of the action path.
     * @param actionPath Full path to action
     * @return The action name.
     */
    String getActionName(String actionPath) {
        int idx = actionPath.lastIndexOf('/');
        String action = actionPath;
        if (idx >= 0) {
            action = actionPath.substring(idx + 1);
        }
        return action;
    }

    /**
     * Returns a Map of all request parameters. This implementation just calls
     * {@link PortletRequest#getParameterMap()}.
     * 
     * @param request the PortletRequest object.
     * @return a Map of all request parameters.
     * @throws IOException if an exception occurs while retrieving the parameter
     *         map.
     */
    protected Map getParameterMap(PortletRequest request) throws IOException {
        return new HashMap(request.getParameterMap());
    }

    /**
     * Returns a Map of all request attributes. The default implementation is to
     * wrap the request in a {@link RequestMap}. Override this method to
     * customize how request attributes are mapped.
     * 
     * @param request the PortletRequest object.
     * @return a Map of all request attributes.
     */
    protected Map getRequestMap(PortletRequest request) {
        return new PortletRequestMap(request);
    }

    /**
     * Returns a Map of all session attributes. The default implementation is to
     * wrap the reqeust in a {@link SessionMap}. Override this method to
     * customize how session attributes are mapped.
     * 
     * @param request the PortletRequest object.
     * @return a Map of all session attributes.
     */
    protected Map getSessionMap(PortletRequest request) {
        return new PortletSessionMap(request);
    }

    /**
     * Convenience method to ease testing.
     * @param factory
     */
    protected void setActionProxyFactory(ActionProxyFactory factory) {
        this.factory = factory;
    }

    /**
     * Check to see if the action parameter is valid for the current portlet mode. If the portlet
     * mode has been changed with the portal widgets, the action name is invalid, since the
     * action name belongs to the previous executing portlet mode. If this method evaluates to 
     * <code>true</code> the <code>default&lt;Mode&gt;Action</code> is used instead.
     * @param request The portlet request.
     * @return <code>true</code> if the action should be reset.
     */
    private boolean resetAction(PortletRequest request) {
        boolean reset = false;
        Map paramMap = request.getParameterMap();
        String[] modeParam = (String[]) paramMap.get(MODE_PARAM);
        if (modeParam != null && modeParam.length == 1) {
            String originatingMode = modeParam[0];
            String currentMode = request.getPortletMode().toString();
            if (!currentMode.equals(originatingMode)) {
                reset = true;
            }
        }
        return reset;
    }
}
"
core/src/main/java/org/apache/struts2/portlet/result/PortletResult.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.portlet.result;

import java.io.IOException;
import java.util.StringTokenizer;

import javax.portlet.ActionResponse;
import javax.portlet.PortletConfig;
import javax.portlet.PortletException;
import javax.portlet.PortletRequestDispatcher;
import javax.portlet.RenderRequest;
import javax.portlet.RenderResponse;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.ServletActionContext;
import org.apache.struts2.dispatcher.StrutsResultSupport;
import org.apache.struts2.portlet.PortletActionConstants;
import org.apache.struts2.portlet.context.PortletActionContext;

import com.opensymphony.xwork2.ActionInvocation;

/**
 * Result type that includes a JSP to render.
 * 
 */
public class PortletResult extends StrutsResultSupport {

	private static final long serialVersionUID = 434251393926178567L;

	/**
     * Logger instance.
     */
    private static final Log LOG = LogFactory.getLog(PortletResult.class);

    private String contentType = "text/html";

    private String title;

    /**
     * Execute the result. Obtains the
     * {@link javax.portlet.PortletRequestDispatcher}from the
     * {@link PortletActionContext}and includes the JSP.
     * 
     * @see com.opensymphony.xwork2.Result#execute(com.opensymphony.xwork2.ActionInvocation)
     */
    public void doExecute(String finalLocation,
            ActionInvocation actionInvocation) throws Exception {

        if (PortletActionContext.isRender()) {
            executeRenderResult(finalLocation);
        } else if (PortletActionContext.isEvent()) {
            executeActionResult(finalLocation, actionInvocation);
        } else {
            executeRegularServletResult(finalLocation, actionInvocation);
        }
    }

    /**
     * Executes the regular servlet result.
     *
     * @param finalLocation
     * @param actionInvocation
     */
    private void executeRegularServletResult(String finalLocation,
            ActionInvocation actionInvocation) throws ServletException, IOException {
        ServletContext ctx = ServletActionContext.getServletContext();
        HttpServletRequest req = ServletActionContext.getRequest();
        HttpServletResponse res = ServletActionContext.getResponse();
        try {
            ctx.getRequestDispatcher(finalLocation).include(req, res);
        } catch (ServletException e) {
            LOG.error("ServletException including " + finalLocation, e);
            throw e;
        } catch (IOException e) {
            LOG.error("IOException while including result '" + finalLocation + "'", e);
            throw e;
        }
    }

    /**
     * Executes the action result.
     *
     * @param finalLocation
     * @param invocation
     */
    protected void executeActionResult(String finalLocation,
            ActionInvocation invocation) {
        LOG.debug("Executing result in Event phase");
        ActionResponse res = PortletActionContext.getActionResponse();
        LOG.debug("Setting event render parameter: " + finalLocation);
        if (finalLocation.indexOf('?') != -1) {
            convertQueryParamsToRenderParams(res, finalLocation
                    .substring(finalLocation.indexOf('?') + 1));
            finalLocation = finalLocation.substring(0, finalLocation
                    .indexOf('?'));
        }
        if (finalLocation.endsWith(".action")) {
            // View is rendered with a view action...luckily...
            finalLocation = finalLocation.substring(0, finalLocation
                    .lastIndexOf("."));
            res.setRenderParameter(PortletActionConstants.ACTION_PARAM, finalLocation);
        } else {
            // View is rendered outside an action...uh oh...
            res.setRenderParameter(PortletActionConstants.ACTION_PARAM, "renderDirect");
            res.setRenderParameter("location", finalLocation);
        }
        res.setRenderParameter(PortletActionConstants.MODE_PARAM, PortletActionContext
                .getRequest().getPortletMode().toString());
    }

    /**
     * Converts the query params to render params.
     *
     * @param response
     * @param queryParams
     */
    protected static void convertQueryParamsToRenderParams(
            ActionResponse response, String queryParams) {
        StringTokenizer tok = new StringTokenizer(queryParams, "&");
        while (tok.hasMoreTokens()) {
            String token = tok.nextToken();
            String key = token.substring(0, token.indexOf('='));
            String value = token.substring(token.indexOf('=') + 1);
            response.setRenderParameter(key, value);
        }
    }

    /**
     * Executes the render result.
     *
     * @param finalLocation
     * @throws PortletException
     * @throws IOException
     */
    protected void executeRenderResult(final String finalLocation) throws PortletException, IOException {
        LOG.debug("Executing result in Render phase");
        PortletConfig cfg = PortletActionContext.getPortletConfig();
        RenderRequest req = PortletActionContext.getRenderRequest();
        RenderResponse res = PortletActionContext.getRenderResponse();
        LOG.debug("PortletConfig: " + cfg);
        LOG.debug("RenderRequest: " + req);
        LOG.debug("RenderResponse: " + res);
        res.setContentType(contentType);
        if (StringUtils.isNotEmpty(title)) {
            res.setTitle(title);
        }
        LOG.debug("Location: " + finalLocation);
        PortletRequestDispatcher preparator = cfg.getPortletContext()
                .getNamedDispatcher("preparator");
        if(preparator == null) {
            throw new PortletException("Cannot look up 'preparator' servlet. Make sure that you" +
            		"have configured it correctly in the web.xml file.");
        }
        new IncludeTemplate() {
            protected void when(PortletException e) {
                LOG.error("PortletException while dispatching to 'preparator' servlet", e);
            }
            protected void when(IOException e) {
                LOG.error("IOException while dispatching to 'preparator' servlet", e);
            }
        }.include(preparator, req, res);
        PortletRequestDispatcher dispatcher = cfg.getPortletContext().getRequestDispatcher(finalLocation);
        if(dispatcher == null) {
            throw new PortletException("Could not locate dispatcher for '" + finalLocation + "'");
        }
        new IncludeTemplate() {
            protected void when(PortletException e) {
                LOG.error("PortletException while dispatching to '" + finalLocation + "'");
            }
            protected void when(IOException e) {
                LOG.error("IOException while dispatching to '" + finalLocation + "'");
            }
        }.include(dispatcher, req, res);
    }

    /**
     * Sets the content type.
     *
     * @param contentType The content type to set.
     */
    public void setContentType(String contentType) {
        this.contentType = contentType;
    }

    /**
     * Sets the title.
     *
     * @param title The title to set.
     */
    public void setTitle(String title) {
        this.title = title;
    }
    
    static class IncludeTemplate {
        protected void include(PortletRequestDispatcher dispatcher, RenderRequest req, RenderResponse res) throws PortletException, IOException{
            try {
                dispatcher.include(req, res);
            }
            catch(PortletException e) {
                when(e);
                throw e;
            }
            catch(IOException e) {
                when(e);
                throw e;
            }
        }
        
        protected void when(PortletException e) {}
        
        protected void when(IOException e) {}
    }
}
"
core/src/main/java/org/apache/struts2/portlet/result/PortletVelocityResult.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.portlet.result;

import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;

import javax.portlet.ActionResponse;
import javax.portlet.PortletException;
import javax.portlet.PortletRequestDispatcher;
import javax.servlet.Servlet;
import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.jsp.JspFactory;
import javax.servlet.jsp.PageContext;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.ServletActionContext;
import org.apache.struts2.StrutsConstants;
import org.apache.struts2.config.Settings;
import org.apache.struts2.dispatcher.StrutsResultSupport;
import org.apache.struts2.portlet.PortletActionConstants;
import org.apache.struts2.portlet.context.PortletActionContext;
import org.apache.struts2.views.JspSupportServlet;
import org.apache.struts2.views.velocity.VelocityManager;
import org.apache.velocity.Template;
import org.apache.velocity.app.VelocityEngine;
import org.apache.velocity.context.Context;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: description -->
 * 
 * Using the Servlet container's {@link JspFactory}, this result mocks a JSP
 * execution environment and then displays a Velocity template that will be
 * streamed directly to the servlet output.
 * 
 * <!-- END SNIPPET: description --> <p/><b>This result type takes the
 * following parameters: </b>
 * 
 * <!-- START SNIPPET: params -->
 * 
 * <ul>
 * 
 * <li><b>location (default) </b>- the location of the template to process.
 * </li>
 * 
 * <li><b>parse </b>- true by default. If set to false, the location param
 * will not be parsed for Ognl expressions.</li>
 * 
 * </ul>
 * <p>
 * This result follows the same rules from {@link StrutsResultSupport}.
 * </p>
 * 
 * <!-- END SNIPPET: params -->
 * 
 * <b>Example: </b>
 * 
 * <pre>
 * &lt;!-- START SNIPPET: example --&gt;
 *  &lt;result name=&quot;success&quot; type=&quot;velocity&quot;&gt;
 *    &lt;param name=&quot;location&quot;&gt;foo.vm&lt;/param&gt;
 *  &lt;/result&gt;
 *  &lt;!-- END SNIPPET: example --&gt;
 * </pre>
 * 
 */
public class PortletVelocityResult extends StrutsResultSupport {

	private static final long serialVersionUID = -8241086555872212274L;
	
	private static final Log log = LogFactory
            .getLog(PortletVelocityResult.class);

    /* (non-Javadoc)
     * @see org.apache.struts2.dispatcher.StrutsResultSupport#doExecute(java.lang.String, com.opensymphony.xwork2.ActionInvocation)
     */
    public void doExecute(String location, ActionInvocation invocation)
            throws Exception {
        if (PortletActionContext.isEvent()) {
            executeActionResult(location, invocation);
        } else if (PortletActionContext.isRender()) {
            executeRenderResult(location, invocation);
        }
    }

    /**
     * Executes the result
     * 
     * @param location The location string
     * @param invocation The action invocation
     */
    private void executeActionResult(String location,
            ActionInvocation invocation) {
        ActionResponse res = PortletActionContext.getActionResponse();
        // View is rendered outside an action...uh oh...
        res.setRenderParameter(PortletActionConstants.ACTION_PARAM,
                "freemarkerDirect");
        res.setRenderParameter("location", location);
        res.setRenderParameter(PortletActionConstants.MODE_PARAM, PortletActionContext
                .getRequest().getPortletMode().toString());

    }

    /**
     * Creates a Velocity context from the action, loads a Velocity template and
     * executes the template. Output is written to the servlet output stream.
     * 
     * @param finalLocation the location of the Velocity template
     * @param invocation an encapsulation of the action execution state.
     * @throws Exception if an error occurs when creating the Velocity context,
     *         loading or executing the template or writing output to the
     *         servlet response stream.
     */
    public void executeRenderResult(String finalLocation,
            ActionInvocation invocation) throws Exception {
        prepareServletActionContext();
        OgnlValueStack stack = ActionContext.getContext().getValueStack();

        HttpServletRequest request = ServletActionContext.getRequest();
        HttpServletResponse response = ServletActionContext.getResponse();
        JspFactory jspFactory = null;
        ServletContext servletContext = ServletActionContext
                .getServletContext();
        Servlet servlet = JspSupportServlet.jspSupportServlet;

        VelocityManager.getInstance().init(servletContext);

        boolean usedJspFactory = false;
        PageContext pageContext = (PageContext) ActionContext.getContext().get(
                ServletActionContext.PAGE_CONTEXT);

        if (pageContext == null && servlet != null) {
            jspFactory = JspFactory.getDefaultFactory();
            pageContext = jspFactory.getPageContext(servlet, request, response,
                    null, true, 8192, true);
            ActionContext.getContext().put(ServletActionContext.PAGE_CONTEXT,
                    pageContext);
            usedJspFactory = true;
        }

        try {
            String encoding = getEncoding(finalLocation);
            String contentType = getContentType(finalLocation);

            if (encoding != null) {
                contentType = contentType + ";charset=" + encoding;
            }

            VelocityManager velocityManager = VelocityManager.getInstance();
            Template t = getTemplate(stack,
                    velocityManager.getVelocityEngine(), invocation,
                    finalLocation, encoding);

            Context context = createContext(velocityManager, stack, request,
                    response, finalLocation);
            Writer writer = new OutputStreamWriter(response.getOutputStream(),
                    encoding);

            response.setContentType(contentType);

            t.merge(context, writer);

            // always flush the writer (we used to only flush it if this was a
            // jspWriter, but someone asked
            // to do it all the time (WW-829). Since Velocity support is being
            // deprecated, we'll oblige :)
            writer.flush();
        } catch (Exception e) {
            log.error("Unable to render Velocity Template, '" + finalLocation
                    + "'", e);
            throw e;
        } finally {
            if (usedJspFactory) {
                jspFactory.releasePageContext(pageContext);
            }
        }

        return;
    }

    /**
     * Retrieve the content type for this template. <p/>People can override
     * this method if they want to provide specific content types for specific
     * templates (eg text/xml).
     * 
     * @return The content type associated with this template (default
     *         "text/html")
     */
    protected String getContentType(String templateLocation) {
        return "text/html";
    }

    /**
     * Retrieve the encoding for this template. <p/>People can override this
     * method if they want to provide specific encodings for specific templates.
     * 
     * @return The encoding associated with this template (defaults to the value
     *         of 'struts.i18n.encoding' property)
     */
    protected String getEncoding(String templateLocation) {
        String encoding = (String) Settings
                .get(StrutsConstants.STRUTS_I18N_ENCODING);
        if (encoding == null) {
            encoding = System.getProperty("file.encoding");
        }
        if (encoding == null) {
            encoding = "UTF-8";
        }
        return encoding;
    }

    /**
     * Given a value stack, a Velocity engine, and an action invocation, this
     * method returns the appropriate Velocity template to render.
     * 
     * @param stack the value stack to resolve the location again (when parse
     *        equals true)
     * @param velocity the velocity engine to process the request against
     * @param invocation an encapsulation of the action execution state.
     * @param location the location of the template
     * @param encoding the charset encoding of the template
     * @return the template to render
     * @throws Exception when the requested template could not be found
     */
    protected Template getTemplate(OgnlValueStack stack,
            VelocityEngine velocity, ActionInvocation invocation,
            String location, String encoding) throws Exception {
        if (!location.startsWith("/")) {
            location = invocation.getProxy().getNamespace() + "/" + location;
        }

        Template template = velocity.getTemplate(location, encoding);

        return template;
    }

    /**
     * Creates the VelocityContext that we'll use to render this page.
     * 
     * @param velocityManager a reference to the velocityManager to use
     * @param stack the value stack to resolve the location against (when parse
     *        equals true)
     * @param location the name of the template that is being used
     * @return the a minted Velocity context.
     */
    protected Context createContext(VelocityManager velocityManager,
            OgnlValueStack stack, HttpServletRequest request,
            HttpServletResponse response, String location) {
        return velocityManager.createContext(stack, request, response);
    }

    /**
     *  Prepares the servlet action context for this request
     */
    private void prepareServletActionContext() throws PortletException,
            IOException {
        PortletRequestDispatcher disp = PortletActionContext.getPortletConfig()
                .getPortletContext().getNamedDispatcher("preparator");
        disp.include(PortletActionContext.getRenderRequest(),
                PortletActionContext.getRenderResponse());
    }
}
"
core/src/main/java/org/apache/struts2/portlet/util/PortletUrlHelper.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.portlet.util;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.StringTokenizer;

import javax.portlet.PortletMode;
import javax.portlet.PortletSecurityException;
import javax.portlet.PortletURL;
import javax.portlet.RenderRequest;
import javax.portlet.RenderResponse;
import javax.portlet.WindowState;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.StrutsException;
import org.apache.struts2.portlet.PortletActionConstants;
import org.apache.struts2.portlet.context.PortletActionContext;

/**
 * Helper class for creating Portlet URLs. Portlet URLs are fundamentally different from regular
 * servlet URLs since they never target the application itself; all requests go through the portlet
 * container and must therefore be programatically constructed using the 
 * {@link javax.portlet.RenderResponse#createActionURL()} and 
 * {@link javax.portlet.RenderResponse#createRenderURL()} APIs.
 * 
 */
public class PortletUrlHelper {
    public static final String ENCODING = "UTF-8";
    
    private static final Log LOG = LogFactory.getLog(PortletUrlHelper.class);

    /**
     * Create a portlet URL with for the specified action and namespace.
     * 
     * @param action The action the URL should invoke.
     * @param namespace The namespace of the action to invoke.
     * @param params The parameters of the URL.
     * @param type The type of the url, either <tt>action</tt> or <tt>render</tt>
     * @param mode The PortletMode of the URL.
     * @param state The WindowState of the URL.
     * @return The URL String.
     */
    public static String buildUrl(String action, String namespace, Map params,
            String type, String mode, String state) {
        return buildUrl(action, namespace, params, null, type, mode, state,
                true, true);
    }

    /**
     * Create a portlet URL with for the specified action and namespace. 
     * 
     * @see #buildUrl(String, String, Map, String, String, String)
     */
    public static String buildUrl(String action, String namespace, Map params,
            String scheme, String type, String portletMode, String windowState,
            boolean includeContext, boolean encodeResult) {
        RenderRequest request = PortletActionContext.getRenderRequest();
        RenderResponse response = PortletActionContext.getRenderResponse();
        LOG.debug("Creating url. Action = " + action + ", Namespace = "
                + namespace + ", Type = " + type);
        namespace = prependNamespace(namespace, portletMode);
        if(StringUtils.isEmpty(portletMode)) {
            portletMode = PortletActionContext.getRenderRequest().getPortletMode().toString();
        }
        String result = null;
        int paramStartIndex = action.indexOf('?');
        if (paramStartIndex > 0) {
            String value = action;
            action = value.substring(0, value.indexOf('?'));
            String queryStr = value.substring(paramStartIndex + 1);
            StringTokenizer tok = new StringTokenizer(queryStr, "&");
            while (tok.hasMoreTokens()) {
                String paramVal = tok.nextToken();
                String key = paramVal.substring(0, paramVal.indexOf('='));
                String val = paramVal.substring(paramVal.indexOf('=') + 1);
                params.put(key, new String[] { val });
            }
        }
        if (StringUtils.isNotEmpty(namespace)) {
            StringBuffer sb = new StringBuffer();
            sb.append(namespace);
            if(!action.startsWith("/") && !namespace.endsWith("/")) {
                sb.append("/");
            }
            action = sb.append(action).toString();
            LOG.debug("Resulting actionPath: " + action);
        }
        params.put(PortletActionConstants.ACTION_PARAM, new String[] { action });

        PortletURL url = null;
        if ("action".equalsIgnoreCase(type)) {
            LOG.debug("Creating action url");
            url = response.createActionURL();
        } else {
            LOG.debug("Creating render url");
            url = response.createRenderURL();
        }

        params.put(PortletActionConstants.MODE_PARAM, portletMode);
        url.setParameters(ensureParamsAreStringArrays(params));

        if ("HTTPS".equalsIgnoreCase(scheme)) {
            try {
                url.setSecure(true);
            } catch (PortletSecurityException e) {
                LOG.error("Cannot set scheme to https", e);
            }
        }
        try {
            url.setPortletMode(getPortletMode(request, portletMode));
            url.setWindowState(getWindowState(request, windowState));
        } catch (Exception e) {
            LOG.error("Unable to set mode or state:" + e.getMessage(), e);
        }
        result = url.toString();
        // TEMP BUG-WORKAROUND FOR DOUBLE ESCAPING OF AMPERSAND
        if(result.indexOf("&amp;") >= 0) {
            result = StringUtils.replace(result, "&amp;", "&");
        }
        return result;

    }

    /**
     * 
     * Prepend the namespace configuration for the specified namespace and PortletMode.
     * 
     * @param namespace The base namespace.
     * @param portletMode The PortletMode.
     * 
     * @return prepended namespace.
     */
    private static String prependNamespace(String namespace, String portletMode) {
        StringBuffer sb = new StringBuffer();
        PortletMode mode = PortletActionContext.getRenderRequest().getPortletMode();
        if(StringUtils.isNotEmpty(portletMode)) {
            mode = new PortletMode(portletMode);
        }
        String portletNamespace = PortletActionContext.getPortletNamespace();
        String modeNamespace = (String)PortletActionContext.getModeNamespaceMap().get(mode);
        LOG.debug("PortletNamespace: " + portletNamespace + ", modeNamespace: " + modeNamespace);
        if(StringUtils.isNotEmpty(portletNamespace)) {
            sb.append(portletNamespace);
        }
        if(StringUtils.isNotEmpty(modeNamespace)) {
            if(!modeNamespace.startsWith("/")) {
                sb.append("/");
            }
            sb.append(modeNamespace);
        }
        if(StringUtils.isNotEmpty(namespace)) {
            if(!namespace.startsWith("/")) {
                sb.append("/");
            }
            sb.append(namespace);
        }
        LOG.debug("Resulting namespace: " + sb);
        return sb.toString();
    }

    /**
     * Encode an url to a non Struts action resource, like stylesheet, image or
     * servlet.
     * 
     * @param value
     * @return encoded url to non Struts action resources.
     */
    public static String buildResourceUrl(String value, Map params) {
        StringBuffer sb = new StringBuffer();
        // Relative URLs are not allowed in a portlet
        if (!value.startsWith("/")) {
            sb.append("/");
        }
        sb.append(value);
        if(params != null && params.size() > 0) {
            sb.append("?");
            Iterator it = params.keySet().iterator();
            try {
            while(it.hasNext()) {
                String key = (String)it.next();
                String val = (String)params.get(key);
                
                sb.append(URLEncoder.encode(key, ENCODING)).append("=");
                sb.append(URLEncoder.encode(val, ENCODING));
                if(it.hasNext()) {
                    sb.append("&");
                }
            }
            } catch (UnsupportedEncodingException e) {
                throw new StrutsException("Encoding "+ENCODING+" not found");
            }
        }
        RenderResponse resp = PortletActionContext.getRenderResponse();
        RenderRequest req = PortletActionContext.getRenderRequest();
        return resp.encodeURL(req.getContextPath() + sb.toString());
    }

    /**
     * Will ensure that all entries in <code>params</code> are String arrays,
     * as requried by the setParameters on the PortletURL.
     * 
     * @param params The parameters to the URL.
     * @return A Map with all parameters as String arrays.
     */
    public static Map ensureParamsAreStringArrays(Map params) {
        Map result = null;
        if (params != null) {
            result = new HashMap(params.size());
            Iterator it = params.keySet().iterator();
            while (it.hasNext()) {
                Object key = it.next();
                Object val = params.get(key);
                if (val instanceof String[]) {
                    result.put(key, val);
                } else {
                    result.put(key, new String[] { val.toString() });
                }
            }
        }
        return result;
    }

    /**
     * Convert the given String to a WindowState object.
     * 
     * @param portletReq The RenderRequest.
     * @param windowState The WindowState as a String.
     * @return The WindowState that mathces the <tt>windowState</tt> String, or if
     * the Sring is blank, the current WindowState.
     */
    private static WindowState getWindowState(RenderRequest portletReq,
            String windowState) {
        WindowState state = portletReq.getWindowState();
        if (StringUtils.isNotEmpty(windowState)) {
            state = portletReq.getWindowState();
            if ("maximized".equalsIgnoreCase(windowState)) {
                state = WindowState.MAXIMIZED;
            } else if ("normal".equalsIgnoreCase(windowState)) {
                state = WindowState.NORMAL;
            } else if ("minimized".equalsIgnoreCase(windowState)) {
                state = WindowState.MINIMIZED;
            }
        }
        if(state == null) {
            state = WindowState.NORMAL;
        }
        return state;
    }

    /**
     * Convert the given String to a PortletMode object.
     * 
     * @param portletReq The RenderRequest.
     * @param portletMode The PortletMode as a String.
     * @return The PortletMode that mathces the <tt>portletMode</tt> String, or if
     * the Sring is blank, the current PortletMode.
     */
    private static PortletMode getPortletMode(RenderRequest portletReq,
            String portletMode) {
        PortletMode mode = portletReq.getPortletMode();

        if (StringUtils.isNotEmpty(portletMode)) {
            mode = portletReq.getPortletMode();
            if ("edit".equalsIgnoreCase(portletMode)) {
                mode = PortletMode.EDIT;
            } else if ("view".equalsIgnoreCase(portletMode)) {
                mode = PortletMode.VIEW;
            } else if ("help".equalsIgnoreCase(portletMode)) {
                mode = PortletMode.HELP;
            }
        }
        if(mode == null) {
            mode = PortletMode.VIEW;
        }
        return mode;
    }
}
"
core/src/main/java/org/apache/struts2/quickstart/Configuration.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.quickstart;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.apache.commons.collections.MultiHashMap;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import com.thoughtworks.xstream.XStream;

/**
 * Configuration for the QuickStart program.
 */
public class Configuration implements Serializable {

	private static final long serialVersionUID = 9159115401614443449L;

	String ideaConfig;
    String extendsConfig;
    String resolver;
    Integer port;
    String context;
    List libs;
    List classDirs;
    List sources;
    List webDirs;
    Map mappings;
    List pathPriority;

    public String getIdeaConfig() {
        return ideaConfig;
    }

    public void setIdeaConfig(String ideaConfig) {
        this.ideaConfig = ideaConfig;
    }

    public String getExtendsConfig() {
        return extendsConfig;
    }

    public void setExtendsConfig(String extendsConfig) {
        this.extendsConfig = extendsConfig;
    }

    public String getResolver() {
        return resolver;
    }

    public void setResolver(String resolver) {
        this.resolver = resolver;
    }

    public List getLibs() {
        return libs;
    }

    public void setLibs(List libs) {
        this.libs = libs;
    }

    public List getClassDirs() {
        return classDirs;
    }

    public void setClassDirs(List classDirs) {
        this.classDirs = classDirs;
    }

    public List getSources() {
        return sources;
    }

    public void setSources(List sources) {
        this.sources = sources;
    }

    public Map getMappings() {
        return mappings;
    }

    public List getPathPriority() {
        return pathPriority;
    }

    public List getWebDirs() {
        return webDirs;
    }

    public void setWebDirs(List webDirs) {
        this.webDirs = webDirs;
    }

    public Integer getPort() {
        return port;
    }

    public void setPort(Integer port) {
        this.port = port;
    }

    public String getContext() {
        return context;
    }

    public void setContext(String context) {
        this.context = context;
    }

    public void resolveDirs(String wd) {
        if (ideaConfig != null) {
            String[] paths = ideaConfig.split(",");
            for (String path : paths) {
                String full = resolveDir(path, wd);

                try {
                    DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();
                    Document doc = db.parse(full);
                    NodeList components = doc.getElementsByTagName("root");
                    List jars = new ArrayList();
                    for (int i = 0; i < components.getLength(); i++) {
                        Element e = (Element) components.item(i);
                        String value = e.getAttribute("url");
                        if (value != null && value.startsWith("jar://") && value.endsWith(".jar!/")) {
                            value = value.substring(6, value.length() - 2);
                            if (value.startsWith("$MODULE_DIR$")) {
                                value = value.substring(13);
                            }
                            jars.add(value);
                        }
                    }

                    if (this.libs != null) {
                        this.libs.addAll(jars);
                    } else {
                        this.libs = jars;
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
        resolve(this.libs, wd);
        resolve(this.classDirs, wd);
        resolve(this.sources, wd);

        // now resolve the web dirs
        for (Iterator iterator = webDirs.iterator(); iterator.hasNext();) {
            Mapping mapping = (Mapping) iterator.next();
            String path = mapping.getPath();
            String dir = mapping.getDir();
            dir = resolveDir(dir, wd);

            // if the ${dir}/WEB-INF/classes dir exists and isn't already added to the classDirs, let's do it
            // ... but make sure we put it at the front (to obey the class loading behaviors)
            File classDir = new File(dir, "WEB-INF/classes");
            if (classDir.exists()) {
                String fullClassDir = getFullPath(classDir);
                if (this.classDirs == null) {
                    this.classDirs = new ArrayList();
                }

                if (!classDirs.contains(fullClassDir)) {
                    classDirs.add(0, fullClassDir);
                }
            }

            if (this.mappings == null) {
                this.mappings = new MultiHashMap();
                this.pathPriority = new ArrayList();
            }

            if (!this.pathPriority.contains(path)) {
                this.pathPriority.add(path);
            }
            this.mappings.put(path, dir);
        }
    }

    private void resolve(List list, String wd) {
        if (list != null) {
            for (int i = 0; i < list.size(); i++) {
                String s = (String) list.get(i);
                list.set(i, resolveDir(s, wd));
            }
        }
    }

    private String resolveDir(String dir, String wd) {
        File file = new File(wd, dir);
        if (!file.exists() && new File(dir).exists()) {
            file = new File(dir);
        }

        return getFullPath(file);
    }

    private String getFullPath(File file) {
        try {
            return file.getCanonicalPath();
        } catch (IOException e) {
            return file.getAbsolutePath();
        }
    }

    public void resolveExtensions(String wd, XStream xstream) throws FileNotFoundException {
        if (extendsConfig != null) {
            File config = new File(wd, extendsConfig);
            Configuration c = (Configuration) xstream.fromXML(new FileReader(config));
            c.resolveDirs(config.getParent());
            c.resolveExtensions(config.getParent(), xstream);

            // now copy over the props
            if (c.getResolver() != null) {
                this.resolver = c.getResolver();
            }

            if (port == null) {
                this.port = c.getPort();
            }

            if (c.getContext() != null) {
                this.context = c.getContext();
            }

            if (c.getLibs() != null) {
                if (this.libs != null) {
                    this.libs.addAll(c.getLibs());
                } else {
                    this.libs = c.getLibs();
                }
            }

            if (c.getClassDirs() != null) {
                if (this.classDirs != null) {
                    this.classDirs.addAll(c.getClassDirs());
                } else {
                    this.classDirs = c.getClassDirs();
                }
            }

            if (c.getSources() != null) {
                if (this.sources != null) {
                    this.sources.addAll(c.getSources());
                } else {
                    this.sources = c.getSources();
                }
            }

            for (Iterator iterator = c.getMappings().entrySet().iterator(); iterator.hasNext();) {
                Map.Entry entry = (Map.Entry) iterator.next();
                List list = (List) this.mappings.get(entry.getKey());
                if (list != null) {
                    list.addAll((List) entry.getValue());
                } else {
                    this.mappings.put(entry.getKey(), (List) entry.getValue());
                }
            }

            // add only new paths
            for (Iterator iterator = c.getPathPriority().iterator(); iterator.hasNext();) {
                String path = (String) iterator.next();
                if (!this.pathPriority.contains(path)) {
                    this.pathPriority.add(path);
                }
            }
        }
    }

    public boolean validate() {
        boolean error = false;

        if (port == null) {
            System.out.println("Port must be greater than 0");
            error = true;
        }

        if (!context.startsWith("/")) {
            System.out.println("Context must start with /");
            error = true;
        }


        if (verifyList("Library", libs, false)) {
            error = true;
        }

        if (verifyList("ClassDir", classDirs, false)) {
            error = true;
        }

        if (verifyList("Sources", sources, true)) {
            error = true;
        }

        if (verifyMap("WebApp", mappings)) {
            error = true;
        }

        return error;
    }

    private boolean verifyMap(String name, Map map) {
        boolean error = false;
        if (map == null || map.size() == 0) {
            System.out.println(name + " must be specified");
            return true;
        }

        for (Iterator iterator = map.entrySet().iterator(); iterator.hasNext();) {
            Map.Entry entry = (Map.Entry) iterator.next();
            List list = (List) entry.getValue();
            verifyList(name, list, false);
        }

        return error;
    }

    private boolean verifyList(String name, List list, boolean allowEmpty) {
        boolean error = false;
        if (!allowEmpty) {
            if (list == null || list.size() == 0) {
                System.out.println(name + " must be specified");
                return true;
            }
        }

        if (list != null) {
            for (Iterator iterator = list.iterator(); iterator.hasNext();) {
                String s = (String) iterator.next();
                if (!new File(s).exists()) {
                    System.out.println(name + " doesn't exist: " + s);
                    error = true;
                }
            }
        }

        return error;
    }
}
"
core/src/main/java/org/apache/struts2/quickstart/JettyServer.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.quickstart;

import java.io.File;
import java.util.List;
import java.util.Map;

import org.mortbay.http.SocketListener;
import org.mortbay.jetty.Server;
import org.mortbay.jetty.servlet.WebApplicationContext;

/**
 * To start a Jetty server used by the QuickStart application.
 */
public class JettyServer {
    /**
     * The system property name used to specify a directory of webapps.
     */
    public static final String WEBAPPS_DIR_PROPERTY = "webapps.dir";

    public static void startServer(int port, String context, List pathPriority, Map paths, String resolver) throws Exception {
        try {
            Server server = new Server();
            SocketListener socketListener = new SocketListener();
            socketListener.setPort(port);
            server.addListener(socketListener);

            WebApplicationContext ctx;
            if (resolver == null) {
                ctx = new MultiWebApplicationContext(pathPriority, paths);
            } else {
                ctx = new MultiWebApplicationContext(pathPriority, paths, resolver);
            }
            ctx.setClassLoader(Thread.currentThread().getContextClassLoader());
            ctx.setContextPath(context);
            server.addContext(null, ctx);

            // Add in extra webapps dir (see WW-1387)
            String webappsDir = System.getProperty(WEBAPPS_DIR_PROPERTY);
            if (webappsDir != null && new File(webappsDir).exists()) {
                server.addWebApplications(webappsDir);
            }

            server.start();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
"
core/src/main/java/org/apache/struts2/quickstart/Mapping.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.quickstart;

/**
 * Used for mapping configuration for the QuickStart application.
 *
 */
public class Mapping {
    String path;
    String dir;

    public Mapping(String path, String dir) {
        this.path = path;
        this.dir = dir;
    }

    public Mapping() {
    }

    public String getPath() {
        return path;
    }

    public void setPath(String path) {
        this.path = path;
    }

    public String getDir() {
        return dir;
    }

    public void setDir(String dir) {
        this.dir = dir;
    }
}
"
core/src/main/java/org/apache/struts2/quickstart/MultiDirClassLoader.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.quickstart;

import java.io.File;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;

/**
 * Integration with Jetty.
 *
 */
public class MultiDirClassLoader extends URLClassLoader {
    private ClassLoader parent;

    public MultiDirClassLoader(String[] dirs, String[] cps, ClassLoader parent) throws MalformedURLException {
        super(getAllURLs(dirs, cps), parent);
        this.parent = parent;
    }

    public Class loadClass(String name) throws ClassNotFoundException {
        Class aClass;

        try {
            aClass = parent.loadClass(name);
            if (aClass != null) {
                return aClass;
            }
        } catch (ClassNotFoundException e) {
            // ok, keep trying
        }

        return super.loadClass(name);
    }

    public URL getResource(String name) {
        URL url = findResource(name);
        if (url == null && parent != null) {
            url = parent.getResource(name);
        }

        return url;
    }


    private static URL[] getAllURLs(String[] dirs, String[] cps) throws MalformedURLException {
        ArrayList urls = new ArrayList();

        for (int i = 0; i < cps.length; i++) {
            String cp = cps[i];
            urls.add(new File(cp).toURL());
        }

        for (int i = 0; i < dirs.length; i++) {
            String dir = dirs[i];
            File file = new File(dir);
            findJars(file, urls);
        }

        return (URL[]) urls.toArray(new URL[urls.size()]);
    }

    private static void findJars(File file, ArrayList fileList) throws MalformedURLException {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; i++) {
                File f = files[i];
                findJars(f, fileList);
            }
        }
        else if (file.getName().endsWith(".jar")) {
            // Manually exclude the local license file so that it's possible to run
            // clustering.
            if (!file.getName().equals("tangosol-license-local.jar")) {
                fileList.add(file.toURL());
            }
        }
    }
}
"
core/src/main/java/org/apache/struts2/quickstart/MultiDirResource.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.quickstart;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.mortbay.util.Resource;

/**
 */
public class MultiDirResource extends Resource {
	
	private static final long serialVersionUID = -7571068340424106599L;
	
	MultiWebApplicationContext ctx;
    File[] files;
    String uri;

    public MultiDirResource(MultiWebApplicationContext ctx, String uri, List pathPriority, Map paths) {
        this.ctx = ctx;
        this.uri = uri;
        ArrayList files = new ArrayList();
        for (Iterator iterator = pathPriority.iterator(); iterator.hasNext();) {
            String path = (String) iterator.next();
            List dirs = (List) paths.get(path);

            if (uri.startsWith(path) || (uri.equals("") && path.equals("/"))) {
                for (Iterator iterator1 = dirs.iterator(); iterator1.hasNext();) {
                    String s = (String) iterator1.next();

                    if (uri.startsWith(path)) {
                        // cut off the path from the start of the URI
                        files.add(new File(s, uri.substring(path.length())));
                    } else {
                        files.add(new File(s, uri));
                    }
                }
            }
        }

        this.files = (File[]) files.toArray(new File[files.size()]);
    }

    public void release() {
    }

    public boolean exists() {
        for (int i = 0; i < files.length; i++) {
            File file = files[i];
            if (file.exists()) {
                return true;
            }
        }

        return false;
    }

    public boolean isDirectory() {
        for (int i = 0; i < files.length; i++) {
            File file = files[i];
            if (file.exists()) {
                return file.isDirectory();
            }
        }

        return false;
    }

    public long lastModified() {
        for (int i = 0; i < files.length; i++) {
            File file = files[i];
            if (file.exists()) {
                return file.lastModified();
            }
        }

        return 0;
    }

    public long length() {
        for (int i = 0; i < files.length; i++) {
            File file = files[i];
            if (file.exists()) {
                return file.length();
            }
        }

        return 0;
    }

    public URL getURL() {
        for (int i = 0; i < files.length; i++) {
            File file = files[i];
            if (file.exists()) {
                try {
                    return file.toURL();
                } catch (MalformedURLException e) {
                    e.printStackTrace();
                }
            }
        }

        return null;
    }

    public File getFile() throws IOException {
        for (int i = 0; i < files.length; i++) {
            File file = files[i];
            if (file.exists()) {
                return file;
            }
        }

        return null;
    }

    public String getName() {
        for (int i = 0; i < files.length; i++) {
            File file = files[i];
            if (file.exists()) {
                return file.getName();
            }
        }

        return null;
    }

    public InputStream getInputStream() throws IOException {
        for (int i = 0; i < files.length; i++) {
            File file = files[i];
            if (file.exists()) {
                return new FileInputStream(file);
            }
        }

        return null;
    }

    public OutputStream getOutputStream() throws IOException, SecurityException {
        for (int i = 0; i < files.length; i++) {
            File file = files[i];
            if (file.exists()) {
                return new FileOutputStream(file);
            }
        }

        return null;
    }

    public boolean delete() throws SecurityException {
        for (int i = 0; i < files.length; i++) {
            File file = files[i];
            if (file.exists()) {
                return file.delete();
            }
        }

        return false;
    }

    public boolean renameTo(Resource resource) throws SecurityException {
        return false;
    }

    public String[] list() {
        HashSet set = new HashSet();
        for (int i = 0; i < files.length; i++) {
            File file = files[i];
            if (file.exists()) {
                String[] files = file.list();
                for (int j = 0; j < files.length; j++) {
                    String s = files[j];
                    set.add(s);
                }
            }
        }

        return (String[]) set.toArray(new String[set.size()]);
    }

    public Resource addPath(String string) throws IOException, MalformedURLException {
        return ctx.newResolver(uri + string);
    }
}
"
core/src/main/java/org/apache/struts2/quickstart/MultiWebApplicationContext.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.quickstart;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.List;
import java.util.Map;

import org.mortbay.jetty.servlet.WebApplicationContext;
import org.mortbay.util.FileResource;
import org.mortbay.util.JarResource;
import org.mortbay.util.Resource;

/**
 */
public class MultiWebApplicationContext extends WebApplicationContext {

	private static final long serialVersionUID = -4732081314967099271L;

	private List pathPriority;
    private Map paths;
    private Class resolver;

    public MultiWebApplicationContext() {
    }

    public MultiWebApplicationContext(List pathPriority, Map paths) {
        super(getFirstRoot(paths));
        this.pathPriority = pathPriority;
        this.paths = paths;
    }

    public MultiWebApplicationContext(List pathPriority, Map paths, String resolver) {
        super(getFirstRoot(paths));
        this.pathPriority = pathPriority;
        this.paths = paths;
        try {
            this.resolver = loadClass(resolver, getClass());
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

    private static String getFirstRoot(Map paths) {
        return (String) ((List) paths.get("/")).get(0);
    }

    public Resource getResource(String uriInContext) throws IOException {
        if (uriInContext.startsWith("/WEB-INF/lib/")) {
            String jar = uriInContext.substring("/WEB-INF/lib/".length());
            ClassLoader parent = Thread.currentThread().getContextClassLoader();
            while (parent != null) {
                if (parent instanceof URLClassLoader) {
                    URL[] urls = ((URLClassLoader) parent).getURLs();
                    for (int i = 0; i < urls.length; i++) {
                        URL url = urls[i];
                        if (url.toExternalForm().endsWith(jar)) {
                            return JarResource.newResource(url);
                        }
                    }
                }

                parent = parent.getParent();
            }
        }

        // still haven't found what we're looking for?
        // Alright, let's just hack this to work in IDEA
        if (uriInContext.equals("/tags")) {
            // we do this check to support both "quickstart:showcase" and "quickstart" (using quickstart.xml)
            if (new File("../../core/src/main/resources/META-INF/tags.tld").exists()) {
                return FileResource.newResource("../../core/src/main/resources/META-INF/tags.tld");
            } else {
                return FileResource.newResource("src/main/resources/META-INF/tags.tld");
            }
        }

        MultiDirResource resource = newResolver(uriInContext);
        if (resource.exists()) {
            return resource;
        }

        String aliasedUri= getResourceAlias(uriInContext);
        if (aliasedUri != null) {
            return super.getResource(aliasedUri);
        }

        return resource;
    }

    public MultiDirResource newResolver(String uriInContext) {
        if (resolver == null) {
            return new MultiDirResource(this, uriInContext, pathPriority, paths);
        } else {
            try {
                Constructor c = resolver.getDeclaredConstructor(new Class[]{
                        MultiWebApplicationContext.class,
                        String.class,
                        List.class,
                        Map.class,
                });
                return (MultiDirResource) c.newInstance(new Object[] {
                        this,
                        uriInContext,
                        pathPriority,
                        paths,
                });
            } catch (Exception e) {
                e.printStackTrace();
                return null;
            }
        }
    }

    public Resource getBaseResource() {
        return newResolver("");
    }

    public static Class loadClass(String className, Class callingClass)
            throws ClassNotFoundException {
        try {
            return Thread.currentThread().getContextClassLoader().loadClass(className);
        }
        catch (ClassNotFoundException e) {
            try {
                return Class.forName(className);
            }
            catch (ClassNotFoundException ex) {
                try {
                    return MultiWebApplicationContext.class.getClassLoader().loadClass(className);
                }
                catch (ClassNotFoundException exc) {
                    return callingClass.getClassLoader().loadClass(className);
                }

            }
        }
    }
}
"
core/src/main/java/org/apache/struts2/quickstart/QuickStart.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.quickstart;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.io.xml.DomDriver;

/**
 * The QuickStart main program.
 *
 */
public class QuickStart {
    public static void main(String[] args) throws FileNotFoundException, MalformedURLException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {
        if (args.length != 3 && args.length != 0) {
            System.err.println("QuickStart must be either invoked with three arguments or no arguments:");
            System.err.println("[contextPath] [webapp] [sources]");
            System.err.println("");
            System.err.println("Ex: java -jar struts.jar \\");
            System.err.println("    quickstart /sandbox sandbox/src/webapp sandbox/src/java");
            System.err.println("");
            System.err.println("OR");
            System.err.println("");
            System.err.println("Ex: java -jar struts.jar quickstart");
            System.err.println(" Where a 'quickstart.xml' file exists in your working directory");
            return;
        }

        Configuration c;
        if (args.length == 0) {
            XStream xstream = new XStream(new DomDriver());
            xstream.alias("configuration", Configuration.class);
            xstream.alias("extendsConfig", String.class);
            xstream.alias("port", int.class);
            xstream.alias("context", String.class);
            xstream.alias("dir", String.class);
            xstream.alias("path", String.class);
            xstream.alias("webDir", Mapping.class);
            File config = new File("quickstart.xml");
            if (!config.exists()) {
                // uh oh, time to stop
                System.err.println("Could not find quickstart.xml!");
                System.err.println("Tip: quickstart.xml must exist in your working directory");
                System.err.println("");
                System.err.println("Alternatively, if you your deployment is simple, try launching");
                System.err.println("QuickStart using the simple command line options rather than");
                System.err.println("Relying on quickstart.xml existing");
                return;
            }

            c = (Configuration) xstream.fromXML(new FileReader(config));
            c.resolveDirs(config.getParent());
            c.resolveExtensions(config.getParent(), xstream);
        } else {
            c = new Configuration();
            c.setContext(args[0]);
            c.setPort(new Integer(8080));
            ArrayList webDirs = new ArrayList();
            webDirs.add(new Mapping("/", args[1]));
            c.setWebDirs(webDirs);
            ArrayList sources = new ArrayList();
            sources.add(args[2]);
            c.setSources(sources);
            ArrayList classDirs = new ArrayList();
            classDirs.add(args[1] + "/WEB-INF/classes");
            classDirs.add(args[2]);
            c.setClassDirs(classDirs);
            ArrayList libs = new ArrayList();
            libs.add("lib");
            c.setLibs(libs);

            c.resolveDirs(new File(".").getParent());
        }

        // validate the configuration
        if (c.validate()) {
            return;
        }

        // explain what is being executed
        System.out.println("Launching Jetty with the following configuration:");
        System.out.println("Jars/Directory of jars:");
        for (Iterator iterator = c.getLibs().iterator(); iterator.hasNext();) {
            String s = (String) iterator.next();
            System.out.println("    " + s);
        }
        System.out.println("Directories of classes:");
        for (Iterator iterator = c.getClassDirs().iterator(); iterator.hasNext();) {
            String s = (String) iterator.next();
            System.out.println("    " + s);
        }
        if (c.getSources() != null) {
            System.out.println("Sources:");
            for (Iterator iterator = c.getSources().iterator(); iterator.hasNext();) {
                String s = (String) iterator.next();
                System.out.println("    " + s);
            }
        }
        System.out.println("WebApp directories:");
        for (Iterator iterator = c.getMappings().entrySet().iterator(); iterator.hasNext();) {
            Map.Entry entry = (Map.Entry) iterator.next();
            System.out.println(entry.getKey() + "  ->  " + entry.getValue());
        }

        // prepare the classloader
        List libs = c.getLibs();
        List classDirs = c.getClassDirs();
        ClassLoader parent = new MultiDirClassLoader((String[]) libs.toArray(new String[libs.size()]),
                (String[]) classDirs.toArray(new String[classDirs.size()]),
                Thread.currentThread().getContextClassLoader());

        if (c.getSources() != null) {
            System.out.print("Automatic compiling of classes no longer supported.");
        }
        URLClassLoader url = new MyURLClassLoader(parent);
        Thread.currentThread().setContextClassLoader(url);

        Class clazz = url.loadClass("org.apache.struts2.quickstart.JettyServer");
        Method method = clazz.getDeclaredMethod("startServer",
                new Class[]{int.class, String.class, List.class, Map.class, String.class});
        method.invoke(null, new Object[]{c.port, c.getContext(), c.getPathPriority(), c.getMappings(), c.getResolver()});

        System.out.println("");
        System.out.println("********************************************************");
        System.out.println("Quick-started at http://localhost:" + c.getPort() + c.getContext());
        System.out.println("You may now edit your Java classes and web files without");
        System.out.println(" deploying or restarting.");
        System.out.println("********************************************************");
    }

    static class MyURLClassLoader extends URLClassLoader {
        private ClassLoader parent;

        public MyURLClassLoader(ClassLoader parent) {
            super(new URL[0], parent);
            this.parent = parent;
        }

        public Class loadClass(String name, boolean resolve) throws ClassNotFoundException {
            if (name.startsWith("org.xml.") || name.startsWith("org.w3c.")
                    || name.startsWith("java.") || name.startsWith("javax.")
                    || name.startsWith("sun.") || name.startsWith("com.sun.")) {
                return super.loadClass(name, resolve);
            }

            ClassLoader parent = getParent();
            // First, check if the class has already been loaded
            Class c = findLoadedClass(name);
            if (c == null) {
                try {
                    c = findClass(name);
                } catch (Throwable t) {
                    // If still not found, only then ask the parent
                    c = parent.loadClass(name);
                }
            }
            if (resolve) {
                resolveClass(c);
            }

            return c;
        }

        public URL getResource(String name) {
            URL url = findResource(name);
            if (url == null && parent != null) {
                url = parent.getResource(name);
            }

            return url;
        }
    }
}
"
core/src/main/java/org/apache/struts2/sitegraph/SiteGraph.java,false,"/*
 * Created on Aug 12, 2004 by mgreer
 */
package org.apache.struts2.sitegraph;

import java.io.ByteArrayOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.Writer;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.StrutsException;
import org.apache.struts2.sitegraph.renderers.DOTRenderer;

/**
 * // START SNIPPET: javadocs-intro
 * SiteGraph is a tool that renders out GraphViz-generated images depicting your
 * Struts-powered web application's flow. SiteGraph requires GraphViz be installed
 * and that the "dot" executable be in your command path. You can find GraphViz
 * at http://www.graphviz.org.
 * // END SNIPPET: javadocs-intro
 * <p/>
 * // START SNIPPET: javadocs-api
 * If you wish to use SiteGraph through its API rather than through the command line,
 * you can do that as well. All you need to do is create a new SiteGraph instance,
 * optionally specify a {@link Writer} to output the dot content to, and then call
 * {@link #prepare()}.
 * // END SNIPPET: javadocs-api
 */
public class SiteGraph {

    private static final Log LOG = LogFactory.getLog(SiteGraph.class);

    private String configDir;
    private String views;
    private String output;
    private String namespace;
    private Writer writer;

    public SiteGraph(String configDir, String views, String output, String namespace) {
        this.configDir = configDir;
        this.views = views;
        this.output = output;
        this.namespace = namespace;
    }

    public static void main(String[] args) throws IOException {
        LOG.info("SiteGraph starting...");

        if (args.length != 8 && args.length != 6) {
            InputStream is = SiteGraph.class.getResourceAsStream("sitegraph-usage.txt");
            byte[] buffer = new byte[2048];
            int length = -1;
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            while ((length = is.read(buffer)) != -1) {
                baos.write(buffer, 0, length);
            }
            is.close();
            baos.close();

            String usage = baos.toString();
            System.out.println(usage.replaceAll("//.*", ""));
            return;
        }

        String configDir = getArg(args, "config");
        String views = getArg(args, "views");
        String output = getArg(args, "output");
        String namespace = getArg(args, "ns");

        // START SNIPPET: example-api
        SiteGraph siteGraph = new SiteGraph(configDir, views, output, namespace);
        siteGraph.prepare();
        siteGraph.render();
        // END SNIPPET: example-api
    }

    private static String getArg(String[] args, String arg) {
        for (int i = 0; i < args.length; i++) {
            if (("-" + arg).equals(args[i]) && ((i + 1) < args.length)) {
                return args[i + 1];
            }
        }

        return "";
    }

    /**
     * Prepares the dot generated content and writes out to the provided writer
     * object. If no writer has been given, that a {@link FileWriter} pointing to "out.dot"
     * in the specified output directly shall be used.
     */
    public void prepare() {
        if (writer == null) {
            try {
                writer = new FileWriter(output + "/out.dot");
            } catch (IOException e) {
                throw new StrutsException(e);
            }
        }

        StrutsConfigRetriever.setConfiguration(configDir, views.split("[, ]+"));
        DOTRenderer renderer = new DOTRenderer(writer);
        renderer.render(namespace);
    }

    /**
     * Invokes the dot command, cause GraphViz to render out.dot in the form of out.gif,
     * located in the specified output directory. If an error occurs during this process,
     * the error is logged and the method completes without throwing an exception.
     */
    public void render() {
        try {
            Runtime.getRuntime().exec("dot -o" + output + "/out.gif -Tgif " + output + "/out.dot");
        } catch (IOException e) {
            LOG.error("Could not invoke dot", e);
        }
    }

    public void setWriter(Writer writer) {
        this.writer = writer;
    }
}
"
core/src/main/java/org/apache/struts2/sitegraph/StrutsConfigRetriever.java,false,"/*
 * Created on Aug 14, 2004 by mgreer
 */
package org.apache.struts2.sitegraph;

import java.io.File;
import java.io.IOException;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.config.StrutsXMLConfigurationProvider;
import org.apache.struts2.sitegraph.entities.FreeMarkerView;
import org.apache.struts2.sitegraph.entities.JspView;
import org.apache.struts2.sitegraph.entities.VelocityView;
import org.apache.struts2.sitegraph.entities.View;

import com.opensymphony.xwork2.config.ConfigurationManager;
import com.opensymphony.xwork2.config.ConfigurationProvider;
import com.opensymphony.xwork2.config.entities.ActionConfig;
import com.opensymphony.xwork2.config.entities.ResultConfig;

/**
 * Initializes and retrieves XWork config elements
 */
public class StrutsConfigRetriever {

    private static final Log LOG = LogFactory.getLog(StrutsConfigRetriever.class);
    private static String configDir;
    private static String[] views;
    private static boolean isXWorkStarted = false;
    private static Map viewCache = new LinkedHashMap();
    private static ConfigurationManager cm;

    /**
     * Returns a Map of all action names/configs
     *
     * @return Map of all action names/configs
     */
    public static Map getActionConfigs() {
        if (!isXWorkStarted)
            initXWork();
        return cm.getConfiguration().getRuntimeConfiguration().getActionConfigs();
    }

    private static void initXWork() {
        String configFilePath = configDir + "/struts.xml";
        File configFile = new File(configFilePath);
        try {
            ConfigurationProvider configProvider = new StrutsXMLConfigurationProvider(configFile.getCanonicalPath(), true);
            cm = new ConfigurationManager();
            cm.addConfigurationProvider(configProvider);
            isXWorkStarted = true;
        } catch (IOException e) {
            LOG.error("IOException", e);
        }
    }

    public static Set getNamespaces() {
        Set namespaces = Collections.EMPTY_SET;
        Map allActionConfigs = getActionConfigs();
        if (allActionConfigs != null) {
            namespaces = allActionConfigs.keySet();
        }
        return namespaces;
    }

    /**
     * Return a Set of the action names for this namespace.
     *
     * @param namespace
     * @return Set of the action names for this namespace.
     */
    public static Set getActionNames(String namespace) {
        Set actionNames = Collections.EMPTY_SET;
        Map allActionConfigs = getActionConfigs();
        if (allActionConfigs != null) {
            Map actionMappings = (Map) allActionConfigs.get(namespace);
            if (actionMappings != null) {
                actionNames = actionMappings.keySet();
            }
        }
        return actionNames;
    }

    /**
     * Returns the ActionConfig for this action name at this namespace.
     *
     * @param namespace
     * @param actionName
     * @return The ActionConfig for this action name at this namespace.
     */
    public static ActionConfig getActionConfig(String namespace, String actionName) {
        ActionConfig config = null;
        Map allActionConfigs = getActionConfigs();
        if (allActionConfigs != null) {
            Map actionMappings = (Map) allActionConfigs.get(namespace);
            if (actionMappings != null) {
                config = (ActionConfig) actionMappings.get(actionName);
            }
        }
        return config;
    }

    public static ResultConfig getResultConfig(String namespace, String actionName,
                                               String resultName) {
        ResultConfig result = null;
        ActionConfig actionConfig = getActionConfig(namespace, actionName);
        if (actionConfig != null) {
            Map resultMap = actionConfig.getResults();
            result = (ResultConfig) resultMap.get(resultName);
        }
        return result;
    }

    public static File getViewFile(String namespace, String actionName, String resultName) {
        ResultConfig result = getResultConfig(namespace, actionName, resultName);
        String location = (String) result.getParams().get("location");
        for (int i = 0; i < views.length; i++) {
            String viewRoot = views[i];
            File viewFile = getViewFileInternal(viewRoot, location, namespace);
            if (viewFile != null) {
                return viewFile;
            }
        }

        return null;
    }

    private static File getViewFileInternal(String root, String location, String namespace) {
        StringBuffer filePath = new StringBuffer(root);
        if (!location.startsWith("/")) {
            filePath.append(namespace + "/");
        }
        filePath.append(location);
        File viewFile = new File(filePath.toString());
        if (viewFile.exists()) {
            return viewFile;
        } else {
            return null;
        }
    }

    public static View getView(String namespace, String actionName, String resultName, int type) {
        String viewId = namespace + "/" + actionName + "/" + resultName;
        View view = (View) viewCache.get(viewId);
        if (view == null) {
            File viewFile = StrutsConfigRetriever.getViewFile(namespace, actionName, resultName);
            if (viewFile != null) {
                switch (type) {
                    case View.TYPE_JSP:
                        view = new JspView(viewFile);
                        break;
                    case View.TYPE_FTL:
                        view = new FreeMarkerView(viewFile);
                        break;
                    case View.TYPE_VM:
                        view = new VelocityView(viewFile);
                        break;
                    default:
                        return null;
                }

                viewCache.put(viewId, view);
            }
        }
        return view;
    }

    public static void setConfiguration(String configDir, String[] views) {
        StrutsConfigRetriever.configDir = configDir;
        StrutsConfigRetriever.views = views;
        isXWorkStarted = false;
        viewCache = new LinkedHashMap();
    }
}
"
core/src/main/java/org/apache/struts2/sitegraph/entities/FileBasedView.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.sitegraph.entities;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Set;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.StrutsConstants;
import org.apache.struts2.config.Settings;
import org.apache.struts2.sitegraph.model.Link;

/**
 */
public abstract class FileBasedView implements View {
    private String name;
    private String contents;
    
    private static final Log log = LogFactory.getLog(FileBasedView.class);

    public FileBasedView(File file) {
        this.name = file.getName();
        // get the contents as a single line
        this.contents = readFile(file).replaceAll("[\r\n ]+", " ");
    }

    public String getName() {
        return name;
    }

    public Set getTargets() {
        TreeSet targets = new TreeSet();

        // links
        matchPatterns(getLinkPattern(), targets, Link.TYPE_HREF);

        // actions
        matchPatterns(getActionPattern(), targets, Link.TYPE_ACTION);

        // forms
        matchPatterns(getFormPattern(), targets, Link.TYPE_FORM);

        return targets;
    }

    protected Pattern getLinkPattern() {
        Object ext = Settings.get(StrutsConstants.STRUTS_ACTION_EXTENSION);
        String actionRegex = "([A-Za-z0-9\\._\\-\\!]+\\." + ext + ")";
        return Pattern.compile(actionRegex);
    }

    private void matchPatterns(Pattern pattern, Set targets, int type) {
        Matcher matcher = pattern.matcher(contents);
        while (matcher.find()) {
            String target = matcher.group(1);
            targets.add(new Target(target, type));
        }
    }

    protected abstract Pattern getActionPattern();

    protected abstract Pattern getFormPattern();
    
    protected String readFile(File file) {
        try {
            BufferedReader in = new BufferedReader(new FileReader(file));

            String s = new String();
            StringBuffer buffer = new StringBuffer();

            while ((s = in.readLine()) != null) {
                buffer.append(s + "\n");
            }

            in.close();

            return buffer.toString();
        } catch (FileNotFoundException e) {
            log.warn("File not found");
        } catch (IOException e) {
            log.error(e);
        }

        return null;
    }
}
"
core/src/main/java/org/apache/struts2/sitegraph/entities/FreeMarkerView.java,false,"package org.apache.struts2.sitegraph.entities;

import java.io.File;
import java.util.regex.Pattern;

/**
 */
public class FreeMarkerView extends FileBasedView {
    public FreeMarkerView(File file) {
        super(file);
    }

    protected Pattern getActionPattern() {
        return Pattern.compile("<\\@s.action [^>]*name=\"([^\"]+)\"[^>]*>");
    }

    protected Pattern getFormPattern() {
        return Pattern.compile("<\\@s.form [^>]*action=\"([^\"]+)\"[^>]*>");
    }
}
"
core/src/main/java/org/apache/struts2/sitegraph/entities/JspView.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.sitegraph.entities;

import java.io.File;
import java.util.regex.Pattern;

/**
 */
public class JspView extends FileBasedView {
    public JspView(File file) {
        super(file);
    }

    protected Pattern getActionPattern() {
        return Pattern.compile("<a:action [^>]*name=\"([^\"]+)\"[^>]*>");
    }

    protected Pattern getFormPattern() {
        return Pattern.compile("<a:form [^>]*action=\"([^\"]+)\"[^>]*>");
    }
}
"
core/src/main/java/org/apache/struts2/sitegraph/entities/Target.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.sitegraph.entities;


/**
 */
public class Target {
    private String target;
    private int type;

    public Target(String target, int type) {
        this.target = target;
        this.type = type;
    }

    public String getTarget() {
        return target;
    }

    public int getType() {
        return type;
    }

    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Target)) return false;

        final Target target1 = (Target) o;

        if (type != target1.type) return false;
        if (target != null ? !target.equals(target1.target) : target1.target != null) return false;

        return true;
    }

    public int hashCode() {
        int result;
        result = (target != null ? target.hashCode() : 0);
        result = 29 * result + type;
        return result;
    }
}
"
core/src/main/java/org/apache/struts2/sitegraph/entities/VelocityView.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.sitegraph.entities;

import java.io.File;
import java.util.regex.Pattern;

/**
 */
public class VelocityView extends FileBasedView {
    public VelocityView(File file) {
        super(file);
    }

    protected Pattern getActionPattern() {
        return Pattern.compile("#tag( Action [^)]*name=\"([^\"]+)\"[^)]*)");
    }

    protected Pattern getFormPattern() {
        return Pattern.compile("#tag \\(Form [^)]*action=\"([^\"]+)\"[^)]*\\)");
    }
}
"
core/src/main/java/org/apache/struts2/sitegraph/entities/View.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.sitegraph.entities;

import java.util.Set;

/**
 * TODO Describe View
 */
public interface View {
    public static final int TYPE_JSP = 0;
    public static final int TYPE_VM = 1;
    public static final int TYPE_FTL = 2;

    /**
     * Name of view file
     *
     * @return The name of the view file.
     */
    public String getName();

    /**
     * Returns Set of Commands linked to by this view
     *
     * @return a set of Targets
     */
    public Set getTargets();
}
"
core/src/main/java/org/apache/struts2/sitegraph/model/ActionNode.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.sitegraph.model;

/**
 */
public class ActionNode extends SiteGraphNode {
    public ActionNode(String name) {
        super(name);
    }

    public String getColor() {
        return "coral1";
    }
}
"
core/src/main/java/org/apache/struts2/sitegraph/model/Graph.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.sitegraph.model;

import java.io.IOException;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

/**
 */
public class Graph extends SubGraph {
    private Set links;
    public static Map nodeMap = new LinkedHashMap();

    public Graph() {
        super("");
        this.links = new TreeSet();
    }

    public void addLink(Link link) {
        links.add(link);
    }

    public void render(IndentWriter writer) throws IOException {
        // write out the header
        writer.write("digraph mygraph {", true);
        writer.write("fontsize=10;");
        writer.write("fontname=helvetica;");
        writer.write("node [fontsize=10, fontname=helvetica, style=filled, shape=rectangle]");
        writer.write("edge [fontsize=10, fontname=helvetica]");

        // render all the subgraphs
        for (Iterator iterator = subGraphs.iterator(); iterator.hasNext();) {
            SubGraph subGraph = (SubGraph) iterator.next();
            subGraph.render(new IndentWriter(writer));
        }

        // render all the nodes
        for (Iterator iterator = nodes.iterator(); iterator.hasNext();) {
            SiteGraphNode siteGraphNode = (SiteGraphNode) iterator.next();
            siteGraphNode.render(writer);
        }

        // finally, render the links
        for (Iterator iterator = links.iterator(); iterator.hasNext();) {
            Link link = (Link) iterator.next();
            link.render(writer);
        }

        // and now the footer
        writer.write("}", true);
    }

    public SiteGraphNode findNode(String location, SiteGraphNode ref) {
        if (location.startsWith("/")) {
            location = location.substring(1);
        } else {
            // not absolute, so use the reference node
            String prefix = null;
            if (ref.getParent() != null) {
                prefix = ref.getParent().getPrefix();
                location = prefix + "_" + location;
            }
        }

        location = location.replaceAll("[\\.\\/\\-\\$\\{\\}]", "_");

        return (SiteGraphNode) nodeMap.get(location);
    }
}
"
core/src/main/java/org/apache/struts2/sitegraph/model/IndentWriter.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.sitegraph.model;

import java.io.IOException;
import java.io.Writer;

/**
 */
public class IndentWriter extends Writer {
    Writer writer;

    public IndentWriter(Writer writer) {
        this.writer = writer;
    }

    public void close() throws IOException {
        writer.close();
    }

    public void flush() throws IOException {
        writer.flush();
    }

    public void write(String str) throws IOException {
        write(str, false);
    }

    public void write(String str, boolean noIndent) throws IOException {
        if (!noIndent) {
            str = "    " + str;
        }

        if (writer instanceof IndentWriter) {
            ((IndentWriter) writer).write(str, false);
        } else {
            writer.write(str + "\n");
        }
    }

    public void write(char cbuf[], int off, int len) throws IOException {
        writer.write(cbuf, off, len);
    }
}
"
core/src/main/java/org/apache/struts2/sitegraph/model/Link.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.sitegraph.model;

import java.io.IOException;

/**
 */
public class Link implements Render, Comparable {
    public static final int TYPE_FORM = 0;
    public static final int TYPE_ACTION = 1;
    public static final int TYPE_HREF = 2;
    public static final int TYPE_RESULT = 3;
    public static final int TYPE_REDIRECT = 4;

    private SiteGraphNode from;
    private SiteGraphNode to;
    private int type;
    private String label;

    public Link(SiteGraphNode from, SiteGraphNode to, int type, String label) {
        this.from = from;
        this.to = to;
        this.type = type;
        this.label = label;
    }

    public void render(IndentWriter writer) throws IOException {
        writer.write(from.getFullName() + " -> " + to.getFullName() + " [label=\"" + getRealLabel() + "\"" + getColor() + "];");
    }

    private String getRealLabel() {
        switch (type) {
            case TYPE_ACTION:
                return "action" + label;
            case TYPE_FORM:
                return "form" + label;
            case TYPE_HREF:
                return "href" + label;
            case TYPE_REDIRECT:
                return "redirect: " + label;
            case TYPE_RESULT:
                return label;
        }

        return "";
    }

    private String getColor() {
        if (type == TYPE_RESULT || type == TYPE_ACTION) {
            return ",color=\"darkseagreen2\"";
        } else {
            return "";
        }
    }

    public int compareTo(Object o) {
        Link other = (Link) o;
        int result = from.compareTo(other.from);
        if (result != 0) {
            return result;
        }

        result = to.compareTo(other.to);
        if (result != 0) {
            return result;
        }

        result = label.compareTo(other.label);
        if (result != 0) {
            return result;
        }

        return new Integer(type).compareTo(new Integer(other.type));
    }
}
"
core/src/main/java/org/apache/struts2/sitegraph/model/Render.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.sitegraph.model;

import java.io.IOException;

/**
 */
public interface Render {
    public void render(IndentWriter writer) throws IOException;
}
"
core/src/main/java/org/apache/struts2/sitegraph/model/SiteGraphNode.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.sitegraph.model;

import java.io.IOException;

/**
 */
public abstract class SiteGraphNode implements Render, Comparable {
    private String name;
    private SubGraph parent;

    public SiteGraphNode(String name) {
        this.name = name;
    }

    public SubGraph getParent() {
        return parent;
    }

    public void setParent(SubGraph parent) {
        this.parent = parent;
    }

    public void render(IndentWriter writer) throws IOException {
        writer.write(getFullName() + " [label=\"" + name + "\",color=\"" + getColor() + "\"];");
    }

    public String getFullName() {
        String prefix = "";
        if (parent != null) {
            String parentPrefix = parent.getPrefix();
            if (!parentPrefix.equals("")) {
                prefix = parentPrefix + "_";
            }
        }
        return prefix + cleanName();
    }

    private String cleanName() {
        return name.replaceAll("[\\.\\/\\-\\$\\{\\}]", "_");
    }

    public abstract String getColor();

    public int compareTo(Object o) {
        return name.compareTo(((SiteGraphNode) o).name);
    }
}
"
core/src/main/java/org/apache/struts2/sitegraph/model/SubGraph.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.sitegraph.model;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 */
public class SubGraph implements Render {
    protected String name;
    protected SubGraph parent;
    protected List subGraphs;
    protected List nodes;

    public SubGraph(String name) {
        this.name = name;
        this.subGraphs = new ArrayList();
        this.nodes = new ArrayList();
    }

    public String getName() {
        return name;
    }

    public void addSubGraph(SubGraph subGraph) {
        subGraph.setParent(this);
        subGraphs.add(subGraph);
    }

    public void setParent(SubGraph parent) {
        this.parent = parent;
    }

    public void addNode(SiteGraphNode node) {
        node.setParent(this);
        Graph.nodeMap.put(node.getFullName(), node);
        nodes.add(node);
    }

    public void render(IndentWriter writer) throws IOException {
        // write the header
        writer.write("subgraph cluster_" + getPrefix() + " {", true);
        writer.write("color=grey;");
        writer.write("fontcolor=grey;");
        writer.write("label=\"" + name + "\";");

        // write out the subgraphs
        for (Iterator iterator = subGraphs.iterator(); iterator.hasNext();) {
            SubGraph subGraph = (SubGraph) iterator.next();
            subGraph.render(new IndentWriter(writer));
        }

        // write out the actions
        for (Iterator iterator = nodes.iterator(); iterator.hasNext();) {
            SiteGraphNode siteGraphNode = (SiteGraphNode) iterator.next();
            siteGraphNode.render(writer);
        }

        // .. footer
        writer.write("}", true);
    }

    public String getPrefix() {
        if (parent == null) {
            return name;
        } else {
            String prefix = parent.getPrefix();
            if (prefix.equals("")) {
                return name;
            } else {
                return prefix + "_" + name;
            }
        }
    }

    public SubGraph create(String namespace) {
        if (namespace.equals("")) {
            return this;
        }

        String[] parts = namespace.split("\\/");
        SubGraph last = this;
        for (int i = 0; i < parts.length; i++) {
            String part = parts[i];
            if (part.equals("")) {
                continue;
            }

            SubGraph subGraph = findSubGraph(part);
            if (subGraph == null) {
                subGraph = new SubGraph(part);
                last.addSubGraph(subGraph);
            }

            last = subGraph;
        }

        return last;
    }

    private SubGraph findSubGraph(String name) {
        for (Iterator iterator = subGraphs.iterator(); iterator.hasNext();) {
            SubGraph subGraph = (SubGraph) iterator.next();
            if (subGraph.getName().equals(name)) {
                return subGraph;
            }
        }

        return null;
    }
}
"
core/src/main/java/org/apache/struts2/sitegraph/model/ViewNode.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.sitegraph.model;

/**
 */
public class ViewNode extends SiteGraphNode {
    public ViewNode(String name) {
        super(name);
    }

    public String getColor() {
        return "darkseagreen2";
    }
}
"
core/src/main/java/org/apache/struts2/sitegraph/renderers/DOTRenderer.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.sitegraph.renderers;

import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

import org.apache.struts2.StrutsConstants;
import org.apache.struts2.config.Settings;
import org.apache.struts2.sitegraph.StrutsConfigRetriever;
import org.apache.struts2.sitegraph.entities.Target;
import org.apache.struts2.sitegraph.entities.View;
import org.apache.struts2.sitegraph.model.ActionNode;
import org.apache.struts2.sitegraph.model.Graph;
import org.apache.struts2.sitegraph.model.IndentWriter;
import org.apache.struts2.sitegraph.model.Link;
import org.apache.struts2.sitegraph.model.SiteGraphNode;
import org.apache.struts2.sitegraph.model.SubGraph;
import org.apache.struts2.sitegraph.model.ViewNode;

import com.opensymphony.xwork2.ActionChainResult;
import com.opensymphony.xwork2.config.entities.ActionConfig;
import com.opensymphony.xwork2.config.entities.ResultConfig;

/**
 * Renders flow diagram to the console at info level
 */
public class DOTRenderer {

    private Writer writer;
    private List links = new ArrayList();

    public DOTRenderer(Writer writer) {
        this.writer = writer;
    }

    public void render(String ns) {
        Graph graph = new Graph();

        TreeMap viewMap = new TreeMap(new Comparator() {
            public int compare(Object o1, Object o2) {
                ViewNode v1 = (ViewNode) o1;
                ViewNode v2 = (ViewNode) o2;

                return v1.getFullName().compareTo(v2.getFullName());
            }
        });

        Set namespaces = StrutsConfigRetriever.getNamespaces();
        for (Iterator iter = namespaces.iterator(); iter.hasNext();) {
            String namespace = (String) iter.next();

            if (!namespace.startsWith(ns)) {
                continue;
            }

            SubGraph subGraph = graph.create(namespace);

            Set actionNames = StrutsConfigRetriever.getActionNames(namespace);
            for (Iterator iterator = actionNames.iterator(); iterator.hasNext();) {
                String actionName = (String) iterator.next();
                ActionConfig actionConfig = StrutsConfigRetriever.getActionConfig(namespace,
                        actionName);

                ActionNode action = new ActionNode(actionName);
                subGraph.addNode(action);

                Set resultNames = actionConfig.getResults().keySet();
                for (Iterator iterator2 = resultNames.iterator(); iterator2.hasNext();) {
                    String resultName = (String) iterator2.next();
                    ResultConfig resultConfig = ((ResultConfig) actionConfig.getResults().get(resultName));
                    String resultClassName = resultConfig.getClassName();

                    if (resultClassName.equals(ActionChainResult.class.getName())) {

                    } else if (resultClassName.indexOf("Dispatcher") != -1
                            || resultClassName.indexOf("Velocity") != -1
                            || resultClassName.indexOf("Freemarker") != -1) {
                        if (resultConfig.getParams().get("location") == null) {
                            continue;
                        }

                        String location = getViewLocation((String) resultConfig.getParams().get("location"), namespace);
                        if (location.endsWith((String) Settings.get(StrutsConstants.STRUTS_ACTION_EXTENSION))) {
                            addTempLink(action, location, Link.TYPE_RESULT, resultConfig.getName());
                        } else {
                            ViewNode view = new ViewNode(stripLocation(location));
                            subGraph.addNode(view);

                            addTempLink(action, location, Link.TYPE_RESULT, resultConfig.getName());

                            View viewFile = getView(namespace, actionName, resultName, location);
                            if (viewFile != null) {
                                viewMap.put(view, viewFile);
                            }
                        }
                    } else if (resultClassName.indexOf("Jasper") != -1) {

                    } else if (resultClassName.indexOf("XSLT") != -1) {

                    } else if (resultClassName.indexOf("Redirect") != -1) {
                        // check if the redirect is to an action -- if so, link it
                        String location = getViewLocation((String) resultConfig.getParams().get("location"), namespace);
                        if (location.endsWith((String) Settings.get(StrutsConstants.STRUTS_ACTION_EXTENSION))) {
                            addTempLink(action, location, Link.TYPE_REDIRECT, resultConfig.getName());
                        } else {
                            ViewNode view = new ViewNode(stripLocation(location));
                            subGraph.addNode(view);

                            addTempLink(action, location, Link.TYPE_REDIRECT, resultConfig.getName());

                            View viewFile = getView(namespace, actionName, resultName, location);
                            if (viewFile != null) {
                                viewMap.put(view, viewFile);
                            }
                        }
                    }
                }
            }
        }

        // now look for links in the view
        for (Iterator iterator = viewMap.entrySet().iterator(); iterator.hasNext();) {
            Map.Entry entry = (Map.Entry) iterator.next();
            ViewNode view = (ViewNode) entry.getKey();
            View viewFile = (View) entry.getValue();
            Set targets = viewFile.getTargets();
            for (Iterator iterator1 = targets.iterator(); iterator1.hasNext();) {
                Target target = (Target) iterator1.next();
                String viewTarget = target.getTarget();
                addTempLink(view, viewTarget, target.getType(), "");
            }
        }

        // finally, let's match up these links as real Link objects
        for (Iterator iterator = links.iterator(); iterator.hasNext();) {
            TempLink temp = (TempLink) iterator.next();
            String location = temp.location;
            if (location.endsWith((String) Settings.get(StrutsConstants.STRUTS_ACTION_EXTENSION))) {
                location = location.substring(0, location.indexOf((String) Settings.get(StrutsConstants.STRUTS_ACTION_EXTENSION)) - 1);

                if (location.indexOf('!') != -1) {
                    temp.label = temp.label + "\\n(" + location.substring(location.indexOf('!')) + ")";
                    location = location.substring(0, location.indexOf('!'));
                }
            }
            SiteGraphNode to = graph.findNode(location, temp.node);
            if (to != null) {
                graph.addLink(new Link(temp.node, to, temp.typeResult, temp.label));
            }
        }

        try {
            //writer.write(graph.to_s(true));
            graph.render(new IndentWriter(writer));
            writer.flush();
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void addTempLink(SiteGraphNode node, String location, int type, String label) {
        links.add(new TempLink(node, location, type, label));
    }

    private String stripLocation(String location) {
        return location.substring(location.lastIndexOf('/') + 1);
    }

    private View getView(String namespace, String actionName, String resultName, String location) {
        int type = View.TYPE_JSP;
        if (location.endsWith(".fm") || location.endsWith(".ftl")) {
            type = View.TYPE_FTL;
        } else if (location.endsWith(".vm")) {
            type = View.TYPE_VM;
        }
        return StrutsConfigRetriever.getView(namespace, actionName, resultName, type);
    }

    private String getViewLocation(String location, String namespace) {
        String view = null;
        if (!location.startsWith("/")) {
            view = namespace + "/" + location;
        } else {
            view = location;
        }

        if (view.indexOf('?') != -1) {
            view = view.substring(0, view.indexOf('?'));
        }

        return view;
    }

    class TempLink {
        SiteGraphNode node;
        String location;
        int typeResult;
        String label;

        public TempLink(SiteGraphNode node, String location, int typeResult, String label) {
            this.node = node;
            this.location = location;
            this.typeResult = typeResult;
            this.label = label;
        }

        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof TempLink)) return false;

            final TempLink tempLink = (TempLink) o;

            if (typeResult != tempLink.typeResult) return false;
            if (label != null ? !label.equals(tempLink.label) : tempLink.label != null) return false;
            if (location != null ? !location.equals(tempLink.location) : tempLink.location != null) return false;
            if (node != null ? !node.equals(tempLink.node) : tempLink.node != null) return false;

            return true;
        }

        public int hashCode() {
            int result;
            result = (node != null ? node.hashCode() : 0);
            result = 29 * result + (location != null ? location.hashCode() : 0);
            result = 29 * result + typeResult;
            result = 29 * result + (label != null ? label.hashCode() : 0);
            return result;
        }
    }
}
"
core/src/main/java/org/apache/struts2/sitemesh/FreeMarkerPageFilter.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.sitemesh;

import java.io.IOException;
import java.util.Locale;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.views.freemarker.FreemarkerManager;

import com.opensymphony.module.sitemesh.Decorator;
import com.opensymphony.module.sitemesh.HTMLPage;
import com.opensymphony.module.sitemesh.Page;
import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.LocaleProvider;

import freemarker.template.Configuration;
import freemarker.template.SimpleHash;
import freemarker.template.Template;

/**
 *  Applies FreeMarker-based sitemesh decorators.
 *  
 *  <!-- START SNIPPET: javadoc -->
 *  
 *  The following variables are available to the decorating freemarker page :-
 *  <ul>
 *      <li>${title}           - content of &lt;title&gt; tag in the decorated page</li>
 *      <li>${head}            - content of &lt;head&gt; tag in the decorated page</li>
 *      <li>${body}            - content of t&lt;body&gt; tag in the decorated page</li>
 *      <li>${page.properties} - content of the page properties</li>
 *  </ul>
 *  <p/>
 *  With the following decorated page :-
 *  <pre>
 *  &lt;html&gt;
 *      &lt;meta name="author" content="tm_jee" /&gt;
 *      &lt;head&gt;
 *          &lt;title&gt;My Title&lt;/title&gt;
 *          &lt;link rel="stylesheet" type="text/css" href="mycss.css" /&gt;
 *          &lt;style type="text/javascript" language="javascript" src="myjavascript.js"&gt;&lt;/script&gt;
 *      &lt;/head&gt;
 *      &lt;body&lt;
 *          &lt;h1&gt;Sample&lt;/h1&gt;
 *      &lt;/body&gt;
 *  &lt;/html&gt;
 *  </pre>
 *  <p/>
 *  <table border="1">
 *      <tr>
 *          <td>Properties</td>
 *          <td>Content</td>
 *      </tr>
 *      <tr>
 *          <td>${title}</td>
 *          <td>My Title</td>
 *      </tr>
 *      <tr>
 *          <td>${head}</td>
 *          <td>
 *              &lt;link rel="stylesheet" type="text/css" href="mycss.css" /&gt;
 *              &lt;style type="text/javascript" language="javascript" src="myjavascript.js"&gt;&lt;/script&gt;
 *          </td>
 *      </tr>
 *      <tr>
 *          <td>${body}</td>
 *          <td>
 *              &lt;h1&gt;Sample&lt;/h1&gt;
 *          </td>
 *      </tr>
 *      <tr>
 *          <td>${page.properties.meta.author}</td>
 *          <td>tm_jee</td>
 *      </tr>
 *  </table>
 *  
 *  <!-- END SNIPPET: javadoc -->
 *  
 *  @version $Date$ $Id$
 */
public class FreeMarkerPageFilter extends TemplatePageFilter {
    private static final Log LOG = LogFactory.getLog(FreeMarkerPageFilter.class);

    /**
     *  Applies the decorator, using the relevent contexts
     * 
     * @param page The page
     * @param decorator The decorator
     * @param req The servlet request
     * @param res The servlet response
     * @param servletContext The servlet context
     * @param ctx The action context for this request, populated with the server state
     */
    protected void applyDecorator(Page page, Decorator decorator,
                                  HttpServletRequest req, HttpServletResponse res,
                                  ServletContext servletContext, ActionContext ctx)
            throws ServletException, IOException {
        try {
            FreemarkerManager fmm = FreemarkerManager.getInstance();

            // get the configuration and template
            Configuration config = fmm.getConfiguration(servletContext);
            Template template = config.getTemplate(decorator.getPage(), getLocale(ctx.getActionInvocation(), config)); // WW-1181

            // get the main hash
            SimpleHash model = fmm.buildTemplateModel(ctx.getValueStack(), null, servletContext, req, res, config.getObjectWrapper());

            // populate the hash with the page
            model.put("page", page);
            if (page instanceof HTMLPage) {
                HTMLPage htmlPage = ((HTMLPage) page);
                model.put("head", htmlPage.getHead());
            }
            model.put("title",page.getTitle());
            model.put("body",page.getBody());
            model.put("page.properties", new SimpleHash(page.getProperties()));

            // finally, render it
            template.process(model, res.getWriter());
        } catch (Exception e) {
            String msg = "Error applying decorator: " + e.getMessage();
            LOG.error(msg, e);
            throw new ServletException(msg, e);
        }
    }
    
    /**
     * Returns the locale used for the {@link Configuration#getTemplate(String, Locale)} call. The base implementation
     * simply returns the locale setting of the action (assuming the action implements {@link LocaleProvider}) or, if
     * the action does not the configuration's locale is returned. Override this method to provide different behaviour,
     */
    protected Locale getLocale(ActionInvocation invocation, Configuration configuration) {
        if (invocation.getAction() instanceof LocaleProvider) {
            return ((LocaleProvider) invocation.getAction()).getLocale();
        } else {
            return configuration.getLocale();
        }
    }
 
}
"
core/src/main/java/org/apache/struts2/sitemesh/TemplatePageFilter.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.sitemesh;

import java.io.IOException;

import javax.servlet.FilterConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.ServletActionContext;
import org.apache.struts2.StrutsConstants;
import org.apache.struts2.config.Settings;
import org.apache.struts2.dispatcher.Dispatcher;

import com.opensymphony.module.sitemesh.Decorator;
import com.opensymphony.module.sitemesh.Page;
import com.opensymphony.module.sitemesh.filter.PageFilter;
import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.ActionProxy;
import com.opensymphony.xwork2.ActionSupport;
import com.opensymphony.xwork2.Result;
import com.opensymphony.xwork2.interceptor.PreResultListener;
import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 *  An abstract template page filter that sets up the proper contexts for
 *  template processing.
 * 
 */
public abstract class TemplatePageFilter extends PageFilter {
    
    private FilterConfig filterConfig;

    public void init(FilterConfig filterConfig) {
        super.init(filterConfig);
        this.filterConfig = filterConfig;
    }

    /**
     *  Applies the decorator, using the relevent contexts
     * 
     * @param page The page
     * @param decorator The decorator
     * @param req The servlet request
     * @param res The servlet response
     * @param servletContext The servlet context
     * @param ctx The action context for this request, populated with the server state
     */
    protected abstract void applyDecorator(Page page, Decorator decorator,
                                  HttpServletRequest req, HttpServletResponse res,
                                  ServletContext servletContext, ActionContext ctx)
            throws ServletException, IOException;
    
    /**
     *  Applies the decorator, creating the relevent contexts and delegating to
     *  the extended applyDecorator().
     * 
     * @param page The page
     * @param decorator The decorator
     * @param req The servlet request
     * @param res The servlet response
     */
    protected void applyDecorator(Page page, Decorator decorator,
                                  HttpServletRequest req, HttpServletResponse res)
            throws ServletException, IOException {
            
        ServletContext servletContext = filterConfig.getServletContext();
        ActionContext ctx = ServletActionContext.getActionContext(req);
        if (ctx == null) {
            // ok, one isn't associated with the request, so let's get a ThreadLocal one (which will create one if needed)
            OgnlValueStack vs = new OgnlValueStack();
            vs.getContext().putAll(Dispatcher.getInstance().createContextMap(req, res, null, servletContext));
            ctx = new ActionContext(vs.getContext());
            if (ctx.getActionInvocation() == null) {
                // put in a dummy ActionSupport so basic functionality still works
                ActionSupport action = new ActionSupport();
                vs.push(action);
                ctx.setActionInvocation(new DummyActionInvocation(action));
            }
        }

        // delegate to the actual page decorator
        applyDecorator(page, decorator, req, res, servletContext, ctx);
    }

    
    /**
     *  Gets the L18N encoding of the system.  The default is UTF-8.
     */
    protected String getEncoding() {
        String encoding = (String) Settings.get(StrutsConstants.STRUTS_I18N_ENCODING);
        if (encoding == null) {
            encoding = System.getProperty("file.encoding");
        }
        if (encoding == null) {
            encoding = "UTF-8";
        }
        return encoding;
    }

    static class DummyActionInvocation implements ActionInvocation {
    	
		private static final long serialVersionUID = -4808072199157363028L;
		
		ActionSupport action;

        public DummyActionInvocation(ActionSupport action) {
            this.action = action;
        }

        public Object getAction() {
            return action;
        }

        public boolean isExecuted() {
            return false;
        }

        public ActionContext getInvocationContext() {
            return null;
        }

        public ActionProxy getProxy() {
            return null;
        }

        public Result getResult() throws Exception {
            return null;
        }

        public String getResultCode() {
            return null;
        }

        public void setResultCode(String resultCode) {
        }

        public OgnlValueStack getStack() {
            return null;
        }

        public void addPreResultListener(PreResultListener listener) {
        }

        public String invoke() throws Exception {
            return null;
        }

        public String invokeActionOnly() throws Exception {
            return null;
        }
    }
}
"
core/src/main/java/org/apache/struts2/sitemesh/VelocityPageFilter.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.sitemesh;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.views.velocity.VelocityManager;
import org.apache.velocity.Template;
import org.apache.velocity.context.Context;

import com.opensymphony.module.sitemesh.Decorator;
import com.opensymphony.module.sitemesh.HTMLPage;
import com.opensymphony.module.sitemesh.Page;
import com.opensymphony.xwork2.ActionContext;


/**
 *  Applies Velocity-based decorators
 * 
 */
public class VelocityPageFilter extends TemplatePageFilter {
    private static final Log LOG = LogFactory.getLog(VelocityPageFilter.class);

    /**
     *  Applies the decorator, using the relevent contexts
     * 
     * @param page The page
     * @param decorator The decorator
     * @param req The servlet request
     * @param res The servlet response
     * @param servletContext The servlet context
     * @param ctx The action context for this request, populated with the server state
     */
    protected void applyDecorator(Page page, Decorator decorator,
                                  HttpServletRequest req, HttpServletResponse res,
                                  ServletContext servletContext, ActionContext ctx)
            throws ServletException, IOException {
        try {
            VelocityManager vm = VelocityManager.getInstance();

            // init (if needed)
            vm.init(servletContext);

            // get encoding
            String encoding = getEncoding();

            // get the template and context
            Template template = vm.getVelocityEngine().getTemplate(decorator.getPage(), encoding);
            Context context = vm.createContext(ctx.getValueStack(), req, res);

            // put the page in the context
            context.put("page", page);
            if (page instanceof HTMLPage) {
                HTMLPage htmlPage = ((HTMLPage) page);
                context.put("head", htmlPage.getHead());
            }
            context.put("title",page.getTitle());
            context.put("body",page.getBody());

            // finally, render it
            PrintWriter writer = res.getWriter();
            template.merge(context, writer);
            writer.flush();
        } catch (Exception e) {
            String msg = "Error applying decorator: " + e.getMessage();
            LOG.error(msg, e);
            throw new ServletException(msg, e);
        }
    }
}
"
core/src/main/java/org/apache/struts2/spring/StrutsSpringObjectFactory.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.spring;

import javax.servlet.ServletContext;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.StrutsConstants;
import org.apache.struts2.config.Settings;
import org.apache.struts2.util.ObjectFactoryInitializable;
import org.springframework.beans.factory.config.AutowireCapableBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.web.context.support.WebApplicationContextUtils;

import com.opensymphony.xwork2.spring.SpringObjectFactory;



/**
 * Struts object factory that integrates with Spring.
 * <p/>
 * Spring should be loaded using a web context listener
 * <code>org.springframework.web.context.ContextLoaderListener</code> defined in <code>web.xml</code>.
 *
 */
public class StrutsSpringObjectFactory extends SpringObjectFactory implements ObjectFactoryInitializable {
    private static final Log log = LogFactory.getLog(StrutsSpringObjectFactory.class);

    /* (non-Javadoc)
     * @see org.apache.struts2.util.ObjectFactoryInitializable#init(javax.servlet.ServletContext)
     */
    public void init(ServletContext servletContext) {
        log.info("Initializing Struts-Spring integration...");

        ApplicationContext appContext = WebApplicationContextUtils.getWebApplicationContext(servletContext);
        if (appContext == null) {
            // uh oh! looks like the lifecycle listener wasn't installed. Let's inform the user
            String message = "********** FATAL ERROR STARTING UP SPRING-STRUTS INTEGRATION **********\n" +
                    "Looks like the Spring listener was not configured for your web app! \n" +
                    "Nothing will work until WebApplicationContextUtils returns a valid ApplicationContext.\n" +
                    "You might need to add the following to web.xml: \n" +
                    "    <listener>\n" +
                    "        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n" +
                    "    </listener>";
            log.fatal(message);
            return;
        }

        this.setApplicationContext(appContext);

        String autoWire = Settings.get(StrutsConstants.STRUTS_OBJECTFACTORY_SPRING_AUTOWIRE);
        int type = AutowireCapableBeanFactory.AUTOWIRE_BY_NAME;   // default
        if ("name".equals(autoWire)) {
            type = AutowireCapableBeanFactory.AUTOWIRE_BY_NAME;
        } else if ("type".equals(autoWire)) {
            type = AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE;
        } else if ("auto".equals(autoWire)) {
            type = AutowireCapableBeanFactory.AUTOWIRE_AUTODETECT;
        } else if ("constructor".equals(autoWire)) {
            type = AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR;
        }
        this.setAutowireStrategy(type);

        boolean useClassCache = "true".equals(Settings.get(StrutsConstants.STRUTS_OBJECTFACTORY_SPRING_USE_CLASS_CACHE));
        this.setUseClassCache(useClassCache);

        log.info("... initialized Struts-Spring integration successfully");
    }
}
"
core/src/main/java/org/apache/struts2/spring/lifecycle/SpringExternalReferenceResolverSetupListener.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.spring.lifecycle;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import javax.servlet.ServletContext;
import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;

import org.apache.struts2.dispatcher.Dispatcher;
import org.apache.struts2.dispatcher.DispatcherListener;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.web.context.support.WebApplicationContextUtils;

import com.opensymphony.xwork2.config.Configuration;
import com.opensymphony.xwork2.config.ExternalReferenceResolver;
import com.opensymphony.xwork2.config.entities.PackageConfig;

/**
 * Setup any {@link com.opensymphony.xwork2.config.ExternalReferenceResolver}s
 * that implement the ApplicationContextAware interface from the Spring
 * framework. Relies on Spring's
 * {@link org.springframework.web.context.ContextLoaderListener}having been
 * called first.
 */
public class SpringExternalReferenceResolverSetupListener implements
        ServletContextListener {
    
    private Map<ServletContext,Listener> listeners = new HashMap<ServletContext,Listener>();
    
    /* (non-Javadoc)
     * @see javax.servlet.ServletContextListener#contextDestroyed(javax.servlet.ServletContextEvent)
     */
    public synchronized void contextDestroyed(ServletContextEvent event) {
        Listener l = listeners.get(event.getServletContext());
        Dispatcher.removeDispatcherListener(l);
        listeners.remove(event.getServletContext());
    }

    /* (non-Javadoc)
     * @see javax.servlet.ServletContextListener#contextInitialized(javax.servlet.ServletContextEvent)
     */
    public synchronized void contextInitialized(ServletContextEvent event) {
        Listener l = new Listener(event.getServletContext());
        Dispatcher.addDispatcherListener(l);
        listeners.put(event.getServletContext(), l);
    }
    
    /**
     * Handles initializing and cleaning up the dispatcher
     * @author brownd
     *
     */
    private class Listener implements DispatcherListener {

        private ServletContext servletContext;
        
        /**
         * Constructs the listener
         * 
         * @param ctx The servlet context
         */
        public Listener(ServletContext ctx) {
            this.servletContext = ctx;
        }
        
        /* (non-Javadoc)
         * @see org.apache.struts2.dispatcher.DispatcherListener#dispatcherInitialized(org.apache.struts2.dispatcher.Dispatcher)
         */
        public void dispatcherInitialized(Dispatcher du) {
            ApplicationContext appContext = WebApplicationContextUtils
            .getWebApplicationContext(servletContext);

            Configuration xworkConfig = du.getConfigurationManager().getConfiguration();
            Map packageConfigs = xworkConfig.getPackageConfigs();
            Iterator i = packageConfigs.values().iterator();
        
            while (i.hasNext()) {
                PackageConfig packageConfig = (PackageConfig) i.next();
                ExternalReferenceResolver resolver = packageConfig.getExternalRefResolver();
                if (resolver == null || !(resolver instanceof ApplicationContextAware))
                    continue;
                ApplicationContextAware contextAware = (ApplicationContextAware) resolver;
                contextAware.setApplicationContext(appContext);
            }
            
        }

        /* (non-Javadoc)
         * @see org.apache.struts2.dispatcher.DispatcherListener#dispatcherDestroyed(org.apache.struts2.dispatcher.Dispatcher)
         */
        public void dispatcherDestroyed(Dispatcher du) {
        }
    }
}
"
core/src/main/java/org/apache/struts2/util/AppendIteratorFilter.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import com.opensymphony.xwork2.Action;


/**
 * A bean that takes several iterators and outputs them in sequence
 *
 * @see org.apache.struts2.components.AppendIterator
 * @see org.apache.struts2.views.jsp.iterator.AppendIteratorTag
 */
public class AppendIteratorFilter extends IteratorFilterSupport implements Iterator, Action {

    List iterators = new ArrayList();

    // Attributes ----------------------------------------------------
    List sources = new ArrayList();


    // Public --------------------------------------------------------
    public void setSource(Object anIterator) {
        sources.add(anIterator);
    }

    // Action implementation -----------------------------------------
    public String execute() {
        // Make source transformations
        for (int i = 0; i < sources.size(); i++) {
            Object source = sources.get(i);
            iterators.add(getIterator(source));
        }

        return SUCCESS;
    }

    // Iterator implementation ---------------------------------------
    public boolean hasNext() {
        if (iterators.size() > 0) {
            return (((Iterator) iterators.get(0)).hasNext());
        } else {
            return false;
        }
    }

    public Object next() {
        try {
            return ((Iterator) iterators.get(0)).next();
        } finally {
            if (iterators.size() > 0) {
                if (!((Iterator) iterators.get(0)).hasNext()) {
                    iterators.remove(0);
                }
            }
        }
    }

    public void remove() {
        throw new UnsupportedOperationException();
    }
}
"
core/src/main/java/org/apache/struts2/util/AttributeMap.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

import java.util.Collection;
import java.util.Collections;
import java.util.Map;
import java.util.Set;

import javax.servlet.jsp.PageContext;

import org.apache.struts2.ServletActionContext;


/**
 * A Map that holds 4 levels of scope.
 * <p/>
 * The scopes are the ones known in the web world.:
 * <ul>
 *   <li>Page scope</li>
 *   <li>Request scope</li>
 *   <li>Session scope</li>
 *   <li>Application scope</li>
 * </ul>
 * A object is searched in the order above, starting from page and ending at application scope.
 *
 */
public class AttributeMap implements Map {

    protected static final String UNSUPPORTED = "method makes no sense for a simplified map";


    Map context;


    public AttributeMap(Map context) {
        this.context = context;
    }


    public boolean isEmpty() {
        throw new UnsupportedOperationException(UNSUPPORTED);
    }

    public void clear() {
        throw new UnsupportedOperationException(UNSUPPORTED);
    }

    public boolean containsKey(Object key) {
        return (get(key) != null);
    }

    public boolean containsValue(Object value) {
        throw new UnsupportedOperationException(UNSUPPORTED);
    }

    public Set entrySet() {
        return Collections.EMPTY_SET;
    }

    public Object get(Object key) {
        PageContext pc = getPageContext();

        if (pc == null) {
            Map request = (Map) context.get("request");
            Map session = (Map) context.get("session");
            Map application = (Map) context.get("application");

            if ((request != null) && (request.get(key) != null)) {
                return request.get(key);
            } else if ((session != null) && (session.get(key) != null)) {
                return session.get(key);
            } else if ((application != null) && (application.get(key) != null)) {
                return application.get(key);
            }
        } else {
            try{
                return pc.findAttribute(key.toString());
            }catch (NullPointerException npe){
                return null;
            }
        }

        return null;
    }

    public Set keySet() {
        return Collections.EMPTY_SET;
    }

    public Object put(Object key, Object value) {
        PageContext pc = getPageContext();
        if (pc != null) {
            pc.setAttribute(key.toString(), value);
        }

        return null;
    }

    public void putAll(Map t) {
        throw new UnsupportedOperationException(UNSUPPORTED);
    }

    public Object remove(Object key) {
        throw new UnsupportedOperationException(UNSUPPORTED);
    }

    public int size() {
        throw new UnsupportedOperationException(UNSUPPORTED);
    }

    public Collection values() {
        return Collections.EMPTY_SET;
    }

    private PageContext getPageContext() {
        return (PageContext) context.get(ServletActionContext.PAGE_CONTEXT);
    }
}
"
core/src/main/java/org/apache/struts2/util/ClassLoaderUtils.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

import java.io.IOException;
import java.io.InputStream;
import java.net.URL;


/**
 * This class is extremely useful for loading resources and classes in a fault tolerant manner
 * that works across different applications servers.
 * <p/>
 * It has come out of many months of frustrating use of multiple application servers at Atlassian,
 * please don't change things unless you're sure they're not going to break in one server or another!
 *
 */
public class ClassLoaderUtils {

    /**
     * Load a given resource.
     * <p/>
     * This method will try to load the resource using the following methods (in order):
     * <ul>
     * <li>From {@link Thread#getContextClassLoader() Thread.currentThread().getContextClassLoader()}
     * <li>From {@link Class#getClassLoader() ClassLoaderUtil.class.getClassLoader()}
     * <li>From the {@link Class#getClassLoader() callingClass.getClassLoader() }
     * </ul>
     *
     * @param resourceName The name of the resource to load
     * @param callingClass The Class object of the calling object
     */
    public static URL getResource(String resourceName, Class callingClass) {
        URL url = null;

        url = Thread.currentThread().getContextClassLoader().getResource(resourceName);

        if (url == null) {
            url = ClassLoaderUtils.class.getClassLoader().getResource(resourceName);
        }

        if (url == null) {
            url = callingClass.getClassLoader().getResource(resourceName);
        }

        return url;
    }

    /**
     * This is a convenience method to load a resource as a stream.
     * <p/>
     * The algorithm used to find the resource is given in getResource()
     *
     * @param resourceName The name of the resource to load
     * @param callingClass The Class object of the calling object
     */
    public static InputStream getResourceAsStream(String resourceName, Class callingClass) {
        URL url = getResource(resourceName, callingClass);

        try {
            return (url != null) ? url.openStream() : null;
        } catch (IOException e) {
            return null;
        }
    }

    /**
     * Load a class with a given name.
     * <p/>
     * It will try to load the class in the following order:
     * <ul>
     * <li>From {@link Thread#getContextClassLoader() Thread.currentThread().getContextClassLoader()}
     * <li>Using the basic {@link Class#forName(java.lang.String) }
     * <li>From {@link Class#getClassLoader() ClassLoaderUtil.class.getClassLoader()}
     * <li>From the {@link Class#getClassLoader() callingClass.getClassLoader() }
     * </ul>
     *
     * @param className    The name of the class to load
     * @param callingClass The Class object of the calling object
     * @throws ClassNotFoundException If the class cannot be found anywhere.
     */
    public static Class loadClass(String className, Class callingClass) throws ClassNotFoundException {
        try {
            return Thread.currentThread().getContextClassLoader().loadClass(className);
        } catch (ClassNotFoundException e) {
            try {
                return Class.forName(className);
            } catch (ClassNotFoundException ex) {
                try {
                    return ClassLoaderUtils.class.getClassLoader().loadClass(className);
                } catch (ClassNotFoundException exc) {
                    return callingClass.getClassLoader().loadClass(className);
                }
            }
        }
    }

    /**
     * Prints the current classloader hierarchy - useful for debugging.
     */
    public static void printClassLoader() {
        System.out.println("ClassLoaderUtils.printClassLoader");
        printClassLoader(Thread.currentThread().getContextClassLoader());
    }

    /**
     * Prints the classloader hierarchy from a given classloader - useful for debugging.
     */
    public static void printClassLoader(ClassLoader cl) {
        System.out.println("ClassLoaderUtils.printClassLoader(cl = " + cl + ")");

        if (cl != null) {
            printClassLoader(cl.getParent());
        }
    }
}
"
core/src/main/java/org/apache/struts2/util/ContainUtil.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

import java.lang.reflect.Array;
import java.util.Collection;
import java.util.Map;


/**
 * <code>ContainUtil</code> will check if object 1 contains object 2.
 * Object 1 may be an Object, array, Collection, or a Map
 *
 */
public class ContainUtil {

    public static boolean contains(Object obj1, Object obj2) {
        if ((obj1 == null) || (obj2 == null)) {
            //log.debug("obj1 or obj2 are null.");
            return false;
        }

        if (obj1 instanceof Map) {
            if (((Map) obj1).containsValue(obj2)) {
                //log.debug("obj1 is a map and contains obj2");
                return true;
            }
        } else if (obj1 instanceof Collection) {
            if (((Collection) obj1).contains(obj2)) {
                //log.debug("obj1 is a collection and contains obj2");
                return true;
            }
        } else if (obj1.getClass().isArray()) {
            for (int i = 0; i < Array.getLength(obj1); i++) {
                Object value = null;
                value = Array.get(obj1, i);

                if (value.equals(obj2)) {
                    //log.debug("obj1 is an array and contains obj2");
                    return true;
                }
            }
        } else if (obj1.equals(obj2)) {
            //log.debug("obj1 is an object and equals obj2");
            return true;
        }

        //log.debug("obj1 does not contain obj2: " + obj1 + ", " + obj2);
        return false;
    }
}
"
core/src/main/java/org/apache/struts2/util/Counter.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

import java.io.Serializable;


/**
 * A bean that can be used to keep track of a counter.
 * <p/>
 * Since it is an Iterator it can be used by the iterator tag
 *
 */
public class Counter implements java.util.Iterator, Serializable {

	private static final long serialVersionUID = 2796965884308060179L;

	boolean wrap = false;

    // Attributes ----------------------------------------------------
    long first = 1;
    long current = first;
    long interval = 1;
    long last = -1;


    public void setAdd(long addition) {
        current += addition;
    }

    public void setCurrent(long current) {
        this.current = current;
    }

    public long getCurrent() {
        return current;
    }

    public void setFirst(long first) {
        this.first = first;
        current = first;
    }

    public long getFirst() {
        return first;
    }

    public void setInterval(long interval) {
        this.interval = interval;
    }

    public long getInterval() {
        return interval;
    }

    public void setLast(long last) {
        this.last = last;
    }

    public long getLast() {
        return last;
    }

    // Public --------------------------------------------------------
    public long getNext() {
        long next = current;
        current += interval;

        if (wrap && (current > last)) {
            current -= ((1 + last) - first);
        }

        return next;
    }

    public long getPrevious() {
        current -= interval;

        if (wrap && (current < first)) {
            current += (last - first + 1);
        }

        return current;
    }

    public void setWrap(boolean wrap) {
        this.wrap = wrap;
    }

    public boolean isWrap() {
        return wrap;
    }

    public boolean hasNext() {
        return ((last == -1) || wrap) ? true : (current <= last);
    }

    public Object next() {
        return new Long(getNext());
    }

    public void remove() {
        // Do nothing
    }
}
"
core/src/main/java/org/apache/struts2/util/DateFormatter.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;


/**
 * A bean that can be used to format dates
 *
 */
public class DateFormatter {

    Date date;
    DateFormat format;

    // Attributes ----------------------------------------------------
    DateFormat parser;


    // Public --------------------------------------------------------
    public DateFormatter() {
        this.parser = new SimpleDateFormat();
        this.format = new SimpleDateFormat();
        this.date = new Date();
    }


    public void setDate(String date) {
        try {
            this.date = parser.parse(date);
        } catch (ParseException e) {
            throw new IllegalArgumentException(e.getMessage());
        }
    }

    public void setDate(Date date) {
        this.date = date;
    }

    public void setDate(int date) {
        setDate(Integer.toString(date));
    }

    public Date getDate() {
        return this.date;
    }

    public void setFormat(String format) {
        this.format = new SimpleDateFormat(format);
    }

    public void setFormat(DateFormat format) {
        this.format = format;
    }

    public String getFormattedDate() {
        return format.format(date);
    }

    public void setParseFormat(String format) {
        this.parser = new SimpleDateFormat(format);
    }

    public void setParser(DateFormat parser) {
        this.parser = parser;
    }

    public void setTime(long time) {
        date.setTime(time);
    }
}
"
core/src/main/java/org/apache/struts2/util/FastByteArrayOutputStream.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.io.Writer;
import java.util.Iterator;
import java.util.LinkedList;


/**
 * A speedy implementation of ByteArrayOutputStream. It's not synchronized, and it
 * does not copy buffers when it's expanded. There's also no copying of the internal buffer
 * if it's contents is extracted with the writeTo(stream) method.
 *
 */
public class FastByteArrayOutputStream extends OutputStream {

    // Static --------------------------------------------------------
    private static final int DEFAULT_BLOCK_SIZE = 8192;


    private LinkedList buffers;

    // Attributes ----------------------------------------------------
    // internal buffer
    private byte[] buffer;

    // is the stream closed?
    private boolean closed;
    private int blockSize;
    private int index;
    private int size;


    // Constructors --------------------------------------------------
    public FastByteArrayOutputStream() {
        this(DEFAULT_BLOCK_SIZE);
    }

    public FastByteArrayOutputStream(int aSize) {
        blockSize = aSize;
        buffer = new byte[blockSize];
    }


    public int getSize() {
        return size + index;
    }

    public void close() {
        closed = true;
    }

    public byte[] toByteArray() {
        byte[] data = new byte[getSize()];

        // Check if we have a list of buffers
        int pos = 0;

        if (buffers != null) {
            Iterator iter = buffers.iterator();

            while (iter.hasNext()) {
                byte[] bytes = (byte[]) iter.next();
                System.arraycopy(bytes, 0, data, pos, blockSize);
                pos += blockSize;
            }
        }

        // write the internal buffer directly
        System.arraycopy(buffer, 0, data, pos, index);

        return data;
    }

    public String toString() {
        return new String(toByteArray());
    }

    // OutputStream overrides ----------------------------------------
    public void write(int datum) throws IOException {
        if (closed) {
            throw new IOException("Stream closed");
        } else {
            if (index == blockSize) {
                addBuffer();
            }

            // store the byte
            buffer[index++] = (byte) datum;
        }
    }

    public void write(byte[] data, int offset, int length) throws IOException {
        if (data == null) {
            throw new NullPointerException();
        } else if ((offset < 0) || ((offset + length) > data.length) || (length < 0)) {
            throw new IndexOutOfBoundsException();
        } else if (closed) {
            throw new IOException("Stream closed");
        } else {
            if ((index + length) > blockSize) {
                int copyLength;

                do {
                    if (index == blockSize) {
                        addBuffer();
                    }

                    copyLength = blockSize - index;

                    if (length < copyLength) {
                        copyLength = length;
                    }

                    System.arraycopy(data, offset, buffer, index, copyLength);
                    offset += copyLength;
                    index += copyLength;
                    length -= copyLength;
                } while (length > 0);
            } else {
                // Copy in the subarray
                System.arraycopy(data, offset, buffer, index, length);
                index += length;
            }
        }
    }

    // Public
    public void writeTo(OutputStream out) throws IOException {
        // Check if we have a list of buffers
        if (buffers != null) {
            Iterator iter = buffers.iterator();

            while (iter.hasNext()) {
                byte[] bytes = (byte[]) iter.next();
                out.write(bytes, 0, blockSize);
            }
        }

        // write the internal buffer directly
        out.write(buffer, 0, index);
    }

    public void writeTo(RandomAccessFile out) throws IOException {
        // Check if we have a list of buffers
        if (buffers != null) {
            Iterator iter = buffers.iterator();

            while (iter.hasNext()) {
                byte[] bytes = (byte[]) iter.next();
                out.write(bytes, 0, blockSize);
            }
        }

        // write the internal buffer directly
        out.write(buffer, 0, index);
    }

    public void writeTo(Writer out, String encoding) throws IOException {
        // Check if we have a list of buffers
        if (buffers != null) {
            Iterator iter = buffers.iterator();

            while (iter.hasNext()) {
                byte[] bytes = (byte[]) iter.next();

                if (encoding != null) {
                    out.write(new String(bytes, encoding));
                } else {
                    out.write(new String(bytes));
                }
            }
        }

        // write the internal buffer directly
        if (encoding != null) {
            out.write(new String(buffer, 0, index, encoding));
        } else {
            out.write(new String(buffer, 0, index));
        }
    }

    /**
     * Create a new buffer and store the
     * current one in linked list
     */
    protected void addBuffer() {
        if (buffers == null) {
            buffers = new LinkedList();
        }

        buffers.addLast(buffer);

        buffer = new byte[blockSize];
        size += index;
        index = 0;
    }
}
"
core/src/main/java/org/apache/struts2/util/InvocationSessionStore.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * InvocationSessionStore
 *
 */
public class InvocationSessionStore {

    private static final String INVOCATION_MAP_KEY = "org.apache.struts2.util.InvocationSessionStore.invocationMap";


    private InvocationSessionStore() {
    }


    /**
     * Checks the Map in the Session for the key and the token. If the
     * ActionInvocation is saved in the Session, the ValueStack from the
     * ActionProxy associated with the ActionInvocation is set into the
     * ActionContext and the ActionInvocation is returned.
     *
     * @param key the name the DefaultActionInvocation and ActionContext were saved as
     * @return the DefaultActionInvocation saved using the key, or null if none was found
     */
    public static ActionInvocation loadInvocation(String key, String token) {
        InvocationContext invocationContext = (InvocationContext) getInvocationMap().get(key);

        if ((invocationContext == null) || !invocationContext.token.equals(token)) {
            return null;
        }

        OgnlValueStack stack = invocationContext.invocation.getStack();
        ActionContext.getContext().setValueStack(stack);

        return invocationContext.invocation;
    }

    /**
     * Stores the DefaultActionInvocation and ActionContext into the Session using the provided key for loading later using
     * {@link #loadInvocation}
     *
     * @param key
     * @param invocation
     */
    public static void storeInvocation(String key, String token, ActionInvocation invocation) {
        InvocationContext invocationContext = new InvocationContext(invocation, token);
        Map invocationMap = getInvocationMap();
        invocationMap.put(key, invocationContext);
        setInvocationMap(invocationMap);
    }

    static void setInvocationMap(Map invocationMap) {
        Map session = ActionContext.getContext().getSession();

        if (session == null) {
            throw new IllegalStateException("Unable to access the session.");
        }

        session.put(INVOCATION_MAP_KEY, invocationMap);
    }

    static Map getInvocationMap() {
        Map session = ActionContext.getContext().getSession();

        if (session == null) {
            throw new IllegalStateException("Unable to access the session.");
        }

        Map invocationMap = (Map) session.get(INVOCATION_MAP_KEY);

        if (invocationMap == null) {
            invocationMap = new HashMap();
            setInvocationMap(invocationMap);
        }

        return invocationMap;
    }


    private static class InvocationContext implements Serializable {
    	
		private static final long serialVersionUID = -286697666275777888L;
		
		ActionInvocation invocation;
        String token;

        public InvocationContext(ActionInvocation invocation, String token) {
            this.invocation = invocation;
            this.token = token;
        }
    }
}
"
core/src/main/java/org/apache/struts2/util/IteratorFilterSupport.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

import java.util.Enumeration;
import java.util.Iterator;


/**
 * A base class for iterator filters
 *
 */
public abstract class IteratorFilterSupport {

    // Protected implementation --------------------------------------
    protected Object getIterator(Object source) {
        return MakeIterator.convert(source);
    }


    // Wrapper for enumerations
    public class EnumerationIterator implements Iterator {
        Enumeration enumeration;

        public EnumerationIterator(Enumeration aEnum) {
            enumeration = aEnum;
        }

        public boolean hasNext() {
            return enumeration.hasMoreElements();
        }

        public Object next() {
            return enumeration.nextElement();
        }

        public void remove() {
            throw new UnsupportedOperationException("Remove is not supported in IteratorFilterSupport.");
        }
    }
}
"
core/src/main/java/org/apache/struts2/util/IteratorGenerator.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.StringTokenizer;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.opensymphony.xwork2.Action;


/**
 * A bean that generates an iterator filled with a given object depending on the count,
 * separator and converter defined. It is being used by IteratorGeneratorTag. 
 *
 */
public class IteratorGenerator implements Iterator, Action {
	
	private static final Log _log = LogFactory.getLog(IteratorGenerator.class);

    List values;
    Object value;
    String separator;
    Converter converter;

    // Attributes ----------------------------------------------------
    int count = 0;
    int currentCount = 0;


    public void setCount(int aCount) {
        this.count = aCount;
    }

    public boolean getHasNext() {
        return hasNext();
    }

    public Object getNext() {
        return next();
    }

    public void setSeparator(String aChar) {
        separator = aChar;
    }
    
    public void setConverter(Converter aConverter) {
    	converter = aConverter;
    }

    // Public --------------------------------------------------------
    public void setValues(Object aValue) {
        value = aValue;
    }

    // Action implementation -----------------------------------------
    public String execute() {
        if (value == null) {
            return ERROR;
        } else {
            values = new ArrayList();

            if (separator != null) {
                StringTokenizer tokens = new StringTokenizer(value.toString(), separator);

                while (tokens.hasMoreTokens()) {
                	String token = tokens.nextToken().trim();
                	if (converter != null) {
                		try {
                			Object convertedObj = converter.convert(token);
                			values.add(convertedObj);
                		}
                		catch(Exception e) { // make sure things, goes on, we just ignore the bad ones
                			_log.warn("unable to convert ["+token+"], skipping this token, it will not appear in the generated iterator", e);
                		}
                	}
                	else {
                		values.add(token);
                	}
                }
            } else {
                values.add(value.toString());
            }

            // Count default is the size of the list of values
            if (count == 0) {
                count = values.size();
            }

            return SUCCESS;
        }
    }

    // Iterator implementation ---------------------------------------
    public boolean hasNext() {
        return (value == null) ? false : ((currentCount < count) || (count == -1));
    }

    public Object next() {
        try {
            return values.get(currentCount % values.size());
        } finally {
            currentCount++;
        }
    }

    public void remove() {
        throw new UnsupportedOperationException("Remove is not supported in IteratorGenerator.");
    }
    
    
    // Inner class --------------------------------------------------
    /**
     * Interface for converting each separated token into an Object of choice.
     */
    public static interface Converter {
    	Object convert(String token) throws Exception;
    }
}
"
core/src/main/java/org/apache/struts2/util/ListEntry.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

/**
 * Entry in a list.
 *
 */
public class ListEntry {

    final private Object key;
    final private Object value;
    final private boolean isSelected;


    public ListEntry(Object key, Object value, boolean isSelected) {
        this.key = key;
        this.value = value;
        this.isSelected = isSelected;
    }


    public boolean getIsSelected() {
        return isSelected;
    }

    public Object getKey() {
        return key;
    }

    public Object getValue() {
        return value;
    }
}
"
core/src/main/java/org/apache/struts2/util/MakeIterator.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.Map;


/**
 * MakeIterator.
 *
 */
public class MakeIterator {

    /**
     * Determine whether a given object can be made into an <code>Iterator</code>
     *
     * @param object the object to check
     * @return <code>true</code> if the object can be converted to an iterator and
     *         <code>false</code> otherwise
     */
    public static boolean isIterable(Object object) {
        if (object == null) {
            return false;
        }

        if (object instanceof Map) {
            return true;
        } else if (object instanceof Collection) {
            return true;
        } else if (object.getClass().isArray()) {
            return true;
        } else if (object instanceof Enumeration) {
            return true;
        } else if (object instanceof Iterator) {
            return true;
        } else {
            return false;
        }
    }

    public static Iterator convert(Object value) {
        Iterator iterator;

        if (value instanceof Iterator) {
            return (Iterator) value;
        }

        if (value instanceof Map) {
            value = ((Map) value).entrySet();
        }

        if (value == null) {
            return null;
        }

        if (value instanceof Collection) {
            iterator = ((Collection) value).iterator();
        } else if (value.getClass().isArray()) {
            //need ability to support primitives; therefore, cannot
            //use Object[] casting.
            ArrayList list = new ArrayList(Array.getLength(value));

            for (int j = 0; j < Array.getLength(value); j++) {
                list.add(Array.get(value, j));
            }

            iterator = list.iterator();
        } else if (value instanceof Enumeration) {
            Enumeration enumeration = (Enumeration) value;
            ArrayList list = new ArrayList();

            while (enumeration.hasMoreElements()) {
                list.add(enumeration.nextElement());
            }

            iterator = list.iterator();
        } else {
            List list = new ArrayList(1);
            list.add(value);
            iterator = list.iterator();
        }

        return iterator;
    }
}
"
core/src/main/java/org/apache/struts2/util/MergeIteratorFilter.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import com.opensymphony.xwork2.Action;


/**
 * A bean that takes several iterators and outputs the merge of them. Used by 
 * MergeIteratorTag.
 *
 * @see org.apache.struts2.views.jsp.iterator.MergeIteratorTag
 * @see org.apache.struts2.components.MergeIterator
 */
public class MergeIteratorFilter extends IteratorFilterSupport implements Iterator, Action {

    List iterators = new ArrayList();

    // Attributes ----------------------------------------------------
    List sources = new ArrayList();
    int idx = 0;


    // Public --------------------------------------------------------
    public void setSource(Object anIterator) {
        sources.add(anIterator);
    }

    // Action implementation -----------------------------------------
    public String execute() {
        // Make source transformations
        for (int i = 0; i < sources.size(); i++) {
            Object source = sources.get(i);
            iterators.add(getIterator(source));
        }

        return SUCCESS;
    }

    // Iterator implementation ---------------------------------------
    public boolean hasNext() {
        while (iterators.size() > 0) {
            if (((Iterator) iterators.get(idx)).hasNext()) {
                return true;
            } else {
                iterators.remove(idx);

                if (iterators.size() > 0) {
                    idx = idx % iterators.size();
                }
            }
        }

        return false;
    }

    public Object next() {
        try {
            return ((Iterator) iterators.get(idx)).next();
        } finally {
            idx = (idx + 1) % iterators.size();
        }
    }

    public void remove() {
        throw new UnsupportedOperationException("Remove is not supported in MergeIteratorFilter.");
    }
}
"
core/src/main/java/org/apache/struts2/util/ObjectFactoryDestroyable.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

/**
 * An interface to be implemented by any ObjectFactory implementation 
 * if it requires shutdown hook whenever an ObjectFactory is to be 
 * destroyed. 
 * 
 * @see org.apache.struts2.dispatcher.FilterDispatcher
 * @see org.apache.struts2.dispatcher.Dispatcher
 */
public interface ObjectFactoryDestroyable {
	void destroy();
}
"
core/src/main/java/org/apache/struts2/util/ObjectFactoryInitializable.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

import javax.servlet.ServletContext;

/**
 * Used to pass ServletContext init parameters to various
 * frameworks such as Spring, Plexus and Portlet.
 */
public interface ObjectFactoryInitializable {

    void init(ServletContext servletContext);

}
"
core/src/main/java/org/apache/struts2/util/ObjectFactoryLifecycle.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

/**
 * An interface indicating the lifecycle of an ObjectFactory implementation.
 * 
 * @see ObjectFactoryLifecycle
 * @see com.opensymphony.xwork2.ObjectFactory
 * @see org.apache.struts2.util.ObjectFactoryInitializable
 * @see org.apache.struts2.util.ObjectFactoryDestroyable
 */
public interface ObjectFactoryLifecycle extends ObjectFactoryInitializable, ObjectFactoryDestroyable {
	
}
"
core/src/main/java/org/apache/struts2/util/PrefixTrie.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

/**
 * Quickly matches a prefix to an object.
 *
 */
public class PrefixTrie {

    // supports 7-bit chars.
    private static final int SIZE = 128;

    Node root = new Node();

    public void put(String prefix, Object value) {
        Node current = root;
        for (int i = 0; i < prefix.length(); i++) {
            char c = prefix.charAt(i);
            if (c > SIZE)
                throw new IllegalArgumentException("'" + c + "' is too big.");
            if (current.next[c] == null)
                current.next[c] = new Node();
            current = current.next[c];
        }
        current.value = value;
    }

    public Object get(String key) {
        Node current = root;
        for (int i = 0; i < key.length(); i++) {
            char c = key.charAt(i);
            if (c > SIZE)
                return null;
            current = current.next[c];
            if (current == null)
                return null;
            if (current.value != null)
                return current.value;
        }
        return null;
    }

    static class Node {
        Object value;
        Node[] next = new Node[SIZE];
    }
}
"
core/src/main/java/org/apache/struts2/util/ResolverSetupServletContextListener.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import javax.servlet.ServletContext;
import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;

import org.apache.struts2.dispatcher.Dispatcher;
import org.apache.struts2.dispatcher.DispatcherListener;

import com.opensymphony.xwork2.config.Configuration;
import com.opensymphony.xwork2.config.entities.PackageConfig;


/**
 * A Servlet Context Listener that will loop through all Reference Resolvers available in
 * the xwork Configuration and set the ServletContext on those that are ServletContextAware.
 * The Servlet Context can be used by the External Reference Resolver to initialise it's state. i.e. the
 * Spring framework uses a ContextServletListener to initialise it's IoC container, storing it's
 * container context (ApplicationContext in Spring terms) in the Servlet context, the External
 * Reference Resolver can get a reference to the container context from the servlet context.
 */
public class ResolverSetupServletContextListener implements ServletContextListener {

    Map<ServletContext,Listener> listeners = new HashMap<ServletContext,Listener>();
    
    public synchronized void contextDestroyed(ServletContextEvent event) {
        Listener l = listeners.get(event.getServletContext());
        Dispatcher.removeDispatcherListener(l);
        listeners.remove(event.getServletContext());
    }

    public synchronized void contextInitialized(ServletContextEvent event) {
        Listener l = new Listener(event.getServletContext());
        Dispatcher.addDispatcherListener(l);
        listeners.put(event.getServletContext(), l);
    }
    
    private class Listener implements DispatcherListener {

        private ServletContext servletContext;
        
        public Listener(ServletContext ctx) {
            this.servletContext = ctx;
        }
        
        public void dispatcherInitialized(Dispatcher du) {
            Configuration config = du.getConfigurationManager().getConfiguration();
            String key;
            PackageConfig packageConfig;

            for (Iterator iter = config.getPackageConfigNames().iterator();
                 iter.hasNext();) {
                key = (String) iter.next();
                packageConfig = config.getPackageConfig(key);

                if (packageConfig.getExternalRefResolver()instanceof ServletContextAware) {
                    ((ServletContextAware) packageConfig.getExternalRefResolver()).setServletContext(servletContext);
                }
            }
            
        }

        public void dispatcherDestroyed(Dispatcher du) {
        }
    }
}
"
core/src/main/java/org/apache/struts2/util/ServletContextAware.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

import javax.servlet.ServletContext;


/**
 * For components that have a dependence on the Servlet context.
 */
public interface ServletContextAware {

    public void setServletContext(ServletContext context);
}
"
core/src/main/java/org/apache/struts2/util/Sorter.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

import java.util.Comparator;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * Sorters. Utility sorters for use with the "sort" tag.
 *
 * @see org.apache.struts2.views.jsp.iterator.SortIteratorTag
 * @see SortIteratorFilter
 */
public class Sorter {

    public Comparator getAscending() {
        return new Comparator() {
            public int compare(Object o1, Object o2) {
                if (o1 instanceof Comparable) {
                    return ((Comparable) o1).compareTo(o2);
                } else {
                    String s1 = o1.toString();
                    String s2 = o2.toString();

                    return s1.compareTo(s2);
                }
            }
        };
    }

    public Comparator getAscending(final String anExpression) {
        return new Comparator() {
            private OgnlValueStack stack = new OgnlValueStack();

            public int compare(Object o1, Object o2) {
                // Get value for first object
                stack.push(o1);

                Object v1 = stack.findValue(anExpression);
                stack.pop();

                // Get value for second object
                stack.push(o2);

                Object v2 = stack.findValue(anExpression);
                stack.pop();

                // Ensure non-null
                if (v1 == null) {
                    v1 = "";
                }

                if (v2 == null) {
                    v2 = "";
                }

                // Compare them
                if (v1 instanceof Comparable && v1.getClass().equals(v2.getClass())) {
                    return ((Comparable) v1).compareTo(v2);
                } else {
                    String s1 = v1.toString();
                    String s2 = v2.toString();

                    return s1.compareTo(s2);
                }
            }
        };
    }

    public Comparator getComparator(String anExpression, boolean ascending) {
        if (ascending) {
            return getAscending(anExpression);
        } else {
            return getDescending(anExpression);
        }
    }

    public Comparator getDescending() {
        return new Comparator() {
            public int compare(Object o1, Object o2) {
                if (o2 instanceof Comparable) {
                    return ((Comparable) o2).compareTo(o1);
                } else {
                    String s1 = o1.toString();
                    String s2 = o2.toString();

                    return s2.compareTo(s1);
                }
            }
        };
    }

    public Comparator getDescending(final String anExpression) {
        return new Comparator() {
            private OgnlValueStack stack = new OgnlValueStack();

            public int compare(Object o1, Object o2) {
                // Get value for first object
                stack.push(o1);

                Object v1 = stack.findValue(anExpression);
                stack.pop();

                // Get value for second object
                stack.push(o2);

                Object v2 = stack.findValue(anExpression);
                stack.pop();

                // Ensure non-null
                if (v1 == null) {
                    v1 = "";
                }

                if (v2 == null) {
                    v2 = "";
                }

                // Compare them
                if (v2 instanceof Comparable && v1.getClass().equals(v2.getClass())) {
                    return ((Comparable) v2).compareTo(v1);
                } else {
                    String s1 = v1.toString();
                    String s2 = v2.toString();

                    return s2.compareTo(s1);
                }
            }
        };
    }
}
"
core/src/main/java/org/apache/struts2/util/SortIteratorFilter.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;

import org.apache.commons.logging.LogFactory;

import com.opensymphony.xwork2.Action;


/**
 * A bean that takes a source and comparator then attempt to sort the source
 * utilizing the comparator. It is being used in SortIteratorTag.
 *
 * @see org.apache.struts2.views.jsp.iterator.SortIteratorTag
 */
public class SortIteratorFilter extends IteratorFilterSupport implements Iterator, Action {

    Comparator comparator;
    Iterator iterator;
    List list;

    // Attributes ----------------------------------------------------
    Object source;


    public void setComparator(Comparator aComparator) {
        this.comparator = aComparator;
    }

    public List getList() {
        return list;
    }

    // Public --------------------------------------------------------
    public void setSource(Object anIterator) {
        source = anIterator;
    }

    // Action implementation -----------------------------------------
    public String execute() {
        if (source == null) {
            return ERROR;
        } else {
            try {
                if (!MakeIterator.isIterable(source)) {
                    LogFactory.getLog(SortIteratorFilter.class.getName()).warn("Cannot create SortIterator for source " + source);

                    return ERROR;
                }

                list = new ArrayList();

                Iterator i = MakeIterator.convert(source);

                while (i.hasNext()) {
                    list.add(i.next());
                }

                // Sort it
                Collections.sort(list, comparator);
                iterator = list.iterator();

                return SUCCESS;
            } catch (Exception e) {
                LogFactory.getLog(SortIteratorFilter.class.getName()).warn("Error creating sort iterator.", e);

                return ERROR;
            }
        }
    }

    // Iterator implementation ---------------------------------------
    public boolean hasNext() {
        return (source == null) ? false : iterator.hasNext();
    }

    public Object next() {
        return iterator.next();
    }

    public void remove() {
        throw new UnsupportedOperationException("Remove is not supported in SortIteratorFilter.");
    }
}
"
core/src/main/java/org/apache/struts2/util/StrutsTypeConverter.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

import java.util.Map;

import ognl.DefaultTypeConverter;

/**
 * <!-- START SNIPPET: javadoc -->
 *
 * Base class for type converters used in Struts. This class provides two abstract methods that are used to convert
 * both to and from strings -- the critical functionality that is core to Struts's type coversion system.
 *
 * <p/> Type converters do not have to use this class. It is merely a helper base class, although it is recommended that
 * you use this class as it provides the common type conversion contract required for all web-based type conversion.
 *
 * <p/> There's a hook (fall back method) called <code>performFallbackConversion</code> of which
 * could be used to perform some fallback conversion if <code>convertValue</code> method of this
 * failed. By default it just ask its super class (Ognl's DefaultTypeConverter) to do the conversion.
 *
 * <p/> To allow the framework to recognize that a conversion error has occurred, throw an XWorkException or
 * preferable a TypeConversionException.
 *
 * <!-- END SNIPPET: javadoc -->
 *
 */
public abstract class StrutsTypeConverter extends DefaultTypeConverter {
    public Object convertValue(Map context, Object o, Class toClass) {
        if (toClass.equals(String.class)) {
            return convertToString(context, o);
        } else if (o instanceof String[]) {
            return convertFromString(context, (String[]) o, toClass);
        } else if (o instanceof String) {
            return convertFromString(context, new String[]{(String) o}, toClass);
        } else {
        	return performFallbackConversion(context, o, toClass);
        }
    }

    /**
     * Hook to perform a fallback conversion if every default options failed. By default
     * this will ask Ognl's DefaultTypeConverter (of which this class extends) to
     * perform the conversion.
     *
     * @param context
     * @param o
     * @param toClass
     * @return The fallback conversion
     */
    protected Object performFallbackConversion(Map context, Object o, Class toClass) {
    	return super.convertValue(context, o, toClass);
    }


    /**
     * Converts one or more String values to the specified class.
     *
     * @param context the action context
     * @param values  the String values to be converted, such as those submitted from an HTML form
     * @param toClass the class to convert to
     * @return the converted object
     */
    public abstract Object convertFromString(Map context, String[] values, Class toClass);

    /**
     * Converts the specified object to a String.
     *
     * @param context the action context
     * @param o       the object to be converted
     * @return the converted String
     */
    public abstract String convertToString(Map context, Object o);
}
"
core/src/main/java/org/apache/struts2/util/StrutsUtil.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.views.jsp.ui.OgnlTool;
import org.apache.struts2.views.util.UrlHelper;

import com.opensymphony.xwork2.util.TextUtils;
import com.opensymphony.xwork2.ObjectFactory;
import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * Struts base utility class, for use in Velocity and Freemarker templates
 *
 */
public class StrutsUtil {

    protected static final Log log = LogFactory.getLog(StrutsUtil.class);


    protected HttpServletRequest request;
    protected HttpServletResponse response;
    protected Map classes = new Hashtable();
    protected OgnlTool ognl = OgnlTool.getInstance();
    protected OgnlValueStack stack;


    public StrutsUtil(OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        this.stack = stack;
        this.request = request;
        this.response = response;
    }


    public Object bean(Object aName) throws Exception {
        String name = aName.toString();
        Class c = (Class) classes.get(name);

        if (c == null) {
            c = ClassLoaderUtils.loadClass(name, StrutsUtil.class);
            classes.put(name, c);
        }

        return ObjectFactory.getObjectFactory().buildBean(c, stack.getContext());
    }

    public boolean isTrue(String expression) {
        Boolean retVal = (Boolean) stack.findValue(expression, Boolean.class);
        if (retVal == null) {
            return false;
        }
        return retVal.booleanValue();
    }

    public Object findString(String name) {
        return stack.findValue(name, String.class);
    }

    public String include(Object aName) throws Exception {
        return include(aName, request, response);
    }

    /**
     * @deprecated the request and response are stored in this util class, please use include(string)
     */
    public String include(Object aName, HttpServletRequest aRequest, HttpServletResponse aResponse) throws Exception {
        try {
            RequestDispatcher dispatcher = aRequest.getRequestDispatcher(aName.toString());

            if (dispatcher == null) {
                throw new IllegalArgumentException("Cannot find included file " + aName);
            }

            ResponseWrapper responseWrapper = new ResponseWrapper(aResponse);

            dispatcher.include(aRequest, responseWrapper);

            return responseWrapper.getData();
        }
        catch (Exception e) {
            e.printStackTrace();
            throw e;
        }
    }

    public String urlEncode(String s) {
        try {
            return URLEncoder.encode(s, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            return s;
        }
    }

    public String buildUrl(String url) {
        return UrlHelper.buildUrl(url, request, response, null);
    }

    public Object findValue(String expression, String className) throws ClassNotFoundException {
        return stack.findValue(expression, Class.forName(className));
    }

    public String getText(String text) {
        return (String) stack.findValue("getText('" + text + "')"); 
    }

    /*
	 * @return the url ContextPath. An empty string if one does not exist.
	 */
	public String getContext() {
		return (request == null)? "" : request.getContextPath();
	}

    /**
     * the selectedList objects are matched to the list.listValue
     * <p/>
     * listKey and listValue are optional, and if not provided, the list item is used
     *
     * @param selectedList the name of the action property
     *                     that contains the list of selected items
     *                     or single item if its not an array or list
     * @param list         the name of the action property
     *                     that contains the list of selectable items
     * @param listKey      an ognl expression that is exaluated relative to the list item
     *                     to use as the key of the ListEntry
     * @param listValue    an ognl expression that is exaluated relative to the list item
     *                     to use as the value of the ListEntry
     * @return a List of ListEntry
     */
    public List makeSelectList(String selectedList, String list, String listKey, String listValue) {
        List selectList = new ArrayList();

        Collection selectedItems = null;

        Object i = stack.findValue(selectedList);

        if (i != null) {
            if (i.getClass().isArray()) {
                selectedItems = Arrays.asList((Object[]) i);
            } else if (i instanceof Collection) {
                selectedItems = (Collection) i;
            } else {
                // treat it is a single item
                selectedItems = new ArrayList();
                selectedItems.add(i);
            }
        }

        Collection items = (Collection) stack.findValue(list);

        if (items != null) {
            for (Iterator iter = items.iterator(); iter.hasNext();) {
                Object element = (Object) iter.next();
                Object key = null;

                if ((listKey == null) || (listKey.length() == 0)) {
                    key = element;
                } else {
                    key = ognl.findValue(listKey, element);
                }

                Object value = null;

                if ((listValue == null) || (listValue.length() == 0)) {
                    value = element;
                } else {
                    value = ognl.findValue(listValue, element);
                }

                boolean isSelected = false;

                if ((value != null) && (selectedItems != null) && selectedItems.contains(value)) {
                    isSelected = true;
                }

                selectList.add(new ListEntry(key, value, isSelected));
            }
        }

        return selectList;
    }

    public String htmlEncode(Object obj) {
        if (obj == null) {
            return null;
        }

        return TextUtils.htmlEncode(obj.toString());
    }

    public int toInt(long aLong) {
        return (int) aLong;
    }

    public long toLong(int anInt) {
        return (long) anInt;
    }

    public long toLong(String aLong) {
        if (aLong == null) {
            return 0;
        }

        return Long.parseLong(aLong);
    }

    public String toString(long aLong) {
        return Long.toString(aLong);
    }

    public String toString(int anInt) {
        return Integer.toString(anInt);
    }


    static class ResponseWrapper extends HttpServletResponseWrapper {
        StringWriter strout;
        PrintWriter writer;
        ServletOutputStream sout;

        ResponseWrapper(HttpServletResponse aResponse) {
            super(aResponse);
            strout = new StringWriter();
            sout = new ServletOutputStreamWrapper(strout);
            writer = new PrintWriter(strout);
        }

        public String getData() {
            writer.flush();

            return strout.toString();
        }

        public ServletOutputStream getOutputStream() {
            return sout;
        }

        public PrintWriter getWriter() throws IOException {
            return writer;
        }
    }

    static class ServletOutputStreamWrapper extends ServletOutputStream {
        StringWriter writer;

        ServletOutputStreamWrapper(StringWriter aWriter) {
            writer = aWriter;
        }

        public void write(int aByte) {
            writer.write(aByte);
        }
    }
}
"
core/src/main/java/org/apache/struts2/util/SubsetIteratorFilter.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.opensymphony.xwork2.Action;


/**
 * A bean that takes an iterator and outputs a subset of it.
 *
 */
public class SubsetIteratorFilter extends IteratorFilterSupport implements Iterator, Action {

	private static final Log _log = LogFactory.getLog(SubsetIteratorFilter.class);
	
    Iterator iterator;
    Object source;
    int count = -1;
    int currentCount = 0;
    
    Decider decider;

    // Attributes ----------------------------------------------------
    int start = 0;


    public void setCount(int aCount) {
        this.count = aCount;
    }

    // Public --------------------------------------------------------
    public void setSource(Object anIterator) {
        source = anIterator;
    }

    public void setStart(int aStart) {
        this.start = aStart;
    }
    
    public void setDecider(Decider aDecider) {
    	this.decider = aDecider;
    }

    // Action implementation -----------------------------------------
    public String execute() {
        if (source == null) {
            LogFactory.getLog(SubsetIteratorFilter.class.getName()).warn("Source is null returning empty set.");

            return ERROR;
        }

        // Make source transformations
        source = getIterator(source);

        // Calculate iterator filter
        if (source instanceof Iterator) {
            iterator = (Iterator) source;
            

            // Read away <start> items
            for (int i = 0; (i < start) && iterator.hasNext(); i++) {
                iterator.next();
            }
            
            
            // now let Decider decide if element should be added (if a decider exist)
            if (decider != null) {
            	List list = new ArrayList();
            	while(iterator.hasNext()) {
            		Object currentElement = iterator.next();
            		if (decide(currentElement)) {
            			list.add(currentElement);
            		}
            	}
            	iterator = list.iterator();
            }
            
        } else if (source.getClass().isArray()) {
            ArrayList list = new ArrayList(((Object[]) source).length);
            Object[] objects = (Object[]) source;
            int len = objects.length;

            if (count >= 0) {
            	len = start + count;
            	if (len > objects.length) {
            		len = objects.length;
            	}
            }

            for (int j = start; j < len; j++) {
            	if (decide(objects[j])) {
                    list.add(objects[j]);
            	}
            }

            count = -1; // Don't have to check this in the iterator code
            iterator = list.iterator();
        }

        if (iterator == null) {
            throw new IllegalArgumentException("Source is not an iterator:" + source);
        }

        return SUCCESS;
    }

    // Iterator implementation ---------------------------------------
    public boolean hasNext() {
        return (iterator == null) ? false : (iterator.hasNext() && ((count < 0) || (currentCount < count)));
    }

    public Object next() {
        currentCount++;

        return iterator.next();
    }

    public void remove() {
        iterator.remove();
    }
    
    // inner class ---------------------------------------------------
    /**
     * A decider determines if the given element should be added to the list or not.
     */
    public static interface Decider {

        /**
         * Should the object be added to the list?
         * @param element  the object
         * @return true to add.
         * @throws Exception can be thrown.
         */
        boolean decide(Object element) throws Exception;
    }
    
    // protected -----------------------------------------------------
    protected boolean decide(Object element) {
    	if (decider != null) {
    		try {
    			boolean okToAdd = decider.decide(element);
    			return okToAdd;
    		}
    		catch(Exception e) {
    			_log.warn("decider ["+decider+"] encountered an error while decide adding element ["+element+"], element will be ignored, it will not appeared in subseted iterator", e);
    			return false;
    		}
    	}
    	return true;
    }
}
"
core/src/main/java/org/apache/struts2/util/TabbedPane.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

import java.util.Vector;


/**
 * A bean that helps implement a tabbed pane
 *
 */
public class TabbedPane {

    protected String tabAlign = null;

    // Attributes ----------------------------------------------------
    protected Vector content = null;
    protected int selectedIndex = 0;


    // Public --------------------------------------------------------
    public TabbedPane(int defaultIndex) {
        selectedIndex = defaultIndex;
    }


    public void setContent(Vector content) {
        this.content = content;
    }

    public Vector getContent() {
        return content;
    }

    public void setSelectedIndex(int selectedIndex) {
        this.selectedIndex = selectedIndex;
    }

    public int getSelectedIndex() {
        return selectedIndex;
    }

    public void setTabAlign(String tabAlign) {
        this.tabAlign = tabAlign;
    }

    public String getTabAlign() {
        return tabAlign;
    }
}
"
core/src/main/java/org/apache/struts2/util/Timer.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;


/**
 * A bean that can be used to time execution of pages
 *
 */
public class Timer {

    // Attributes ----------------------------------------------------
    long current = System.currentTimeMillis();
    long start = current;


    // Public --------------------------------------------------------
    public long getTime() {
        // Return how long time has passed since last check point
        long now = System.currentTimeMillis();
        long time = now - current;

        // Reset so that next time we get from this point
        current = now;

        return time;
    }

    public long getTotal() {
        // Reset start so that next time we get from this point
        return System.currentTimeMillis() - start;
    }
}
"
core/src/main/java/org/apache/struts2/util/TokenHelper.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

import java.math.BigInteger;
import java.util.Map;
import java.util.Random;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.util.LocalizedTextUtil;

/**
 * TokenHelper
 *
 */
public class TokenHelper {

    /**
     * The default name to map the token value
     */
    public static final String DEFAULT_TOKEN_NAME = "struts.token";
    
    /**
     * The name of the field which will hold the token name
     */
    public static final String TOKEN_NAME_FIELD = "struts.token.name";
    private static final Log LOG = LogFactory.getLog(TokenHelper.class);
    private static final Random RANDOM = new Random();


    /**
     * Sets a transaction token into the session using the default token name.
     *
     * @return the token string
     */
    public static String setToken() {
        return setToken(DEFAULT_TOKEN_NAME);
    }

    /**
     * Sets a transaction token into the session using the provided token name.
     *
     * @param tokenName the name to store into the session with the token as the value
     * @return the token string
     */
    public static String setToken(String tokenName) {
        Map session = ActionContext.getContext().getSession();
        String token = generateGUID();
        try {
        	session.put(tokenName, token);
        }
        catch(IllegalStateException e) {
        	// WW-1182 explain to user what the problem is
        	String msg = "Error creating HttpSession due response is commited to client. You can use the CreateSessionInterceptor or create the HttpSession from your action before the result is rendered to the client: " + e.getMessage();
        	LOG.error(msg, e);
        	throw new IllegalArgumentException(msg);
        }

        return token;
    }

    
    /**
     * Gets a transaction token into the session using the default token name.
     * 
     * @return token
     */
    public static String getToken() {
    	return getToken(DEFAULT_TOKEN_NAME);
    }
    
    /**
     * Gets the Token value from the params in the ServletActionContext using the given name
     *
     * @param tokenName the name of the parameter which holds the token value
     * @return the token String or null, if the token could not be found
     */
    public static String getToken(String tokenName) {
        Map params = ActionContext.getContext().getParameters();
        String[] tokens = (String[]) params.get(tokenName);
        String token;

        if ((tokens == null) || (tokens.length < 1)) {
            LOG.warn("Could not find token mapped to token name " + tokenName);

            return null;
        }

        token = tokens[0];

        return token;
    }

    /**
     * Gets the token name from the Parameters in the ServletActionContext
     *
     * @return the token name found in the params, or null if it could not be found
     */
    public static String getTokenName() {
        Map params = ActionContext.getContext().getParameters();

        if (!params.containsKey(TOKEN_NAME_FIELD)) {
            LOG.warn("Could not find token name in params.");

            return null;
        }

        String[] tokenNames = (String[]) params.get(TOKEN_NAME_FIELD);
        String tokenName;

        if ((tokenNames == null) || (tokenNames.length < 1)) {
            LOG.warn("Got a null or empty token name.");

            return null;
        }

        tokenName = tokenNames[0];

        return tokenName;
    }

    /**
     * Checks for a valid transaction token in the current request params. If a valid token is found, it is
     * removed so the it is not valid again.
     *
     * @return false if there was no token set into the params (check by looking for {@link #TOKEN_NAME_FIELD}), true if a valid token is found
     */
    public static boolean validToken() {
        String tokenName = getTokenName();

        if (tokenName == null) {
        	if (LOG.isDebugEnabled())
        		LOG.debug("no token name found -> Invalid token ");
            return false;
        }

        String token = getToken(tokenName);

        if (token == null) {
        	if (LOG.isDebugEnabled()) 
        		LOG.debug("no token found for token name "+tokenName+" -> Invalid token ");
            return false;
        }

        Map session = ActionContext.getContext().getSession();
        String sessionToken = (String) session.get(tokenName);

        if (!token.equals(sessionToken)) {
            LOG.warn(LocalizedTextUtil.findText(TokenHelper.class, "struts.internal.invalid.token", ActionContext.getContext().getLocale(), "Form token {0} does not match the session token {1}.", new Object[]{
                    token, sessionToken
            }));

            return false;
        }

        // remove the token so it won't be used again
        session.remove(tokenName);

        return true;
    }
    
    public static String generateGUID() {
        return new BigInteger(165, RANDOM).toString(36).toUpperCase();
    }
}
"
core/src/main/java/org/apache/struts2/util/URLBean.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

import java.util.HashMap;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.views.util.UrlHelper;


/**
 * A bean that can generate a URL.
 *
 */
public class URLBean {

    HashMap params;
    HttpServletRequest request;
    HttpServletResponse response;
    String page;


    public void setPage(String page) {
        this.page = page;
    }

    public void setRequest(HttpServletRequest request) {
        this.request = request;
    }

    public void setResponse(HttpServletResponse response) {
        this.response = response;
    }

    public String getURL() {
        // all this trickier with maps is to reduce the number of objects created
        Map fullParams = null;

        if (params != null) {
            fullParams = new HashMap();
        }

        if (page == null) {
            // No particular page requested, so go to "same page"
            // Add query params to parameters
            if (fullParams != null) {
                fullParams.putAll(request.getParameterMap());
            } else {
                fullParams = request.getParameterMap();
            }
        }

        // added parameters override, just like in URLTag
        if (params != null) {
            fullParams.putAll(params);
        }

        return UrlHelper.buildUrl(page, request, response, fullParams);
    }

    public URLBean addParameter(String name, Object value) {
        if (params == null) {
            params = new HashMap();
        }

        if (value == null) {
            params.remove(name);
        } else {
            params.put(name, value.toString());
        }

        return this;
    }

    public String toString() {
        return getURL();
    }
}
"
core/src/main/java/org/apache/struts2/util/VelocityStrutsUtil.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.util;

import java.io.CharArrayWriter;
import java.io.IOException;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.views.velocity.VelocityManager;
import org.apache.velocity.context.Context;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * Struts velocity related util.
 *
 */
public class VelocityStrutsUtil extends StrutsUtil {

    private Context ctx;

    public VelocityStrutsUtil(Context ctx, OgnlValueStack stack, HttpServletRequest request, HttpServletResponse response) {
        super(stack, request, response);
        this.ctx = ctx;
    }

    public String evaluate(String expression) throws IOException, ResourceNotFoundException, MethodInvocationException, ParseErrorException {
        CharArrayWriter writer = new CharArrayWriter();
        VelocityManager.getInstance().getVelocityEngine().evaluate(ctx, writer, "Error parsing " + expression, expression);

        return writer.toString();
    }

}
"
core/src/main/java/org/apache/struts2/validators/DWRValidator.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.validators;

import java.util.HashMap;
import java.util.Map;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.dispatcher.ApplicationMap;
import org.apache.struts2.dispatcher.Dispatcher;
import org.apache.struts2.dispatcher.RequestMap;
import org.apache.struts2.dispatcher.SessionMap;

import uk.ltd.getahead.dwr.WebContextFactory;

import com.opensymphony.xwork2.Action;
import com.opensymphony.xwork2.ActionProxy;
import com.opensymphony.xwork2.DefaultActionInvocation;
import com.opensymphony.xwork2.DefaultActionProxy;
import com.opensymphony.xwork2.ValidationAware;
import com.opensymphony.xwork2.ValidationAwareSupport;
import com.opensymphony.xwork2.config.Configuration;
import com.opensymphony.xwork2.config.entities.ActionConfig;

/**
 * <p/>
 * Use the dwr configuration as follows :-
 * 
 * <pre>
 * <!-- START SNIPPET: dwrConfiguration -->
 * 
 * &lt;dwr&lt;
 *    &lt;allow&lt;
 *      &lt;create creator="new" javascript="validator" class="org.apache.struts2.validators.DWRValidator"/&lt;
 *      &lt;convert converter="bean" match="com.opensymphony.xwork2.ValidationAwareSupport"/&lt;
 *    &lt;/allow&lt;
 * &lt;/dwr&lt;
 * 
 * <!-- END SNIPPET: dwrConfiguration -->
 * </pre>
 */
public class DWRValidator {
    private static final Log LOG = LogFactory.getLog(DWRValidator.class);

    public ValidationAwareSupport doPost(String namespace, String action, Map params) throws Exception {
        HttpServletRequest req = WebContextFactory.get().getHttpServletRequest();
        ServletContext servletContext = WebContextFactory.get().getServletContext();
        HttpServletResponse res = WebContextFactory.get().getHttpServletResponse();

        Map requestParams = new HashMap(req.getParameterMap());
        if (params != null) {
            requestParams.putAll(params);
        } else {
            params = requestParams;
        }
        Map requestMap = new RequestMap(req);
        Map session = new SessionMap(req);
        Map application = new ApplicationMap(servletContext);
        Dispatcher du = Dispatcher.getInstance();
        HashMap ctx = du.createContextMap(requestMap,
                params,
                session,
                application,
                req,
                res,
                servletContext);

        try {
            Configuration cfg = du.getConfigurationManager().getConfiguration();
            ValidatorActionProxy proxy = new ValidatorActionProxy(cfg, namespace, action, ctx);
            proxy.execute();
            Object a = proxy.getAction();

            if (a instanceof ValidationAware) {
                ValidationAware aware = (ValidationAware) a;
                ValidationAwareSupport vas = new ValidationAwareSupport();
                vas.setActionErrors(aware.getActionErrors());
                vas.setActionMessages(aware.getActionMessages());
                vas.setFieldErrors(aware.getFieldErrors());

                return vas;
            } else {
                return null;
            }
        } catch (Exception e) {
            LOG.error("Error while trying to validate", e);
            return null;
        }
    }

    public static class ValidatorActionInvocation extends DefaultActionInvocation {
        private static final long serialVersionUID = -7645433725470191275L;

        protected ValidatorActionInvocation(ActionProxy proxy, Map extraContext) throws Exception {
            super(proxy, extraContext, true);
        }

        protected String invokeAction(Object action, ActionConfig actionConfig) throws Exception {
            return Action.NONE; // don't actually execute the action
        }
    }

    public static class ValidatorActionProxy extends DefaultActionProxy {
        private static final long serialVersionUID = 5754781916414047963L;

        protected ValidatorActionProxy(Configuration config, String namespace, String actionName, Map extraContext) throws Exception {
            super(config, namespace, actionName, extraContext, false, true);
        }

        protected void prepare() throws Exception {
            invocation = new ValidatorActionInvocation(this, extraContext);
        }
    }
}
"
core/src/main/java/org/apache/struts2/views/JspSupportServlet.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views;

import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;

/**
 */
public class JspSupportServlet extends HttpServlet {
	
	private static final long serialVersionUID = 8302309812391541933L;
	
	public static JspSupportServlet jspSupportServlet;

    public void init(ServletConfig servletConfig) throws ServletException {
        super.init(servletConfig);

        jspSupportServlet = this;
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/FreemarkerManager.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.Map;
import java.util.Properties;

import javax.servlet.GenericServlet;
import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.StrutsConstants;
import org.apache.struts2.config.Settings;
import org.apache.struts2.views.JspSupportServlet;
import org.apache.struts2.views.freemarker.tags.StrutsModels;
import org.apache.struts2.views.util.ContextUtil;

import com.opensymphony.xwork2.util.FileManager;
import com.opensymphony.xwork2.ObjectFactory;
import com.opensymphony.xwork2.util.OgnlValueStack;

import freemarker.cache.FileTemplateLoader;
import freemarker.cache.MultiTemplateLoader;
import freemarker.cache.TemplateLoader;
import freemarker.cache.WebappTemplateLoader;
import freemarker.ext.beans.BeansWrapper;
import freemarker.ext.jsp.TaglibFactory;
import freemarker.ext.servlet.HttpRequestHashModel;
import freemarker.ext.servlet.HttpRequestParametersHashModel;
import freemarker.ext.servlet.HttpSessionHashModel;
import freemarker.ext.servlet.ServletContextHashModel;
import freemarker.template.ObjectWrapper;
import freemarker.template.SimpleHash;
import freemarker.template.TemplateException;
import freemarker.template.TemplateExceptionHandler;
import freemarker.template.TemplateModel;


/**
 * Static Configuration Manager for the FreemarkerResult's configuration
 *
 * <p/>
 *
 * Possible extension points are :-
 * <ul>
 *   <li>createConfiguration method</li>
 *   <li>loadSettings method</li>
 *   <li>getTemplateLoader method</li>
 *   <li>populateContext method</li>
 * </ul>
 *
 * <p/>
 * <b> createConfiguration method </b><br/>
 * Create a freemarker Configuration.
 * <p/>
 *
 * <b> loadSettings method </b><br/>
 * Load freemarker settings, default to freemarker.properties (if found in classpath)
 * <p/>
 *
 * <b> getTemplateLoader method</b><br/>
 * create a freemarker TemplateLoader that loads freemarker template in the following order :-
 * <ol>
 *   <li>path defined in ServletContext init parameter named 'templatePath' or 'TemplatePath' (must be an absolute path)</li>
 *   <li>webapp classpath</li>
 *   <li>struts's static folder (under [STRUT2_SOURCE]/org/apache/struts2/static/</li>
 * </ol>
 * <p/>
 *
 * <b> populateContext method</b><br/>
 * populate the created model.
 *
 */
public class FreemarkerManager {

    private static final Log log = LogFactory.getLog(FreemarkerManager.class);
    public static final String CONFIG_SERVLET_CONTEXT_KEY = "freemarker.Configuration";
    public static final String KEY_EXCEPTION = "exception";

    // coppied from freemarker servlet - since they are private
    private static final String ATTR_APPLICATION_MODEL = ".freemarker.Application";
    private static final String ATTR_JSP_TAGLIBS_MODEL = ".freemarker.JspTaglibs";
    private static final String ATTR_REQUEST_MODEL = ".freemarker.Request";
    private static final String ATTR_REQUEST_PARAMETERS_MODEL = ".freemarker.RequestParameters";

    // coppied from freemarker servlet - so that there is no dependency on it
    public static final String KEY_APPLICATION = "Application";
    public static final String KEY_REQUEST_MODEL = "Request";
    public static final String KEY_SESSION_MODEL = "Session";
    public static final String KEY_JSP_TAGLIBS = "JspTaglibs";
    public static final String KEY_REQUEST_PARAMETER_MODEL = "Parameters";
    private static FreemarkerManager instance = null;


    /**
     * To allow for custom configuration of freemarker, sublcass this class "ConfigManager" and
     * set the Struts configuration property
     * <b>struts.freemarker.configmanager.classname</b> to the fully qualified classname.
     * <p/>
     * This allows you to override the protected methods in the ConfigMangaer
     * to programatically create your own Configuration instance
     */
    public final static synchronized FreemarkerManager getInstance() {
        if (instance == null) {
            String classname = FreemarkerManager.class.getName();

            if (Settings.isSet(StrutsConstants.STRUTS_FREEMARKER_MANAGER_CLASSNAME)) {
                classname = Settings.get(StrutsConstants.STRUTS_FREEMARKER_MANAGER_CLASSNAME).trim();
            }

            try {
                log.info("Instantiating Freemarker ConfigManager!, " + classname);
                // singleton instances shouldn't be built accessing request or session-specific context data
                instance = (FreemarkerManager) ObjectFactory.getObjectFactory().buildBean(classname, null);
            } catch (Exception e) {
                log.fatal("Fatal exception occurred while trying to instantiate a Freemarker ConfigManager instance, " + classname, e);
            }
        }

        // if the instance creation failed, make sure there is a default instance
        if (instance == null) {
            instance = new FreemarkerManager();
        }

        return instance;
    }

    public final synchronized freemarker.template.Configuration getConfiguration(ServletContext servletContext) throws TemplateException {
        freemarker.template.Configuration config = (freemarker.template.Configuration) servletContext.getAttribute(CONFIG_SERVLET_CONTEXT_KEY);

        if (config == null) {
            config = createConfiguration(servletContext);

            // store this configuration in the servlet context
            servletContext.setAttribute(CONFIG_SERVLET_CONTEXT_KEY, config);
        }

        config.setWhitespaceStripping(true);

        return config;
    }

    protected ScopesHashModel buildScopesHashModel(ServletContext servletContext, HttpServletRequest request, HttpServletResponse response, ObjectWrapper wrapper, OgnlValueStack stack) {
        ScopesHashModel model = new ScopesHashModel(wrapper, servletContext, request, stack);

        // Create hash model wrapper for servlet context (the application)
        // only need one thread to do this once, per servlet context
        synchronized (servletContext) {
            ServletContextHashModel servletContextModel = (ServletContextHashModel) servletContext.getAttribute(ATTR_APPLICATION_MODEL);

            if (servletContextModel == null) {

                GenericServlet servlet = JspSupportServlet.jspSupportServlet;
                // TODO if the jsp support  servlet isn't load-on-startup then it won't exist
                // if it hasn't been accessed, and a JSP page is accessed
                if (servlet != null) {
                    servletContextModel = new ServletContextHashModel(servlet, wrapper);
                    servletContext.setAttribute(ATTR_APPLICATION_MODEL, servletContextModel);
                    TaglibFactory taglibs = new TaglibFactory(servletContext);
                    servletContext.setAttribute(ATTR_JSP_TAGLIBS_MODEL, taglibs);
                }

            }

            model.put(KEY_APPLICATION, servletContextModel);
            model.put(KEY_JSP_TAGLIBS, (TemplateModel) servletContext.getAttribute(ATTR_JSP_TAGLIBS_MODEL));
        }

        // Create hash model wrapper for session
        HttpSession session = request.getSession(false);
        if (session != null) {
            model.put(KEY_SESSION_MODEL, new HttpSessionHashModel(session, wrapper));
        } else {
            // no session means no attributes ???
            //            model.put(KEY_SESSION_MODEL, new SimpleHash());
        }

        // Create hash model wrapper for the request attributes
        HttpRequestHashModel requestModel = (HttpRequestHashModel) request.getAttribute(ATTR_REQUEST_MODEL);

        if ((requestModel == null) || (requestModel.getRequest() != request)) {
            requestModel = new HttpRequestHashModel(request, response, wrapper);
            request.setAttribute(ATTR_REQUEST_MODEL, requestModel);
        }

        model.put(KEY_REQUEST_MODEL, requestModel);


        // Create hash model wrapper for request parameters
        HttpRequestParametersHashModel reqParametersModel = (HttpRequestParametersHashModel) request.getAttribute(ATTR_REQUEST_PARAMETERS_MODEL);
        if (reqParametersModel == null || requestModel.getRequest() != request) {
        	reqParametersModel = new HttpRequestParametersHashModel(request);
        	request.setAttribute(ATTR_REQUEST_PARAMETERS_MODEL, reqParametersModel);
        }
        model.put(KEY_REQUEST_PARAMETER_MODEL, reqParametersModel);

        return model;
    }

    protected void populateContext(ScopesHashModel model, OgnlValueStack stack, Object action, HttpServletRequest request, HttpServletResponse response) {
        // put the same objects into the context that the velocity result uses
        Map standard = ContextUtil.getStandardContext(stack, request, response);
        model.putAll(standard);

        // support for JSP exception pages, exposing the servlet or JSP exception
        Throwable exception = (Throwable) request.getAttribute("javax.servlet.error.exception");

        if (exception == null) {
            exception = (Throwable) request.getAttribute("javax.servlet.error.JspException");
        }

        if (exception != null) {
            model.put(KEY_EXCEPTION, exception);
        }
    }

    protected BeansWrapper getObjectWrapper() {
        return new StrutsBeanWrapper();
    }

    /**
     * The default template loader is a MultiTemplateLoader which includes
     * a ClassTemplateLoader and a WebappTemplateLoader (and a FileTemplateLoader depending on
     * the init-parameter 'TemplatePath').
     * <p/>
     * The ClassTemplateLoader will resolve fully qualified template includes
     * that begin with a slash. for example /com/company/template/common.ftl
     * <p/>
     * The WebappTemplateLoader attempts to resolve templates relative to the web root folder
     */
    protected TemplateLoader getTemplateLoader(ServletContext servletContext) {
        // construct a FileTemplateLoader for the init-param 'TemplatePath'
        FileTemplateLoader templatePathLoader = null;

        String templatePath = servletContext.getInitParameter("TemplatePath");
        if (templatePath == null) {
            templatePath = servletContext.getInitParameter("templatePath");
        }

        if (templatePath != null) {
            try {
                templatePathLoader = new FileTemplateLoader(new File(templatePath));
            } catch (IOException e) {
                log.error("Invalid template path specified: " + e.getMessage(), e);
            }
        }

        // presume that most apps will require the class and webapp template loader
        // if people wish to
        return templatePathLoader != null ?
                new MultiTemplateLoader(new TemplateLoader[]{
                        templatePathLoader,
                        new WebappTemplateLoader(servletContext),
                        new StrutsClassTemplateLoader()
                })
                : new MultiTemplateLoader(new TemplateLoader[]{
                new WebappTemplateLoader(servletContext),
                new StrutsClassTemplateLoader()
        });
    }

    /**
     * Create the instance of the freemarker Configuration object.
     * <p/>
     * this implementation
     * <ul>
     * <li>obtains the default configuration from Configuration.getDefaultConfiguration()
     * <li>sets up template loading from a ClassTemplateLoader and a WebappTemplateLoader
     * <li>sets up the object wrapper to be the BeansWrapper
     * <li>loads settings from the classpath file /freemarker.properties
     * </ul>
     *
     * @param servletContext
     */
    protected freemarker.template.Configuration createConfiguration(ServletContext servletContext) throws TemplateException {
    	freemarker.template.Configuration configuration = new freemarker.template.Configuration();

        configuration.setTemplateLoader(getTemplateLoader(servletContext));

        configuration.setTemplateExceptionHandler(TemplateExceptionHandler.HTML_DEBUG_HANDLER);

        configuration.setObjectWrapper(getObjectWrapper());

        if (Settings.isSet(StrutsConstants.STRUTS_I18N_ENCODING)) {
        	configuration.setDefaultEncoding(Settings.get(StrutsConstants.STRUTS_I18N_ENCODING));
        }

        loadSettings(servletContext, configuration);

        return configuration;
    }

    /**
     * Load the settings from the /freemarker.properties file on the classpath
     *
     * @see freemarker.template.Configuration#setSettings for the definition of valid settings
     */
    protected void loadSettings(ServletContext servletContext, freemarker.template.Configuration configuration) {
        try {
            InputStream in = FileManager.loadFile("freemarker.properties", FreemarkerManager.class);

            if (in != null) {
                Properties p = new Properties();
                p.load(in);
                configuration.setSettings(p);
            }
        } catch (IOException e) {
            log.error("Error while loading freemarker settings from /freemarker.properties", e);
        } catch (TemplateException e) {
            log.error("Error while loading freemarker settings from /freemarker.properties", e);
        }
    }

    public SimpleHash buildTemplateModel(OgnlValueStack stack, Object action, ServletContext servletContext, HttpServletRequest request, HttpServletResponse response, ObjectWrapper wrapper) {
        ScopesHashModel model = buildScopesHashModel(servletContext, request, response, wrapper, stack);
        populateContext(model, stack, action, request, response);
        model.put("s", new StrutsModels(stack, request, response));
        return model;
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/FreemarkerResult.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker;

import java.io.IOException;
import java.io.Writer;
import java.util.Locale;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.ServletActionContext;
import org.apache.struts2.dispatcher.StrutsResultSupport;
import org.apache.struts2.views.util.ResourceUtil;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.LocaleProvider;
import com.opensymphony.xwork2.util.OgnlValueStack;

import freemarker.template.Configuration;
import freemarker.template.ObjectWrapper;
import freemarker.template.Template;
import freemarker.template.TemplateException;
import freemarker.template.TemplateModel;
import freemarker.template.TemplateModelException;


/**
 * <!-- START SNIPPET: description -->
 *
 * Renders a view using the Freemarker template engine. 
 * <p>
 * The FreemarkarManager class configures the template loaders so that the
 * template location can be either
 * </p>
 *
 * <ul>
 *
 * <li>relative to the web root folder. eg <code>/WEB-INF/views/home.ftl</code>
 * </li>
 * 
 * <li>a classpath resuorce. eg <code>com/company/web/views/home.ftl</code></li>
 *
 * </ul>
 *
 * <!-- END SNIPPET: description -->
 *
 * <b>This result type takes the following parameters:</b>
 *
 * <!-- START SNIPPET: params -->
 *
 * <ul>
 *
 * <li><b>location (default)</b> - the location of the template to process.</li>
 *
 * <li><b>parse</b> - true by default. If set to false, the location param will 
 * not be parsed for Ognl expressions.</li>
 *
 * <li><b>contentType</b> - defaults to "text/html" unless specified.</li>
 *
 * </ul>
 *
 * <!-- END SNIPPET: params -->
 *
 * <b>Example:</b>
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * 
 * &lt;result name="success" type="freemarker"&gt;foo.ftl&lt;/result&gt;
 * 
 * <!-- END SNIPPET: example -->
 * </pre>
 */
public class FreemarkerResult extends StrutsResultSupport {

	private static final long serialVersionUID = -3778230771704661631L;
	
	protected ActionInvocation invocation;
    protected Configuration configuration;
    protected ObjectWrapper wrapper;

    /*
     * Struts results are constructed for each result execution
     *
     * the current context is availible to subclasses via these protected fields
     */
    protected String location;
    private String pContentType = "text/html";


    public void setContentType(String aContentType) {
        pContentType = aContentType;
    }

    /**
     * allow parameterization of the contentType
     * the default being text/html
     */
    public String getContentType() {
        return pContentType;
    }

    /**
     * Execute this result, using the specified template location.
     * <p/>
     * The template location has already been interoplated for any variable substitutions
     * <p/>
     * this method obtains the freemarker configuration and the object wrapper from the provided hooks.
     * It them implements the template processing workflow by calling the hooks for
     * preTemplateProcess and postTemplateProcess
     */
    public void doExecute(String location, ActionInvocation invocation) throws IOException, TemplateException {
        this.location = location;
        this.invocation = invocation;
        this.configuration = getConfiguration();
        this.wrapper = getObjectWrapper();

        if (!location.startsWith("/")) {
            ActionContext ctx = invocation.getInvocationContext();
            HttpServletRequest req = (HttpServletRequest) ctx.get(ServletActionContext.HTTP_REQUEST);
            String base = ResourceUtil.getResourceBase(req);
            location = base + "/" + location;
        }
        
        Template template = configuration.getTemplate(location, deduceLocale());
        TemplateModel model = createModel();

        // Give subclasses a chance to hook into preprocessing
        if (preTemplateProcess(template, model)) {
            try {
                // Process the template
                template.process(model, getWriter());
            } finally {
                // Give subclasses a chance to hook into postprocessing
                postTemplateProcess(template, model);
            }
        }
    }

    /**
     * This method is called from {@link #doExecute(String, ActionInvocation)} to obtain the
     * FreeMarker configuration object that this result will use for template loading. This is a
     * hook that allows you to custom-configure the configuration object in a subclass, or to fetch
     * it from an IoC container.
     * <p/>
     * <b>
     * The default implementation obtains the configuration from the ConfigurationManager instance.
     * </b>
     */
    protected Configuration getConfiguration() throws TemplateException {
        return FreemarkerManager.getInstance().getConfiguration(ServletActionContext.getServletContext());
    }

    /**
     * This method is called from {@link #doExecute(String, ActionInvocation)}  to obtain the
     * FreeMarker object wrapper object that this result will use for adapting objects into template
     * models. This is a hook that allows you to custom-configure the wrapper object in a subclass.
     * <p/>
     * <b>
     * The default implementation returns {@link Configuration#getObjectWrapper()}
     * </b>
     */
    protected ObjectWrapper getObjectWrapper() {
        return configuration.getObjectWrapper();
    }

    /**
     * The default writer writes directly to the response writer.
     */
    protected Writer getWriter() throws IOException {
        return ServletActionContext.getResponse().getWriter();
    }

    /**
     * Build the instance of the ScopesHashModel, including JspTagLib support
     * <p/>
     * Objects added to the model are
     * <p/>
     * <ul>
     * <li>Application - servlet context attributes hash model
     * <li>JspTaglibs - jsp tag lib factory model
     * <li>Request - request attributes hash model
     * <li>Session - session attributes hash model
     * <li>request - the HttpServletRequst object for direct access
     * <li>response - the HttpServletResponse object for direct access
     * <li>stack - the OgnLValueStack instance for direct access
     * <li>ognl - the instance of the OgnlTool
     * <li>action - the action itself
     * <li>exception - optional : the JSP or Servlet exception as per the servlet spec (for JSP Exception pages)
     * <li>struts - instance of the StrutsUtil class
     * </ul>
     */
    protected TemplateModel createModel() throws TemplateModelException {
        ServletContext servletContext = ServletActionContext.getServletContext();
        HttpServletRequest request = ServletActionContext.getRequest();
        HttpServletResponse response = ServletActionContext.getResponse();
        OgnlValueStack stack = ServletActionContext.getContext().getValueStack();

        Object action = null;
        if(invocation!= null ) action = invocation.getAction(); //Added for NullPointException
        return FreemarkerManager.getInstance().buildTemplateModel(stack, action, servletContext, request, response, wrapper);
    }

    /**
     * Returns the locale used for the {@link Configuration#getTemplate(String, Locale)} call. The base implementation
     * simply returns the locale setting of the action (assuming the action implements {@link LocaleProvider}) or, if
     * the action does not the configuration's locale is returned. Override this method to provide different behaviour,
     */
    protected Locale deduceLocale() {
        if (invocation.getAction() instanceof LocaleProvider) {
            return ((LocaleProvider) invocation.getAction()).getLocale();
        } else {
            return configuration.getLocale();
        }
    }

    /**
     * the default implementation of postTemplateProcess applies the contentType parameter
     */
    protected void postTemplateProcess(Template template, TemplateModel data) throws IOException {
    }

    /**
     * Called before the execution is passed to template.process().
     * This is a generic hook you might use in subclasses to perform a specific
     * action before the template is processed. By default does nothing.
     * A typical action to perform here is to inject application-specific
     * objects into the model root
     *
     * @return true to process the template, false to suppress template processing.
     */
    protected boolean preTemplateProcess(Template template, TemplateModel model) throws IOException {
        Object attrContentType = template.getCustomAttribute("content_type");

        if (attrContentType != null) {
            ServletActionContext.getResponse().setContentType(attrContentType.toString());
        } else {
            String contentType = getContentType();

            if (contentType == null) {
                contentType = "text/html";
            }

            String encoding = template.getEncoding();

            if (encoding != null) {
                contentType = contentType + "; charset=" + encoding;
            }

            ServletActionContext.getResponse().setContentType(contentType);
        }

        return true;
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/PortletFreemarkerResult.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker;

import java.io.IOException;
import java.io.Writer;
import java.util.Locale;

import javax.portlet.ActionResponse;
import javax.portlet.PortletException;
import javax.portlet.PortletRequestDispatcher;
import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.ServletActionContext;
import org.apache.struts2.dispatcher.StrutsResultSupport;
import org.apache.struts2.portlet.PortletActionConstants;
import org.apache.struts2.portlet.context.PortletActionContext;
import org.apache.struts2.views.util.ResourceUtil;

import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.util.OgnlValueStack;

import freemarker.template.Configuration;
import freemarker.template.ObjectWrapper;
import freemarker.template.Template;
import freemarker.template.TemplateException;
import freemarker.template.TemplateModel;
import freemarker.template.TemplateModelException;

/**
 */
public class PortletFreemarkerResult extends StrutsResultSupport {

	private static final long serialVersionUID = -5570612389289887543L;

	protected ActionInvocation invocation;

    protected Configuration configuration;

    protected ObjectWrapper wrapper;

    /*
     * Struts results are constructed for each result execeution
     * 
     * the current context is availible to subclasses via these protected fields
     */
    protected String location;

    private String pContentType = "text/html";

    public void setContentType(String aContentType) {
        pContentType = aContentType;
    }

    /**
     * allow parameterization of the contentType the default being text/html
     */
    public String getContentType() {
        return pContentType;
    }

    /**
     * Execute this result, using the specified template location. <p/>The
     * template location has already been interoplated for any variable
     * substitutions <p/>this method obtains the freemarker configuration and
     * the object wrapper from the provided hooks. It them implements the
     * template processing workflow by calling the hooks for preTemplateProcess
     * and postTemplateProcess
     */
    public void doExecute(String location, ActionInvocation invocation)
            throws IOException, TemplateException, PortletException {
        if (PortletActionContext.isEvent()) {
            executeActionResult(location, invocation);
        } else if (PortletActionContext.isRender()) {
            executeRenderResult(location, invocation);
        }
    }

    /**
     * @param location
     * @param invocation
     */
    private void executeActionResult(String location,
                                     ActionInvocation invocation) {
        ActionResponse res = PortletActionContext.getActionResponse();
        // View is rendered outside an action...uh oh...
        res.setRenderParameter(PortletActionConstants.ACTION_PARAM, "freemarkerDirect");
        res.setRenderParameter("location", location);
        res.setRenderParameter(PortletActionConstants.MODE_PARAM, PortletActionContext
                .getRequest().getPortletMode().toString());

    }

    /**
     * @param location
     * @param invocation
     * @throws TemplateException
     * @throws IOException
     * @throws TemplateModelException
     */
    private void executeRenderResult(String location,
                                     ActionInvocation invocation) throws TemplateException, IOException,
            TemplateModelException, PortletException {
        prepareServletActionContext();
        this.location = location;
        this.invocation = invocation;
        this.configuration = getConfiguration();
        this.wrapper = getObjectWrapper();

        HttpServletRequest req = ServletActionContext.getRequest();

        if (!location.startsWith("/")) {
            String base = ResourceUtil.getResourceBase(req);
            location = base + "/" + location;
        }

        Template template = configuration.getTemplate(location, deduceLocale());
        TemplateModel model = createModel();
        // Give subclasses a chance to hook into preprocessing
        if (preTemplateProcess(template, model)) {
            try {
                // Process the template
                PortletActionContext.getRenderResponse().setContentType(pContentType);
                template.process(model, getWriter());
            } finally {
                // Give subclasses a chance to hook into postprocessing
                postTemplateProcess(template, model);
            }
        }
    }

    /**
     *  
     */
    private void prepareServletActionContext() throws PortletException,
            IOException {
        PortletRequestDispatcher disp = PortletActionContext.getPortletConfig()
                .getPortletContext().getNamedDispatcher("preparator");
        disp.include(PortletActionContext.getRenderRequest(),
                PortletActionContext.getRenderResponse());
    }

    /**
     * This method is called from {@link #doExecute(String, ActionInvocation)}
     * to obtain the FreeMarker configuration object that this result will use
     * for template loading. This is a hook that allows you to custom-configure
     * the configuration object in a subclass, or to fetch it from an IoC
     * container. <p/><b>The default implementation obtains the configuration
     * from the ConfigurationManager instance. </b>
     */
    protected Configuration getConfiguration() throws TemplateException {
        return FreemarkerManager.getInstance().getConfiguration(
                ServletActionContext.getServletContext());
    }

    /**
     * This method is called from {@link #doExecute(String, ActionInvocation)}
     * to obtain the FreeMarker object wrapper object that this result will use
     * for adapting objects into template models. This is a hook that allows you
     * to custom-configure the wrapper object in a subclass. <p/><b>The default
     * implementation returns {@link Configuration#getObjectWrapper()}</b>
     */
    protected ObjectWrapper getObjectWrapper() {
        return configuration.getObjectWrapper();
    }

    /**
     * The default writer writes directly to the response writer.
     */
    protected Writer getWriter() throws IOException {
        return PortletActionContext.getRenderResponse().getWriter();
    }

    /**
     * Build the instance of the ScopesHashModel, including JspTagLib support
     * <p/>Objects added to the model are <p/>
     * <ul>
     * <li>Application - servlet context attributes hash model
     * <li>JspTaglibs - jsp tag lib factory model
     * <li>Request - request attributes hash model
     * <li>Session - session attributes hash model
     * <li>request - the HttpServletRequst object for direct access
     * <li>response - the HttpServletResponse object for direct access
     * <li>stack - the OgnLValueStack instance for direct access
     * <li>ognl - the instance of the OgnlTool
     * <li>action - the action itself
     * <li>exception - optional : the JSP or Servlet exception as per the
     * servlet spec (for JSP Exception pages)
     * <li>struts - instance of the StrutsUtil class
     * </ul>
     */
    protected TemplateModel createModel() throws TemplateModelException {
        ServletContext servletContext = ServletActionContext
                .getServletContext();
        HttpServletRequest request = ServletActionContext.getRequest();
        HttpServletResponse response = ServletActionContext.getResponse();
        OgnlValueStack stack = ServletActionContext.getContext()
                .getValueStack();
        return FreemarkerManager.getInstance().buildTemplateModel(stack,
                invocation.getAction(), servletContext, request, response,
                wrapper);
    }

    /**
     * Returns the locale used for the
     * {@link Configuration#getTemplate(String, Locale)}call. The base
     * implementation simply returns the locale setting of the configuration.
     * Override this method to provide different behaviour,
     */
    protected Locale deduceLocale() {
        return configuration.getLocale();
    }

    /**
     * the default implementation of postTemplateProcess applies the contentType
     * parameter
     */
    protected void postTemplateProcess(Template template, TemplateModel data)
            throws IOException {
    }

    /**
     * Called before the execution is passed to template.process(). This is a
     * generic hook you might use in subclasses to perform a specific action
     * before the template is processed. By default does nothing. A typical
     * action to perform here is to inject application-specific objects into the
     * model root
     *
     * @return true to process the template, false to suppress template
     *         processing.
     */
    protected boolean preTemplateProcess(Template template, TemplateModel model)
            throws IOException {
        Object attrContentType = template.getCustomAttribute("content_type");

        if (attrContentType != null) {
            ServletActionContext.getResponse().setContentType(
                    attrContentType.toString());
        } else {
            String contentType = getContentType();

            if (contentType == null) {
                contentType = "text/html";
            }

            String encoding = template.getEncoding();

            if (encoding != null) {
                contentType = contentType + "; charset=" + encoding;
            }

            ServletActionContext.getResponse().setContentType(contentType);
        }

        return true;
    }
}

"
core/src/main/java/org/apache/struts2/views/freemarker/ScopesHashModel.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;

import com.opensymphony.xwork2.util.OgnlValueStack;

import freemarker.template.ObjectWrapper;
import freemarker.template.SimpleHash;
import freemarker.template.TemplateModel;
import freemarker.template.TemplateModelException;


/**
 * Simple Hash model that also searches other scopes.
 * <p/>
 * If the key doesn't exist in this hash, this template model tries to
 * resolve the key within the attributes of the following scopes,
 * in the order stated: Request, Session, Servlet Context
 */
public class ScopesHashModel extends SimpleHash {

	private static final long serialVersionUID = 5551686380141886764L;
	
	private HttpServletRequest request;
    private ServletContext servletContext;
    private OgnlValueStack stack;


    public ScopesHashModel(ObjectWrapper objectWrapper, ServletContext context, HttpServletRequest request, OgnlValueStack stack) {
        super(objectWrapper);
        this.servletContext = context;
        this.request = request;
        this.stack = stack;
    }


    public TemplateModel get(String key) throws TemplateModelException {
        // Lookup in default scope
        TemplateModel model = super.get(key);

        if (model != null) {
            return model;
        }


        if (stack != null) {
            Object obj = stack.findValue(key);

            if (obj != null) {
                return wrap(obj);
            }

            // ok, then try the context
            obj = stack.getContext().get(key);
            if (obj != null) {
                return wrap(obj);
            }
        }

        if (request != null) {
            // Lookup in request scope
            Object obj = request.getAttribute(key);

            if (obj != null) {
                return wrap(obj);
            }

            // Lookup in session scope
            HttpSession session = request.getSession(false);

            if (session != null) {
                obj = session.getAttribute(key);

                if (obj != null) {
                    return wrap(obj);
                }
            }
        }

        if (servletContext != null) {
            // Lookup in application scope
            Object obj = servletContext.getAttribute(key);

            if (obj != null) {
                return wrap(obj);
            }
        }

        return null;
    }

    public void put(String string, boolean b) {
        super.put(string, b);
    }

    public void put(String string, Object object) {
        super.put(string, object);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/StrutsBeanWrapper.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker;

import java.util.Map;
import java.util.Set;

import freemarker.core.CollectionAndSequence;
import freemarker.ext.beans.BeansWrapper;
import freemarker.ext.beans.MapModel;
import freemarker.ext.util.ModelFactory;
import freemarker.template.ObjectWrapper;
import freemarker.template.SimpleSequence;
import freemarker.template.TemplateBooleanModel;
import freemarker.template.TemplateCollectionModel;
import freemarker.template.TemplateHashModelEx;
import freemarker.template.TemplateModel;
import freemarker.template.TemplateModelException;

/**
 * <!-- START SNIPPET: javadoc -->
 *
 * The StrutsBeanWrapper extends the default FreeMarker BeansWrapper and provides almost no change in functionality,
 * <b>except</b> for how it handles maps. Normally, FreeMarker has two modes of operation: either support for friendly
 * map built-ins (?keys, ?values, etc) but only support for String keys; OR no special built-in support (ie: ?keys
 * returns the methods on the map instead of the keys) but support for String and non-String keys alike. Struts
 * provides an alternative implementation that gives us the best of both worlds.
 *
 * <p/> It is possible that this special behavior may be confusing or can cause problems. Therefore, you can set the
 * <b>struts.freemarker.wrapper.altMap</b> property in struts.properties to false, allowing the normal BeansWrapper
 * logic to take place instead.
 *
 * <!-- END SNIPPET: javadoc -->
 */
public class StrutsBeanWrapper extends BeansWrapper {
    private static final boolean altMapWrapper
            = "true".equals(org.apache.struts2.config.Settings.get("struts.freemarker.wrapper.altMap"));

    public TemplateModel wrap(Object object) throws TemplateModelException {
        if (object instanceof TemplateBooleanModel) {
            return super.wrap(object);
        }

        // attempt to get the best of both the SimpleMapModel and the MapModel of FM.
        if (altMapWrapper && object instanceof Map) {
            return getInstance(object, FriendlyMapModel.FACTORY);
        }

        return super.wrap(object);
    }

    /**
     * Attempting to get the best of both worlds of FM's MapModel and SimpleMapModel, by reimplementing the isEmpty(),
     * keySet() and values() methods. ?keys and ?values built-ins are thus available, just as well as plain Map
     * methods.
     */
    private final static class FriendlyMapModel extends MapModel implements TemplateHashModelEx {
        static final ModelFactory FACTORY = new ModelFactory() {
            public TemplateModel create(Object object, ObjectWrapper wrapper) {
                return new FriendlyMapModel((Map) object, (BeansWrapper) wrapper);
            }
        };

        public FriendlyMapModel(Map map, BeansWrapper wrapper) {
            super(map, wrapper);
        }

        public boolean isEmpty() {
            return ((Map) object).isEmpty();
        }

        protected Set keySet() {
            return ((Map) object).keySet();
        }

        public TemplateCollectionModel values() {
            return new CollectionAndSequence(new SimpleSequence(((Map) object).values(), wrapper));
        }
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/StrutsClassTemplateLoader.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker;

import java.net.URL;

import com.opensymphony.xwork2.util.ClassLoaderUtil;

import freemarker.cache.URLTemplateLoader;

/**
 */
public class StrutsClassTemplateLoader extends URLTemplateLoader {
    protected URL getURL(String name) {
        return ClassLoaderUtil.getResource(name, getClass());
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/ActionErrorModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.ActionError;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see ActionError
 */
public class ActionErrorModel extends TagModel {
    public ActionErrorModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new ActionError(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/ActionMessageModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.ActionMessage;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see ActionMessage
 */
public class ActionMessageModel extends TagModel {
    public ActionMessageModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new ActionMessage(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/ActionModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.ActionComponent;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see ActionComponent
 */
public class ActionModel extends TagModel {
    public ActionModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new ActionComponent(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/AnchorModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Anchor;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Anchor
 */
public class AnchorModel extends TagModel {
    public AnchorModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new Anchor(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/BeanModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Bean;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Bean
 */
public class BeanModel extends TagModel {
    public BeanModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new Bean(stack);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/CallbackWriter.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import java.io.IOException;
import java.io.StringWriter;
import java.io.Writer;

import org.apache.struts2.components.Component;

import freemarker.template.TemplateModelException;
import freemarker.template.TransformControl;

/**
 */
public class CallbackWriter extends Writer implements TransformControl {
    private Component bean;
    private Writer writer;
    private StringWriter body;
    private boolean afterBody = false;

    public CallbackWriter(Component bean, Writer writer) {
        this.bean = bean;
        this.writer = writer;

        if (bean.usesBody()) {
            this.body = new StringWriter();
        }
    }

    public void close() throws IOException {
        if (bean.usesBody()) {
            body.close();
        }
    }

    public void flush() throws IOException {
        writer.flush();

        if (bean.usesBody()) {
            body.flush();
        }
    }

    public void write(char cbuf[], int off, int len) throws IOException {
        if (bean.usesBody() && !afterBody) {
            body.write(cbuf, off, len);
        } else {
            writer.write(cbuf, off, len);
        }
    }

    public int onStart() throws TemplateModelException, IOException {
        boolean result = bean.start(this);

        if (result) {
            return EVALUATE_BODY;
        } else {
            return SKIP_BODY;
        }
    }

    public int afterBody() throws TemplateModelException, IOException {
        afterBody = true;
        boolean result = bean.end(this, bean.usesBody() ? body.toString() : "");

        if (result) {
            return REPEAT_EVALUATION;
        } else {
            return END_EVALUATION;
        }
    }

    public void onError(Throwable throwable) throws Throwable {
        throw throwable;
    }

    public Component getBean() {
        return bean;
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/CheckboxListModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.CheckboxList;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see CheckboxList
 */
public class CheckboxListModel extends TagModel {
    public CheckboxListModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new CheckboxList(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/CheckboxModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Checkbox;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Checkbox
 */
public class CheckboxModel extends TagModel {
    public CheckboxModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new Checkbox(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/ComboBoxModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.ComboBox;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see ComboBox
 */
public class ComboBoxModel extends TagModel {
    public ComboBoxModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new ComboBox(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/ComponentModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.GenericUIBean;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see ComponentModel
 */
public class ComponentModel extends TagModel {
    public ComponentModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new GenericUIBean(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/DateModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Date;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <code>DateModel</code>
 *
 */
public class DateModel extends TagModel {

    public DateModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new Date(stack);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/DatePickerModel.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.DatePicker;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see DatePicker
 */
public class DatePickerModel extends TextFieldModel {
    public DatePickerModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new DatePicker(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/DivModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Div;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Div
 */
public class DivModel extends TagModel {
    public DivModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new Div(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/DoubleSelectModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.DoubleSelect;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see DoubleSelect
 */
public class DoubleSelectModel extends TagModel {
    public DoubleSelectModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new DoubleSelect(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/ElseIfModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.ElseIf;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @version $Date$ $Id$
 */
public class ElseIfModel extends TagModel {

	public ElseIfModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
		super(stack, req, res);
	}

	protected Component getBean() {
		return new ElseIf(stack);
	}
	
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/ElseModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Else;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * 
 * @version $Date$ $Id$
 */
public class ElseModel extends TagModel {

	public ElseModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
		super(stack, req, res);
	}

	protected Component getBean() {
		return new Else(stack);
	}

}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/FieldErrorModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.FieldError;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see FieldError
 */
public class FieldErrorModel extends TagModel {
    public FieldErrorModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new FieldError(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/FileModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.File;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see File
 */
public class FileModel extends TagModel {
    public FileModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new File(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/FormModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Form;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Form
 */
public class FormModel extends TagModel {
    public FormModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new Form(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/HeadModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Head;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Head
 */
public class HeadModel extends TagModel {
    public HeadModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new Head(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/HiddenModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Hidden;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Hidden
 */
public class HiddenModel extends TagModel {
    public HiddenModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new Hidden(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/I18nModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.I18n;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see I18n
 */
public class I18nModel extends TagModel {
    public I18nModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new I18n(stack);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/IfModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.If;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @version $Date$ $Id$
 */
public class IfModel extends TagModel {

	
	public IfModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
		super(stack, req, res);
	}

	protected Component getBean() {
		return new If(stack);
	}
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/IncludeModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Include;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Include
 */
public class IncludeModel extends TagModel {
    public IncludeModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new Include(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/IteratorModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.IteratorComponent;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see IteratorComponent
 */
public class IteratorModel extends TagModel {
    public IteratorModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new IteratorComponent(stack);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/LabelModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Label;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Label
 */
public class LabelModel extends TagModel {
    public LabelModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new Label(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/OptGroupModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.OptGroup;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * Freemarker's TransformModel for OptGroup component.
 *
 */
public class OptGroupModel extends TagModel {
	public OptGroupModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
		super(stack, req, res);
	}

	protected Component getBean() {
		return new OptGroup(stack, req, res);
	}
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/OptionTransferSelectModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.OptionTransferSelect;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see OptionTransferSelect
 */
public class OptionTransferSelectModel extends TagModel {

	public OptionTransferSelectModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
		super(stack, req, res);
	}

	protected Component getBean() {
		return new OptionTransferSelect(stack, req, res);
	}

}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/PanelModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Panel;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Panel
 */
public class PanelModel extends TagModel {
    public PanelModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new Panel(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/ParamModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Param;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Param
 */
public class ParamModel extends TagModel {
    public ParamModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new Param(stack);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/PasswordModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Password;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Password
 */
public class PasswordModel extends TagModel {
    public PasswordModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new Password(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/PropertyModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Property;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Property
 */
public class PropertyModel extends TagModel {
    public PropertyModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new Property(stack);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/PushModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Push;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Push
 */
public class PushModel extends TagModel {
    public PushModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new Push(stack);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/RadioModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Radio;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Radio
 */
public class RadioModel extends TagModel {
    public RadioModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new Radio(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/ResetModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Reset;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see org.apache.struts2.components.Reset
 */
public class ResetModel extends TagModel {
    public ResetModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new Reset(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/SelectModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Select;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Select
 */
public class SelectModel extends TagModel {
    public SelectModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new Select(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/SetModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Set;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Set
 */
public class SetModel extends TagModel {
    public SetModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new Set(stack);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/StrutsModels.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * Provides @s.tag access for various tags.
 *
 */
public class StrutsModels {
    protected OgnlValueStack stack;
    protected HttpServletRequest req;
    protected HttpServletResponse res;

    protected ActionModel action;
    protected BeanModel bean;
    protected CheckboxModel checkbox;
    protected CheckboxListModel checkboxlist;
    protected ComboBoxModel comboBox;
    protected ComponentModel component;
    protected DateModel date;
    protected DatePickerModel datepicker;
    protected DivModel div;
    protected DoubleSelectModel doubleselect;
    protected FileModel file;
    protected FormModel form;
    protected HeadModel head;
    protected HiddenModel hidden;
    protected AnchorModel a;
    protected I18nModel i18n;
    protected IncludeModel include;
    protected LabelModel label;
    protected PanelModel panel;
    protected PasswordModel password;
    protected PushModel push;
    protected ParamModel param;
    protected RadioModel radio;
    protected SelectModel select;
    protected SetModel set;
    protected SubmitModel submit;
    protected ResetModel reset;
    protected TabbedPanelModel tabbedPanel;
    protected TextAreaModel textarea;
    protected TextModel text;
    protected TextFieldModel textfield;
    protected TokenModel token;
    protected URLModel url;
    protected WebTableModel table;
    protected PropertyModel property;
    protected IteratorModel iterator;
    protected ActionErrorModel actionerror;
    protected ActionMessageModel actionmessage;
    protected FieldErrorModel fielderror;
    protected OptionTransferSelectModel optiontransferselect;
    protected TreeModel treeModel;
    protected UpDownSelectModel updownselect;
    protected OptGroupModel optGroupModel;
    protected IfModel ifModel;
    protected ElseModel elseModel;
    protected ElseIfModel elseIfModel;
    protected TimePickerModel timePickerModel;
    

    public StrutsModels(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        this.stack = stack;
        this.req = req;
        this.res = res;
    }

    public CheckboxListModel getCheckboxlist() {
        if (checkboxlist == null) {
            checkboxlist = new CheckboxListModel(stack, req, res);
        }

        return checkboxlist;
    }

    public CheckboxModel getCheckbox() {
        if (checkbox == null) {
            checkbox = new CheckboxModel(stack, req, res);
        }

        return checkbox;
    }

    public ComboBoxModel getComboBox() {
        if (comboBox == null) {
            comboBox = new ComboBoxModel(stack, req, res);
        }

        return comboBox;
    }

    public ComponentModel getComponent() {
        if (component == null) {
            component = new ComponentModel(stack, req, res);
        }

        return component;
    }

    public DoubleSelectModel getDoubleselect() {
        if (doubleselect == null) {
            doubleselect = new DoubleSelectModel(stack, req, res);
        }

        return doubleselect;
    }

    public FileModel getFile() {
        if (file == null) {
            file = new FileModel(stack, req, res);
        }

        return file;
    }

    public FormModel getForm() {
        if (form == null) {
            form = new FormModel(stack, req, res);
        }

        return form;
    }

    public HeadModel getHead() {
        if (head == null) {
            head = new HeadModel(stack, req, res);
        }

        return head;
    }

    public HiddenModel getHidden() {
        if (hidden == null) {
            hidden = new HiddenModel(stack, req, res);
        }

        return hidden;
    }
    public LabelModel getLabel() {
        if (label == null) {
            label = new LabelModel(stack, req, res);
        }

        return label;
    }

    public PasswordModel getPassword() {
        if (password == null) {
            password = new PasswordModel(stack, req, res);
        }

        return password;
    }

    public RadioModel getRadio() {
        if (radio == null) {
            radio = new RadioModel(stack, req, res);
        }

        return radio;
    }

    public SelectModel getSelect() {
        if (select == null) {
            select = new SelectModel(stack, req, res);
        }

        return select;
    }

    public SubmitModel getSubmit() {
        if (submit == null) {
            submit = new SubmitModel(stack, req, res);
        }

        return submit;
    }

    public ResetModel getReset() {
        if (reset == null) {
            reset = new ResetModel(stack, req, res);
        }

        return reset;
    }

    public TextAreaModel getTextarea() {
        if (textarea == null) {
            textarea = new TextAreaModel(stack, req, res);
        }

        return textarea;
    }

    public TextFieldModel getTextfield() {
        if (textfield == null) {
            textfield = new TextFieldModel(stack, req, res);
        }

        return textfield;
    }

    public DateModel getDate() {
        if (date == null) {
            date = new DateModel(stack, req, res);
        }

        return date;
    }

    public DatePickerModel getDatepicker() {
        if (datepicker == null) {
            datepicker = new DatePickerModel(stack, req, res);
        }

        return datepicker;
    }

    public TokenModel getToken() {
        if (token == null) {
            token = new TokenModel(stack, req, res);
        }

        return token;
    }

    public WebTableModel getTable() {
        if (table == null) {
            table = new WebTableModel(stack, req, res);
        }

        return table;
    }

    public URLModel getUrl() {
        if (url == null) {
            url = new URLModel(stack, req, res);
        }

        return url;
    }

    public IncludeModel getInclude() {
        if (include == null) {
            include = new IncludeModel(stack, req, res);
        }

        return include;
    }

    public ParamModel getParam() {
        if (param == null) {
            param = new ParamModel(stack, req, res);
        }

        return param;
    }

    public ActionModel getAction() {
        if (action == null) {
            action = new ActionModel(stack, req, res);
        }

        return action;
    }

    public AnchorModel getA() {
        if (a == null) {
            a = new AnchorModel(stack, req, res);
        }

        return a;
    }

    public AnchorModel getHref() {
        if (a == null) {
            a = new AnchorModel(stack, req, res);
        }

        return a;
    }

    public DivModel getDiv() {
        if (div == null) {
            div = new DivModel(stack, req, res);
        }

        return div;
    }

    public TextModel getText() {
        if (text == null) {
            text = new TextModel(stack, req, res);
        }

        return text;
    }

    public TabbedPanelModel getTabbedPanel() {
        if (tabbedPanel == null) {
            tabbedPanel = new TabbedPanelModel(stack, req, res);
        }

        return tabbedPanel;
    }

    public PanelModel getPanel() {
        if (panel == null) {
            panel = new PanelModel(stack, req, res);
        }

        return panel;
    }

    public BeanModel getBean() {
        if (bean == null) {
            bean = new BeanModel(stack, req, res);
        }

        return bean;
    }

    public I18nModel getI18n() {
        if (i18n == null) {
            i18n = new I18nModel(stack, req, res);
        }

        return i18n;
    }

    public PushModel getPush() {
        if (push == null) {
            push = new PushModel(stack, req, res);
        }

        return push;
    }

    public SetModel getSet() {
        if (set == null) {
            set = new SetModel(stack, req, res);
        }

        return set;
    }

    public PropertyModel getProperty() {
        if (property == null) {
            property = new PropertyModel(stack, req, res);
        }

        return property;
    }

    public IteratorModel getIterator() {
        if (iterator == null) {
            iterator = new IteratorModel(stack, req, res);
        }

        return iterator;
    }

    public ActionErrorModel getActionerror() {
        if (actionerror == null) {
            actionerror = new ActionErrorModel(stack, req, res);
        }

        return actionerror;
    }

    public ActionMessageModel getActionmessage() {
        if (actionmessage == null) {
            actionmessage = new ActionMessageModel(stack, req, res);
        }

        return actionmessage;
    }

    public FieldErrorModel getFielderror() {
        if (fielderror == null) {
            fielderror = new FieldErrorModel(stack, req, res);
        }

        return fielderror;
    }
    
    public OptionTransferSelectModel getOptiontransferselect() {
    	if (optiontransferselect == null) {
    		optiontransferselect = new OptionTransferSelectModel(stack, req, res);
    	}
    	return optiontransferselect;
    }

    public TreeModel getTree() {
        if (treeModel == null) {
            treeModel = new TreeModel(stack,req, res);
        }
        return treeModel;
    }
    
    public UpDownSelectModel getUpdownselect() {
    	if (updownselect == null)  {
    		updownselect = new UpDownSelectModel(stack, req, res);
    	}
    	return updownselect;
    }
    
    public OptGroupModel getOptgroup() {
    	if (optGroupModel == null) {
    		optGroupModel = new OptGroupModel(stack, req, res);
    	}
    	return optGroupModel;
    }
    
    public IfModel getIf() {
    	if (ifModel == null) {
    		ifModel = new IfModel(stack, req, res);
    	}
    	return ifModel;
    }
    
    public ElseModel getElse() {
    	if (elseModel == null) {
    		elseModel = new ElseModel(stack, req, res);
    	}
    	return elseModel;
    }
    
    public ElseIfModel getElseif() {
    	if (elseIfModel == null) {
    		elseIfModel = new ElseIfModel(stack, req, res);
    	}
    	return elseIfModel;
    }
    
    public TimePickerModel getTimepicker() {
    	if (timePickerModel == null) {
    		timePickerModel = new TimePickerModel(stack, req, res);
    	}
    	return timePickerModel;
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/SubmitModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Submit;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Submit
 */
public class SubmitModel extends TagModel {
    public SubmitModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new Submit(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/TabbedPanelModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.TabbedPanel;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see TabbedPanel
 */
public class TabbedPanelModel extends TagModel {
    public TabbedPanelModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new TabbedPanel(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/TagModel.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import java.io.IOException;
import java.io.Writer;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;

import freemarker.template.SimpleNumber;
import freemarker.template.SimpleSequence;
import freemarker.template.TemplateModelException;
import freemarker.template.TemplateTransformModel;

public abstract class TagModel implements TemplateTransformModel {
    private static final Log LOG = LogFactory.getLog(TagModel.class);

    protected OgnlValueStack stack;
    protected HttpServletRequest req;
    protected HttpServletResponse res;

    public TagModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        this.stack = stack;
        this.req = req;
        this.res = res;
    }

    public Writer getWriter(Writer writer, Map params) throws TemplateModelException, IOException {
        Component bean = getBean();
        Map basicParams = convertParams(params);
        bean.copyParams(basicParams);
        bean.addAllParameters(getComplexParams(params));
        return new CallbackWriter(bean, writer);
    }

    protected abstract Component getBean();

    private Map convertParams(Map params) {
        HashMap map = new HashMap(params.size());
        for (Iterator iterator = params.entrySet().iterator(); iterator.hasNext();) {
            Map.Entry entry = (Map.Entry) iterator.next();
            Object value = entry.getValue();
            if (value != null && !complexType(value)) {
                map.put(entry.getKey(), value.toString());
            }
        }
        return map;
    }

    private Map getComplexParams(Map params) {
        HashMap map = new HashMap(params.size());
        for (Iterator iterator = params.entrySet().iterator(); iterator.hasNext();) {
            Map.Entry entry = (Map.Entry) iterator.next();
            Object value = entry.getValue();
            if (value != null && complexType(value)) {
                if (value instanceof freemarker.ext.beans.BeanModel) {
                    map.put(entry.getKey(), ((freemarker.ext.beans.BeanModel) value).getWrappedObject());
                } else if (value instanceof SimpleNumber) {
                    map.put(entry.getKey(), ((SimpleNumber) value).getAsNumber());
                } else if (value instanceof SimpleSequence) {
                    try {
                        map.put(entry.getKey(), ((SimpleSequence) value).toList());
                    } catch (TemplateModelException e) {
                        LOG.error("There was a problem converting a SimpleSequence to a list", e);
                    }
                }
            }
        }
        return map;
    }

    private boolean complexType(Object value) {
        return value instanceof freemarker.ext.beans.BeanModel
                || value instanceof SimpleNumber
                || value instanceof SimpleSequence;
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/TextAreaModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.TextArea;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see TextArea
 */
public class TextAreaModel extends TagModel {
    public TextAreaModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new TextArea(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/TextFieldModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.TextField;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see TextField
 */
public class TextFieldModel extends TagModel {
    public TextFieldModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new TextField(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/TextModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Text;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Text
 */
public class TextModel extends TagModel {
    public TextModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new Text(stack);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/TimePickerModel.java,true,"package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.TimePicker;

import com.opensymphony.xwork2.util.OgnlValueStack;

public class TimePickerModel extends TagModel {

	public TimePickerModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
		super(stack, req, res);
	}

	protected Component getBean() {
		return new TimePicker(stack, req, res);
	}

}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/TokenModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Token;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Token
 */
public class TokenModel extends TagModel {
    public TokenModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new Token(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/TreeModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Tree;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * TreeModel
 * @see Tree
 *
 */
public class TreeModel extends TagModel {
    public TreeModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new Tree(stack,req,res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/TreeNodeModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.TreeNode;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * TreeNodeModel
 * @see TreeNode
 */
public class TreeNodeModel extends TagModel {
    public TreeNodeModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new TreeNode(stack,req,res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/UpDownSelectModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.UpDownSelect;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see UpDownSelect
 * 
 */
public class UpDownSelectModel extends TagModel {

	public UpDownSelectModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
		super(stack, req, res);
	}

	protected Component getBean() {
		return new UpDownSelect(stack, req, res);
	}

}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/URLModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.URL;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see URL
 */
public class URLModel extends TagModel {
    public URLModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new URL(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/freemarker/tags/WebTableModel.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.freemarker.tags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.table.WebTable;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see WebTable
 */
public class WebTableModel extends TagModel {
    public WebTableModel(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        super(stack, req, res);
    }

    protected Component getBean() {
        return new WebTable(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ActionTag.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.ActionComponent;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see ActionComponent
 */
public class ActionTag extends ComponentTagSupport {
	
	private static final long serialVersionUID = -5384167073331678855L;
	
	protected String name;
    protected String namespace;
    protected boolean executeResult;
    protected boolean ignoreContextParams;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new ActionComponent(stack, req, res);
    }

    protected void populateParams() {
        super.populateParams();

        ActionComponent action = (ActionComponent) component;
        action.setName(name);
        action.setNamespace(namespace);
        action.setExecuteResult(executeResult);
        action.setIgnoreContextParams(ignoreContextParams);
        action.start(pageContext.getOut());
    }

    protected void addParameter(String name, Object value) {
        ActionComponent ac = (ActionComponent) component;
        ac.addParameter(name, value);
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setNamespace(String namespace) {
        this.namespace = namespace;
    }

    public void setExecuteResult(boolean executeResult) {
        this.executeResult = executeResult;
    }

    public void setIgnoreContextParams(boolean ignoreContextParams) {
        this.ignoreContextParams = ignoreContextParams;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/BeanTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.components.Bean;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * @see Bean
 */
public class BeanTag extends ComponentTagSupport {
	
	private static final long serialVersionUID = -3863152522071209267L;

	protected static Log log = LogFactory.getLog(BeanTag.class);

    protected String name;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Bean(stack);
    }

    protected void populateParams() {
        super.populateParams();

        ((Bean) component).setName(name);
    }

    public void setName(String name) {
        this.name = name;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ComponentTagSupport.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.jsp.JspException;

import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 */
public abstract class ComponentTagSupport extends StrutsBodyTagSupport {
    protected Component component;

    public abstract Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res);

    public int doEndTag() throws JspException {
        component.end(pageContext.getOut(), getBody());
        component = null;
        return EVAL_PAGE;
    }

    public int doStartTag() throws JspException {
        component = getBean(getStack(), (HttpServletRequest) pageContext.getRequest(), (HttpServletResponse) pageContext.getResponse());
        populateParams();
        boolean evalBody = component.start(pageContext.getOut());

        if (evalBody) {
            return component.usesBody() ? EVAL_BODY_BUFFERED : EVAL_BODY_INCLUDE;
        } else {
            return SKIP_BODY;
        }
    }

    protected void populateParams() {
        component.setId(id);
    }

    public Component getComponent() {
        return component;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/DateTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Date;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Date
 */
public class DateTag extends ComponentTagSupport {

	private static final long serialVersionUID = -6216963123295613440L;
	
	protected String name;
    protected String format;
    protected boolean nice;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Date(stack);
    }

    protected void populateParams() {
        super.populateParams();
        Date d = (Date)component;
        d.setName(name);
        d.setFormat(format);
        d.setNice(nice);

    }

    public void setFormat(String format) {
        this.format = format;
    }

    public void setNice(boolean nice) {
        this.nice = nice;
    }

    public void setName(String name) {
        this.name = name;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ElseIfTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.ElseIf;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see ElseIf
 */
public class ElseIfTag extends ComponentTagSupport {
	
	private static final long serialVersionUID = -3872016920741400345L;
	
	protected String test;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new ElseIf(stack);
    }

    protected void populateParams() {
        ((ElseIf) getComponent()).setTest(test);
    }

    public void setTest(String test) {
        this.test = test;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ElseTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Else;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * @see Else
 */
public class ElseTag extends ComponentTagSupport {
	
	private static final long serialVersionUID = 8166807953193406785L;

	public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Else(stack);
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/I18nTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.I18n;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * @see I18n
 */
public class I18nTag extends ComponentTagSupport {
	
	private static final long serialVersionUID = -7914587341936116887L;
	
	protected String name;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new I18n(stack);
    }

    protected void populateParams() {
        super.populateParams();

        ((I18n) component).setName(name);
    }

    public void setName(String name) {
        this.name = name;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/IfTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.If;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * @see If
 */
public class IfTag extends ComponentTagSupport {
	
	private static final long serialVersionUID = 4448870162549923833L;
	
	String test;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new If(stack);
    }

    protected void populateParams() {
        ((If) getComponent()).setTest(test);
    }

    public void setTest(String test) {
        this.test = test;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/IncludeTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Include;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * @see Include
 */
public class IncludeTag extends ComponentTagSupport {
	
	private static final long serialVersionUID = -1585165567043278243L;
	
	protected String value;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Include(stack, req, res);
    }

    protected void populateParams() {
        super.populateParams();

        ((Include) component).setValue(value);
    }

    public void setValue(String value) {
        this.value = value;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/IteratorStatus.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp;


/**
 * The iterator tag can export an IteratorStatus object so that
 * one can get information about the status of the iteration, such as
 * the size, current index, and whether any more items are available.
 *
 */
public class IteratorStatus {
    protected StatusState state;

    public IteratorStatus(StatusState aState) {
        state = aState;
    }

    public int getCount() {
        return state.index + 1;
    }

    public boolean isEven() {
        return ((state.index + 1) % 2) == 0;
    }

    public boolean isFirst() {
        return state.index == 0;
    }

    public int getIndex() {
        return state.index;
    }

    public boolean isLast() {
        return state.last;
    }

    public boolean isOdd() {
        return ((state.index + 1) % 2) == 1;
    }

    public int modulus(int operand) {
        return (state.index + 1) % operand;
    }

    public static class StatusState {
        boolean last = false;
        int index = 0;

        public void setLast(boolean isLast) {
            last = isLast;
        }

        public void next() {
            index++;
        }
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/IteratorTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.jsp.JspException;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.IteratorComponent;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see IteratorComponent
 */
public class IteratorTag extends ComponentTagSupport {

	private static final long serialVersionUID = -1827978135193581901L;
	
	protected String statusAttr;
    protected String value;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new IteratorComponent(stack);
    }

    protected void populateParams() {
    	super.populateParams();
    	
        IteratorComponent tag = (IteratorComponent) getComponent();
        tag.setStatus(statusAttr);
        tag.setValue(value);
    }

    public void setStatus(String status) {
        this.statusAttr = status;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public int doEndTag() throws JspException {
        component = null;
        return EVAL_PAGE;
    }

    public int doAfterBody() throws JspException {
        boolean again = component.end(pageContext.getOut(), getBody());

        if (again) {
            return EVAL_BODY_AGAIN;
        } else {
            if (bodyContent != null) {
                try {
                    bodyContent.writeOut(bodyContent.getEnclosingWriter());
                } catch (Exception e) {
                    throw new JspException(e.getMessage());
                }
            }
            return SKIP_BODY;
        }
    }

}
"
core/src/main/java/org/apache/struts2/views/jsp/ParamTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Param;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Param
 */
public class ParamTag extends ComponentTagSupport {
	
	private static final long serialVersionUID = -968332732207156408L;
	
	protected String name;
    protected String value;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Param(stack);
    }

    protected void populateParams() {
        super.populateParams();

        Param param = (Param) component;
        param.setName(name);
        param.setValue(value);
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setValue(String value) {
        this.value = value;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/PropertyTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Property;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * @see Property
 */
public class PropertyTag extends ComponentTagSupport {
	
	private static final long serialVersionUID = 435308349113743852L;
	
	private String defaultValue;
    private String value;
    private boolean escape = true;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Property(stack);
    }

    protected void populateParams() {
        super.populateParams();

        Property tag = (Property) component;
        tag.setDefault(defaultValue);
        tag.setValue(value);
        tag.setEscape(escape);
    }

    public void setDefault(String defaultValue) {
        this.defaultValue = defaultValue;
    }

    public void setEscape(boolean escape) {
        this.escape = escape;
    }

    public void setValue(String value) {
        this.value = value;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/PushTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Push;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * @see Push
 */
public class PushTag extends ComponentTagSupport {
	
	private static final long serialVersionUID = -1357895305148907931L;
	
	protected String value;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Push(stack);
    }

    protected void populateParams() {
        super.populateParams();

        ((Push) component).setValue(value);
    }

    public void setValue(String value) {
        this.value = value;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/SetTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Set;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * @see Set
 */
public class SetTag extends ComponentTagSupport {
	
	private static final long serialVersionUID = -5074213926790716974L;
	
	protected String name;
    protected String scope;
    protected String value;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Set(stack);
    }

    protected void populateParams() {
        super.populateParams();

        Set set = (Set) component;
        set.setName(name);
        set.setScope(scope);
        set.setValue(value);
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setScope(String scope) {
        this.scope = scope;
    }

    public void setValue(String value) {
        this.value = value;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/StrutsBodyTagSupport.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp;

import java.io.PrintWriter;

import javax.servlet.jsp.tagext.BodyTagSupport;

import org.apache.struts2.util.FastByteArrayOutputStream;
import org.apache.struts2.views.util.ContextUtil;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * Contains common functonalities for Struts JSP Tags.
 * 
 */
public class StrutsBodyTagSupport extends BodyTagSupport {

    private static final long serialVersionUID = -1201668454354226175L;

    /**
     * @s.tagattribute required="false" type="String"
     * description="The id of the tag element."
     */
    public void setId(String string) {
        super.setId(string);
    }
    
    protected boolean altSyntax() {
        return ContextUtil.isUseAltSyntax(getStack().getContext());
    }

    protected OgnlValueStack getStack() {
        return TagUtils.getStack(pageContext);
    }

    protected String findString(String expr) {
        return (String) findValue(expr, String.class);
    }

    protected Object findValue(String expr) {
        if (altSyntax()) {
            // does the expression start with %{ and end with }? if so, just cut it off!
            if (expr.startsWith("%{") && expr.endsWith("}")) {
                expr = expr.substring(2, expr.length() - 1);
            }
        }

        return getStack().findValue(expr);
    }

    protected Object findValue(String expr, Class toType) {
        if (altSyntax() && toType == String.class) {
            return translateVariables(expr, getStack());
        } else {
            if (altSyntax()) {
                // does the expression start with %{ and end with }? if so, just cut it off!
                if (expr.startsWith("%{") && expr.endsWith("}")) {
                    expr = expr.substring(2, expr.length() - 1);
                }
            }

            return getStack().findValue(expr, toType);
        }
    }

    protected String toString(Throwable t) {
        FastByteArrayOutputStream bout = new FastByteArrayOutputStream();
        PrintWriter wrt = new PrintWriter(bout);
        t.printStackTrace(wrt);
        wrt.close();

        return bout.toString();
    }

    protected String getBody() {
        if (bodyContent == null) {
            return "";
        } else {
            return bodyContent.getString().trim();
        }
    }
    
    public static String translateVariables(String expression, OgnlValueStack stack) {
        while (true) {
            int x = expression.indexOf("%{");
            int y = expression.indexOf("}", x);

            if ((x != -1) && (y != -1)) {
                String var = expression.substring(x + 2, y);

                Object o = stack.findValue(var, String.class);

                if (o != null) {
                    expression = expression.substring(0, x) + o + expression.substring(y + 1);
                } else {
                    // the variable doesn't exist, so don't display anything
                    expression = expression.substring(0, x) + expression.substring(y + 1);
                }
            } else {
                break;
            }
        }

        return expression;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/TagUtils.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp;

import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.jsp.PageContext;

import org.apache.struts2.RequestUtils;
import org.apache.struts2.ServletActionContext;
import org.apache.struts2.dispatcher.ApplicationMap;
import org.apache.struts2.dispatcher.Dispatcher;
import org.apache.struts2.dispatcher.RequestMap;
import org.apache.struts2.dispatcher.SessionMap;
import org.apache.struts2.dispatcher.mapper.ActionMapper;
import org.apache.struts2.dispatcher.mapper.ActionMapperFactory;
import org.apache.struts2.dispatcher.mapper.ActionMapping;
import org.apache.struts2.util.AttributeMap;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 */
public class TagUtils {

    public static OgnlValueStack getStack(PageContext pageContext) {
        HttpServletRequest req = (HttpServletRequest) pageContext.getRequest();
        OgnlValueStack stack = (OgnlValueStack) req.getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY);

        if (stack == null) {
            stack = new OgnlValueStack();

            HttpServletResponse res = (HttpServletResponse) pageContext.getResponse();
            Dispatcher du = Dispatcher.getInstance();
            Map extraContext = du.createContextMap(new RequestMap(req),
                    req.getParameterMap(),
                    new SessionMap(req),
                    new ApplicationMap(pageContext.getServletContext()),
                    req,
                    res,
                    pageContext.getServletContext());
            extraContext.put(ServletActionContext.PAGE_CONTEXT, pageContext);
            stack.getContext().putAll(extraContext);
            req.setAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY, stack);

            // also tie this stack/context to the ThreadLocal
            ActionContext.setContext(new ActionContext(stack.getContext()));
        } else {
            // let's make sure that the current page context is in the action context
            Map context = stack.getContext();
            context.put(ServletActionContext.PAGE_CONTEXT, pageContext);

            AttributeMap attrMap = new AttributeMap(context);
            context.put("attr", attrMap);
        }

        return stack;
    }

    public static String buildNamespace(OgnlValueStack stack, HttpServletRequest request) {
        ActionContext context = new ActionContext(stack.getContext());
        ActionInvocation invocation = context.getActionInvocation();

        if (invocation == null) {
            ActionMapper mapper = ActionMapperFactory.getMapper();
            ActionMapping mapping = mapper.getMapping(request,
                    Dispatcher.getInstance().getConfigurationManager().getConfiguration());

            if (mapping != null) {
                return mapping.getNamespace();
            } else {
                // well, if the ActionMapper can't tell us, and there is no existing action invocation,
                // let's just go with a default guess that the namespace is the last the path minus the
                // last part (/foo/bar/baz.xyz -> /foo/bar)

                String path = RequestUtils.getServletPath(request);
                return path.substring(0, path.lastIndexOf("/"));
            }
        } else {
            return invocation.getProxy().getNamespace();
        }
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/TextTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Text;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * @see Text
 */
public class TextTag extends ComponentTagSupport {
	
	private static final long serialVersionUID = -3075088084198264581L;
	
	protected String name;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Text(stack);
    }

    protected void populateParams() {
        super.populateParams();

        ((Text) component).setName(name);
    }

    public void setName(String name) {
        this.name = name;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/URLTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.URL;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * @see URL
 */
public class URLTag extends ComponentTagSupport {
	
	private static final long serialVersionUID = 1722460444125206226L;

	protected String includeParams;
    protected String scheme;
    protected String value;
    protected String action;
    protected String namespace;
    protected String method;
    protected String encode;
    protected String includeContext;
    protected String portletMode;
    protected String windowState;
    protected String portletUrlType;
    protected String anchor;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new URL(stack, req, res);
    }

    protected void populateParams() {
        super.populateParams();

        URL url = (URL) component;
        url.setIncludeParams(includeParams);
        url.setScheme(scheme);
        url.setValue(value);
        url.setMethod(method);
        url.setNamespace(namespace);
        url.setAction(action);
        url.setPortletMode(portletMode);
        url.setPortletUrlType(portletUrlType);
        url.setWindowState(windowState);
        url.setAnchor(anchor);

        if (encode != null) {
            url.setEncode(Boolean.valueOf(encode).booleanValue());
        }
        if (includeContext != null) {
            url.setIncludeContext(Boolean.valueOf(includeContext).booleanValue());
        }
    }

    public void setEncode(String encode) {
        this.encode = encode;
    }

    public void setIncludeContext(String includeContext) {
        this.includeContext = includeContext;
    }

    public void setIncludeParams(String name) {
        includeParams = name;
    }

    public void setAction(String action) {
        this.action = action;
    }

    public void setNamespace(String namespace) {
        this.namespace = namespace;
    }

    public void setMethod(String method) {
        this.method = method;
    }

    public void setScheme(String scheme) {
        this.scheme = scheme;
    }

    public void setValue(String value) {
        this.value = value;
    }
    public void setPortletMode(String portletMode) {
        this.portletMode = portletMode;
    }
    public void setPortletUrlType(String portletUrlType) {
        this.portletUrlType = portletUrlType;
    }
    public void setWindowState(String windowState) {
        this.windowState = windowState;
    }

    public void setAnchor(String anchor) {
        this.anchor = anchor;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/iterator/AppendIteratorTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.iterator;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.AppendIterator;
import org.apache.struts2.components.Component;
import org.apache.struts2.views.jsp.ComponentTagSupport;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * Append a list of iterators. The values of the iterators will be merged
 * into one iterator.
 *
 * @see AppendIterator
 */
public class AppendIteratorTag extends ComponentTagSupport {

	private static final long serialVersionUID = -6017337859763283691L;

	public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
		return new AppendIterator(stack);
	}
	
}
"
core/src/main/java/org/apache/struts2/views/jsp/iterator/IteratorGeneratorTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.iterator;

import javax.servlet.jsp.JspException;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.util.IteratorGenerator;
import org.apache.struts2.util.IteratorGenerator.Converter;
import org.apache.struts2.views.jsp.StrutsBodyTagSupport;


/**
 * <!-- START SNIPPET: javadoc -->
 * <b>NOTE: JSP-TAG</b>
 * 
 * <p>Generate an iterator based on the val attribute supplied.</P>
 * 
 * <b>NOTE:</b> The generated iterator will <b>ALWAYS</b> be pushed into the top of the stack, and poped
 * at the end of the tag.
 * <!-- END SNIPPET: javadoc -->
 *
 * <!-- START SNIPPET: params -->
 * <ul>
 * 		<li>val* (Object) - the source to be parsed into an iterator </li>
 * 		<li>count (Object) - the max number (Integer, Float, Double, Long, String) entries to be in the iterator</li>
 * 		<li>separator (String) - the separator to be used in separating the <i>val</i> into entries of the iterator</li>
 *  	<li>id (String) - the id to store the resultant iterator into page context, if such id is supplied</li>
 *  	<li>converter (Object) - the converter (must extends off IteratorGenerator.Converter interface) to convert the String entry parsed from <i>val</i> into an object</li>
 * </ul>
 * <!-- END SNIPPET: params -->
 *
 *
 * <!-- START SNIPPET: example -->
 * Example One:
 * <pre>
 * Generate a simple iterator
 * &lt;s:generator val="%{'aaa,bbb,ccc,ddd,eee'}"&gt;
 *	&lt;s:iterator&gt;
 *		&lt;s:property /&gt;&lt;br/&gt;
 *	&lt;/s:iterator&gt;
 * &lt;/s:generator&gt;
 * </pre>
 * This generates an iterator and print it out using the iterator tag.
 *
 * Example Two:
 * <pre>
 * Generate an iterator with count attribute
 * &lt;s:generator val="%{'aaa,bbb,ccc,ddd,eee'}" count="3"&gt;
 *	&lt;s:iterator&gt;
 *		&lt;s:property /&gt;&lt;br/&gt;
 *	&lt;/s:iterator&gt;
 * &lt;/s:generator&gt;
 * </pre>
 * This generates an iterator, but only 3 entries will be available in the iterator
 * generated, namely aaa, bbb and ccc respectively because count attribute is set to 3
 *
 * Example Three:
 * <pre>
 * Generate an iterator with id attribute
 * &lt;s:generator val="%{'aaa,bbb,ccc,ddd,eee'}" count="4" separator="," id="myAtt" /&gt;
 * &lt;%
 * 	Iterator i = (Iterator) pageContext.getAttribute("myAtt");
 * 	while(i.hasNext()) {
 * 		String s = (String) i.next(); %>
 * 		&lt;%=s%&gt; &lt;br/&gt;
 * &lt;% 	}
 * %&gt;
 * </pre>
 * This generates an iterator and put it in the PageContext under the key as specified
 * by the id attribute.
 *
 *
 * Example Four:
 * <pre>
 * Generate an iterator with comparator attribute
 * &lt;s:generator val="%{'aaa,bbb,ccc,ddd,eee'}" converter="%{myConverter}"&gt;
 *	&lt;s:iterator&gt;
 * 		&lt;s:property /&gt;&lt;br/&gt;
 * 	&lt;/s:iterator&gt;
 * &lt;/s:generator&gt;
 *
 *
 * public class GeneratorTagAction extends ActionSupport {
 *
 *   ....
 *
 *	 public Converter getMyConverter() {
 *		return new Converter() {
 *			public Object convert(String value) throws Exception {
 *				return "converter-"+value;
 *			}
 *		};
 *	 }
 *
 *   ...
 *
 * }
 * </pre>
 * This will generate an iterator with each entries decided by the converter supplied. With
 * this converter, it simply add "converter-" to each entries.
 * <!-- END SNIPPET: example -->
 *
 * @see org.apache.struts2.util.IteratorGenerator
 *
 * @s.tag name="generator" tld-body-content="JSP"
 * description="Generate an iterator for a iterable source."
 */
public class IteratorGeneratorTag extends StrutsBodyTagSupport {

	private static final long serialVersionUID = 2968037295463973936L;

	public static final String DEFAULT_SEPARATOR = ",";

	private static final Log _log = LogFactory.getLog(IteratorGeneratorTag.class);

    String countAttr;
    String separatorAttr;
    String valueAttr;
    String converterAttr;

    IteratorGenerator iteratorGenerator = null;

    /**
     * @s.tagattribute required="false" type="Integer"
     * description="the max number entries to be in the iterator"
     */
    public void setCount(String count) {
        countAttr = count;
    }

    /**
     * @s.tagattribute required="true" type="String"
     * description="the separator to be used in separating the <i>val</i> into entries of the iterator"
     */
    public void setSeparator(String separator) {
        separatorAttr = separator;
    }

    /**
     * @s.tagattribute required="true"
     * description="the source to be parsed into an iterator"
     */
    public void setVal(String val) {
        valueAttr = val;
    }

    /**
     * @s.tagattribute required="false" type="org.apache.struts2.util.IteratorGenerator.Converter"
     * description="the converter to convert the String entry parsed from <i>val</i> into an object"
     */
    public void setConverter(String aConverter) {
    	converterAttr = aConverter;
    }

    /**
     * @s.tagattribute required="false" type="String"
     * description="the id to store the resultant iterator into page context, if such id is supplied"
     */
    public void setId(String string) {
        super.setId(string);
    }

    public int doStartTag() throws JspException {

    	// value
    	Object value = findValue(valueAttr);

    	// separator
    	String separator = DEFAULT_SEPARATOR;
    	if (separatorAttr != null && separatorAttr.length() > 0) {
    		separator = findString(separatorAttr);
    	}

    	// TODO: maybe this could be put into an Util class, or there is already one?
    	// count
    	int count = 0;
    	if (countAttr != null && countAttr.length() > 0) {
    		Object countObj = findValue(countAttr);
    		if (countObj instanceof Integer) {
    			count = ((Integer)countObj).intValue();
    		}
    		else if (countObj instanceof Float) {
    			count = ((Float)countObj).intValue();
    		}
    		else if (countObj instanceof Long) {
    			count = ((Long)countObj).intValue();
    		}
    		else if (countObj instanceof Double) {
    			count = ((Long)countObj).intValue();
    		}
    		else if (countObj instanceof String) {
    			try {
    				count = Integer.parseInt((String)countObj);
    			}
    			catch(NumberFormatException e) {
    				_log.warn("unable to convert count attribute ["+countObj+"] to number, ignore count attribute", e);
    			}
    		}
    	}

    	// converter
    	Converter converter = null;
    	if (converterAttr != null && converterAttr.length() > 0) {
    		converter = (Converter) findValue(converterAttr);
    	}


    	iteratorGenerator = new IteratorGenerator();
    	iteratorGenerator.setValues(value);
    	iteratorGenerator.setCount(count);
    	iteratorGenerator.setSeparator(separator);
    	iteratorGenerator.setConverter(converter);

    	iteratorGenerator.execute();



    	// push resulting iterator into stack
    	getStack().push(iteratorGenerator);
    	if (getId() != null && getId().length() > 0) {
    		// if an id is specified, we have the resulting iterator set into
    		// the pageContext attribute as well
    		pageContext.setAttribute(getId(), iteratorGenerator);
    	}

        return EVAL_BODY_INCLUDE;
    }

    public int doEndTag() throws JspException {
    	// pop resulting iterator from stack at end tag
    	getStack().pop();
    	iteratorGenerator = null; // clean up

    	return EVAL_PAGE;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/iterator/MergeIteratorTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.iterator;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.MergeIterator;
import org.apache.struts2.views.jsp.ComponentTagSupport;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * Append a list of iterators. The values of the iterators will be merged
 * into one iterator.
 *
 * @see MergeIterator
 * @see org.apache.struts2.util.MergeIteratorFilter
 */
public class MergeIteratorTag extends ComponentTagSupport {

	private static final long serialVersionUID = 4999729472466011218L;

	public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
		return new MergeIterator(stack);
	}

}
"
core/src/main/java/org/apache/struts2/views/jsp/iterator/SortIteratorTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.iterator;

import java.util.Comparator;

import javax.servlet.jsp.JspException;

import org.apache.struts2.util.MakeIterator;
import org.apache.struts2.util.SortIteratorFilter;
import org.apache.struts2.views.jsp.StrutsBodyTagSupport;


/**
 * <!-- START SNIPPET: javadoc -->
 *
 * <b>NOTE: JSP-TAG</b>
 * 
 * <p>A Tag that sorts a List using a Comparator both passed in as the tag attribute.
 * If 'id' attribute is specified, the sorted list will be placed into the PageContext
 * attribute using the key specified by 'id'. The sorted list will ALWAYS be
 * pushed into the stack and poped at the end of this tag.</p>
 *
 * <!-- END SNIPPET: javadoc -->
 *
 *
 * <!-- START SNIPPET: params -->
 *
 * <ul>
 * 		<li>id (String) - if specified, the sorted iterator will be place with this id under page context</li>
 * 		<li>source (Object) - the source for the sort to take place (should be iteratable) else JspException will be thrown</li>
 * 		<li>comparator* (Object) - the comparator used to do sorting (should be a type of Comparator or its decendent) else JspException will be thrown</li>
 * </ul>
 *
 * <!-- END SNIPPET: params -->
 *
 *
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 *
 * USAGE 1:
 * &lt;s:sort comparator="myComparator" source="myList"&gt;
 *      &lt;s:iterator&gt;
 * 		&lt;!-- do something with each sorted elements --&gt;
 * 		&lt;s:property value="..." /&gt;
 *      &lt;/s:iterator&gt;
 * &lt;/s:sort&gt;
 *
 * USAGE 2:
 * &lt;s:sort id="mySortedList" comparator="myComparator" source="myList" /&gt;
 *
 * &lt;%
 *    Iterator sortedIterator = (Iterator) pageContext.getAttribute("mySortedList");
 *    for (Iterator i = sortedIterator; i.hasNext(); ) {
 *    	// do something with each of the sorted elements
 *    }
 * %&gt;
 *
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 *
 * @see org.apache.struts2.util.SortIteratorFilter
 *
 * @s.tag name="sort" tld-body-content="JSP"
 * description="Sort a List using a Comparator both passed in as the tag attribute."
 */
public class SortIteratorTag extends StrutsBodyTagSupport {

	private static final long serialVersionUID = -7835719609764092235L;

	String comparatorAttr;
    String sourceAttr;

    SortIteratorFilter sortIteratorFilter = null;

    /**
     * @s.tagattribute required="true" type="java.util.Comparator"
     * description="The comparator to use"
     */
    public void setComparator(String comparator) {
        comparatorAttr = comparator;
    }

    /**
     * @s.tagattribute required="false"
     * description="The iterable source to sort"
     */
    public void setSource(String source) {
        sourceAttr = source;
    }

    public int doStartTag() throws JspException {
    	// Source
        Object srcToSort;
        if (sourceAttr == null) {
            srcToSort = findValue("top");
        } else {
            srcToSort = findValue(sourceAttr);
        }
        if (! MakeIterator.isIterable(srcToSort)) { // see if source is Iteratable
        	throw new JspException("source ["+srcToSort+"] is not iteratable");
        }

        // Comparator
        Object comparatorObj = findValue(comparatorAttr);
        if (! (comparatorObj instanceof Comparator)) {
        	throw new JspException("comparator ["+comparatorObj+"] does not implements Comparator interface");
        }
        Comparator c = (Comparator) findValue(comparatorAttr);

        // SortIteratorFilter
        sortIteratorFilter = new SortIteratorFilter();
        sortIteratorFilter.setComparator(c);
        sortIteratorFilter.setSource(srcToSort);
        sortIteratorFilter.execute();

        // push sorted iterator into stack, so nexted tag have access to it
    	getStack().push(sortIteratorFilter);
        if (getId() != null && getId().length() > 0) {
        	pageContext.setAttribute(getId(), sortIteratorFilter);
        }

        return EVAL_BODY_INCLUDE;
    }

    public int doEndTag() throws JspException {
    	int returnVal =  super.doEndTag();

   		// pop sorted list from stack at the end of tag
   		getStack().pop();
   		sortIteratorFilter = null;

    	return returnVal;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/iterator/SubsetIteratorTag.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.iterator;

import javax.servlet.jsp.JspException;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.util.SubsetIteratorFilter;
import org.apache.struts2.util.SubsetIteratorFilter.Decider;
import org.apache.struts2.views.jsp.StrutsBodyTagSupport;


/**
 * <!-- START SNIPPET: javadoc -->
 * <b>NOTE: JSP-TAG</b>
 * 
 * <p>A tag that takes an iterator and outputs a subset of it. It delegates to
 * {@link org.apache.struts2.util.SubsetIteratorFilter} internally to
 * perform the subset functionality.</p>
 * <!-- END SNIPPET: javadoc -->
 *
 * <!-- START SNIPPET: params -->
 * <ul>
 * 		<li>count (Object) - Indicate the number of entries to be in the resulting subset iterator</li>
 * 		<li>source* (Object) - Indicate the source of which the resulting subset iterator is to be derived base on</li>
 * 		<li>start (Object) - Indicate the starting index (eg. first entry is 0) of entries in the source to be available as the first entry in the resulting subset iterator</li>
 * 		<li>decider (Object) - Extension to plug-in a decider to determine if that particular entry is to be included in the resulting subset iterator</li>
 * 		<li>id (String) - Indicate the pageContext attribute id to store the resultant subset iterator in</li>
 * </ul>
 * <!-- END SNIPPET: params -->
 *
 *
 * <pre>
 * <!-- START SNIPPET: action -->
 * public class MySubsetTagAction extends ActionSupport {
 *      public String execute() throws Exception {
 *		   l = new ArrayList();
 *		   l.add(new Integer(1));
 *		   l.add(new Integer(2));
 *		   l.add(new Integer(3));
 *		   l.add(new Integer(4));
 *		   l.add(new Integer(5));
 *		   return "done";
 *	    }
 *
 *
 *	    public Integer[] getMyArray() {
 *		   return a;
 *	    }
 *
 *	    public List getMyList() {
 *		   return l;
 *	     }
 *
 *      public Decider getMyDecider() {
 *		return new Decider() {
 *			public boolean decide(Object element) throws Exception {
 *				int i = ((Integer)element).intValue();
 *				return (((i % 2) == 0)?true:false);
 *			}
 *		};
 *		}
 *	}
 * <!-- END SNIPPET: action -->
 * </pre>
 *
 *
 * <pre>
 * <!-- START SNIPPET: example1 -->
 * &lt;!-- s: List basic --&gt;
 *    &lt;s:subset source="myList"&gt;
 *	     &lt;s:iterator&gt;
 *		    &lt;s:property /&gt;
 *	     &lt;/s:iterator&gt;
 *    &lt;/s:subset&gt;
 * <!-- END SNIPPET: example1 -->
 * </pre>
 *
 * <pre>
 * <!-- START SNIPPET: example2 -->
 * &lt;!-- B: List with count --&gt;
 *    &lt;s:subset source="myList" count="3"&gt;
 * 	     &lt;s:iterator&gt;
 * 		     &lt;s:property /&gt;
 * 	     &lt;/s:iterator&gt;
 *     &lt;/s:subset&gt;
 * <!-- END SNIPPET: example2 -->
 * </pre>
 *
 * <pre>
 * <!-- START SNIPPET: example3 -->
 * &lt;!--  C: List with start -->
 *      &lt;s:subset source="myList" count="13" start="3"&gt;
 * 	       &lt;s:iterator&gt;
 * 		     &lt;s:property /&gt;
 * 	       &lt;/s:iterator&gt;
 *      &lt;/s:subset&gt;
 * <!-- END SNIPPET: example3 -->
 * </pre>
 *
 * <pre>
 * <!-- START SNIPPET: example4 -->
 * &lt;!--  D: List with id --&gt;
 *      &lt;s:subset id="mySubset" source="myList" count="13" start="3" /&gt;
 *      &lt;%
 * 	        Iterator i = (Iterator) pageContext.getAttribute("mySubset");
 *          while(i.hasNext()) {
 *      %&gt;
 *      &lt;%=i.next() %&gt;
 *      &lt;%  } %&gt;
 * <!-- END SNIPPET: example4 -->
 * </pre>
 *
 * <pre>
 * <!-- START SNIPPET: example5 -->
 *  &lt;!--  D: List with Decider --&gt;
 *      &lt;s:subset source="myList" decider="myDecider"&gt;
 * 	           &lt;s:iterator&gt;
 *		            &lt;s:property /&gt;
 *	           &lt;/s:iterator&gt;
 *      &lt;/s:subset&gt;
 * <!-- END SNIPPET: example5 -->
 * </pre>
 *
 *
 * @s.tag name="subset" tld-body-content="JSP"
 * description="Takes an iterator and outputs a subset of it"
 */
public class SubsetIteratorTag extends StrutsBodyTagSupport {

	private static final long serialVersionUID = -6252696081713080102L;

	private static final Log _log = LogFactory.getLog(SubsetIteratorTag.class);

    String countAttr;
    String sourceAttr;
    String startAttr;
    String deciderAttr;

    SubsetIteratorFilter subsetIteratorFilter = null;


    /**
     * @s.tagattribute required="false" type="Integer"
     * description="Indicate the number of entries to be in the resulting subset iterator"
     */
    public void setCount(String count) {
        countAttr = count;
    }

    /**
     * @s.tagattribute required="false"
     * description="Indicate the source of which the resulting subset iterator is to be derived base on"
     */
    public void setSource(String source) {
        sourceAttr = source;
    }

    /**
     * @s.tagattribute required="false" type="Integer"
     * description="Indicate the starting index (eg. first entry is 0) of entries in the source to be available as the first entry in the resulting subset iterator"
     */
    public void setStart(String start) {
        startAttr = start;
    }

    /**
     * @s.tagattribute required="false" type="org.apache.struts2.util.SubsetIteratorFilter.Decider"
     * description="Extension to plug-in a decider to determine if that particular entry is to be included in the resulting subset iterator"
     */
    public void setDecider(String decider) {
    	deciderAttr = decider;
    }


    public int doStartTag() throws JspException {

        // source
        Object source = null;
        if (sourceAttr == null && sourceAttr.length() <= 0) {
        	source = findValue("top");
        } else {
            source = findValue(sourceAttr);
        }

        // count
        int count = -1;
    	if (countAttr != null && countAttr.length() > 0) {
    		Object countObj = findValue(countAttr);
    		if (countObj instanceof Integer) {
    			count = ((Integer)countObj).intValue();
    		}
    		else if (countObj instanceof Float) {
    			count = ((Float)countObj).intValue();
    		}
    		else if (countObj instanceof Long) {
    			count = ((Long)countObj).intValue();
    		}
    		else if (countObj instanceof Double) {
    			count = ((Long)countObj).intValue();
    		}
    		else if (countObj instanceof String) {
    			try {
    				count = Integer.parseInt((String)countObj);
    			}
    			catch(NumberFormatException e) {
    				_log.warn("unable to convert count attribute ["+countObj+"] to number, ignore count attribute", e);
    			}
    		}
    	}

        // start
    	int start = 0;
        if (startAttr != null && startAttr.length() > 0) {
            Object startObj = findValue(startAttr);
            if (startObj instanceof Integer) {
    			start = ((Integer)startObj).intValue();
    		}
    		else if (startObj instanceof Float) {
    			start = ((Float)startObj).intValue();
    		}
    		else if (startObj instanceof Long) {
    			start = ((Long)startObj).intValue();
    		}
    		else if (startObj instanceof Double) {
    			start = ((Long)startObj).intValue();
    		}
    		else if (startObj instanceof String) {
    			try {
    				start = Integer.parseInt((String)startObj);
    			}
    			catch(NumberFormatException e) {
    				_log.warn("unable to convert count attribute ["+startObj+"] to number, ignore count attribute", e);
    			}
    		}
        }

        // decider
        Decider decider = null;
        if (deciderAttr != null && deciderAttr.length() > 0) {
        	Object deciderObj = findValue(deciderAttr);
        	if (! (deciderObj instanceof Decider)) {
        		throw new JspException("decider found from stack ["+deciderObj+"] does not implement "+Decider.class);
        	}
        	decider = (Decider) deciderObj;
        }


        subsetIteratorFilter = new SubsetIteratorFilter();
        subsetIteratorFilter.setCount(count);
        subsetIteratorFilter.setDecider(decider);
        subsetIteratorFilter.setSource(source);
        subsetIteratorFilter.setStart(start);
        subsetIteratorFilter.execute();

        getStack().push(subsetIteratorFilter);
        if (getId() != null) {
        	pageContext.setAttribute(getId(), subsetIteratorFilter);
        }

        return EVAL_BODY_INCLUDE;
    }

    public int doEndTag() throws JspException {

    	getStack().pop();

    	subsetIteratorFilter = null;

    	return EVAL_PAGE;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/AbstractClosingTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import org.apache.struts2.components.ClosingUIBean;

/**
 */
public abstract class AbstractClosingTag extends AbstractUITag {
    protected String openTemplate;

    protected void populateParams() {
        super.populateParams();

        ((ClosingUIBean) component).setOpenTemplate(openTemplate);
    }

    public void setOpenTemplate(String openTemplate) {
        this.openTemplate = openTemplate;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/AbstractDoubleListTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import org.apache.struts2.components.DoubleListUIBean;


/**
 */
public abstract class AbstractDoubleListTag extends AbstractRequiredListTag {
	
    protected String doubleList;
    protected String doubleListKey;
    protected String doubleListValue;
    protected String doubleName;
    protected String doubleValue;
    protected String formName;
    
    protected String emptyOption;
    protected String headerKey;
    protected String headerValue;
    protected String multiple;
    protected String size;
    
    protected String doubleId;
    protected String doubleDisabled;
    protected String doubleMultiple;
    protected String doubleSize;
    protected String doubleHeaderKey;
    protected String doubleHeaderValue;
    protected String doubleEmptyOption;
    
    protected String doubleCssClass;
    protected String doubleCssStyle;
    
    protected String doubleOnclick;
    protected String doubleOndblclick;
    protected String doubleOnmousedown;
    protected String doubleOnmouseup;
    protected String doubleOnmouseover;
    protected String doubleOnmousemove;
    protected String doubleOnmouseout;
    protected String doubleOnfocus;
    protected String doubleOnblur;
    protected String doubleOnkeypress;
    protected String doubleOnkeydown;
    protected String doubleOnkeyup;
    protected String doubleOnselect;
    protected String doubleOnchange;
    
    protected String doubleAccesskey;

    protected void populateParams() {
        super.populateParams();

        DoubleListUIBean bean = ((DoubleListUIBean) this.component);
        bean.setDoubleList(doubleList);
        bean.setDoubleListKey(doubleListKey);
        bean.setDoubleListValue(doubleListValue);
        bean.setDoubleName(doubleName);
        bean.setDoubleValue(doubleValue);
        bean.setFormName(formName);
        
        bean.setDoubleId(doubleId);
        bean.setDoubleDisabled(doubleDisabled);
        bean.setDoubleMultiple(doubleMultiple);
        bean.setDoubleSize(doubleSize);
        bean.setDoubleHeaderKey(doubleHeaderKey);
        bean.setDoubleHeaderValue(doubleHeaderValue);
        bean.setDoubleEmptyOption(doubleEmptyOption);
        
        bean.setDoubleCssClass(doubleCssClass);
        bean.setDoubleCssStyle(doubleCssStyle);
        
        bean.setDoubleOnclick(doubleOnclick);
        bean.setDoubleOndblclick(doubleOndblclick);
        bean.setDoubleOnmousedown(doubleOnmousedown);
        bean.setDoubleOnmouseup(doubleOnmouseup);
        bean.setDoubleOnmouseover(doubleOnmouseover);
        bean.setDoubleOnmousemove(doubleOnmousemove);
        bean.setDoubleOnmouseout(doubleOnmouseout);
        bean.setDoubleOnfocus(doubleOnfocus);
        bean.setDoubleOnblur(doubleOnblur);
        bean.setDoubleOnkeypress(doubleOnkeypress);
        bean.setDoubleOnkeydown(doubleOnkeydown);
        bean.setDoubleOnkeyup(doubleOnkeyup);
        bean.setDoubleOnselect(doubleOnselect);
        bean.setDoubleOnchange(doubleOnchange);
        
        bean.setDoubleAccesskey(doubleAccesskey);
        
        bean.setEmptyOption(emptyOption);
        bean.setHeaderKey(headerKey);
        bean.setHeaderValue(headerValue);
        bean.setMultiple(multiple);
        bean.setSize(size);
    }

    public void setDoubleList(String list) {
        this.doubleList = list;
    }

    public void setDoubleListKey(String listKey) {
        this.doubleListKey = listKey;
    }

    public void setDoubleListValue(String listValue) {
        this.doubleListValue = listValue;
    }

    public void setDoubleName(String aName) {
        doubleName = aName;
    }

    public void setDoubleValue(String doubleValue) {
        this.doubleValue = doubleValue;
    }

    public void setFormName(String formName) {
        this.formName = formName;
    }

	public String getDoubleCssClass() {
		return doubleCssClass;
	}

	public void setDoubleCssClass(String doubleCssClass) {
		this.doubleCssClass = doubleCssClass;
	}

	public String getDoubleCssStyle() {
		return doubleCssStyle;
	}

	public void setDoubleCssStyle(String doubleCssStyle) {
		this.doubleCssStyle = doubleCssStyle;
	}

	public String getDoubleDisabled() {
		return doubleDisabled;
	}

	public void setDoubleDisabled(String doubleDisabled) {
		this.doubleDisabled = doubleDisabled;
	}

	public String getDoubleEmptyOption() {
		return doubleEmptyOption;
	}

	public void setDoubleEmptyOption(String doubleEmptyOption) {
		this.doubleEmptyOption = doubleEmptyOption;
	}

	public String getDoubleHeaderKey() {
		return doubleHeaderKey;
	}

	public void setDoubleHeaderKey(String doubleHeaderKey) {
		this.doubleHeaderKey = doubleHeaderKey;
	}

	public String getDoubleHeaderValue() {
		return doubleHeaderValue;
	}

	public void setDoubleHeaderValue(String doubleHeaderValue) {
		this.doubleHeaderValue = doubleHeaderValue;
	}

	public String getDoubleId() {
		return doubleId;
	}

	public void setDoubleId(String doubleId) {
		this.doubleId = doubleId;
	}

	public String getDoubleMultiple() {
		return doubleMultiple;
	}

	public void setDoubleMultiple(String doubleMultiple) {
		this.doubleMultiple = doubleMultiple;
	}

	public String getDoubleOnblur() {
		return doubleOnblur;
	}

	public void setDoubleOnblur(String doubleOnblur) {
		this.doubleOnblur = doubleOnblur;
	}

	public String getDoubleOnchange() {
		return doubleOnchange;
	}

	public void setDoubleOnchange(String doubleOnchange) {
		this.doubleOnchange = doubleOnchange;
	}

	public String getDoubleOnclick() {
		return doubleOnclick;
	}

	public void setDoubleOnclick(String doubleOnclick) {
		this.doubleOnclick = doubleOnclick;
	}

	public String getDoubleOndblclick() {
		return doubleOndblclick;
	}

	public void setDoubleOndblclick(String doubleOndblclick) {
		this.doubleOndblclick = doubleOndblclick;
	}

	public String getDoubleOnfocus() {
		return doubleOnfocus;
	}

	public void setDoubleOnfocus(String doubleOnfocus) {
		this.doubleOnfocus = doubleOnfocus;
	}

	public String getDoubleOnkeydown() {
		return doubleOnkeydown;
	}

	public void setDoubleOnkeydown(String doubleOnkeydown) {
		this.doubleOnkeydown = doubleOnkeydown;
	}

	public String getDoubleOnkeypress() {
		return doubleOnkeypress;
	}

	public void setDoubleOnkeypress(String doubleOnkeypress) {
		this.doubleOnkeypress = doubleOnkeypress;
	}

	public String getDoubleOnkeyup() {
		return doubleOnkeyup;
	}

	public void setDoubleOnkeyup(String doubleOnkeyup) {
		this.doubleOnkeyup = doubleOnkeyup;
	}

	public String getDoubleOnmousedown() {
		return doubleOnmousedown;
	}

	public void setDoubleOnmousedown(String doubleOnmousedown) {
		this.doubleOnmousedown = doubleOnmousedown;
	}

	public String getDoubleOnmousemove() {
		return doubleOnmousemove;
	}

	public void setDoubleOnmousemove(String doubleOnmousemove) {
		this.doubleOnmousemove = doubleOnmousemove;
	}

	public String getDoubleOnmouseout() {
		return doubleOnmouseout;
	}

	public void setDoubleOnmouseout(String doubleOnmouseout) {
		this.doubleOnmouseout = doubleOnmouseout;
	}

	public String getDoubleOnmouseover() {
		return doubleOnmouseover;
	}

	public void setDoubleOnmouseover(String doubleOnmouseover) {
		this.doubleOnmouseover = doubleOnmouseover;
	}

	public String getDoubleOnmouseup() {
		return doubleOnmouseup;
	}

	public void setDoubleOnmouseup(String doubleOnmouseup) {
		this.doubleOnmouseup = doubleOnmouseup;
	}

	public String getDoubleOnselect() {
		return doubleOnselect;
	}

	public void setDoubleOnselect(String doubleOnselect) {
		this.doubleOnselect = doubleOnselect;
	}

	public String getDoubleSize() {
		return doubleSize;
	}

	public void setDoubleSize(String doubleSize) {
		this.doubleSize = doubleSize;
	}

	public String getDoubleList() {
		return doubleList;
	}

	public String getDoubleListKey() {
		return doubleListKey;
	}

	public String getDoubleListValue() {
		return doubleListValue;
	}

	public String getDoubleName() {
		return doubleName;
	}

	public String getDoubleValue() {
		return doubleValue;
	}

	public String getFormName() {
		return formName;
	}
	
	public void setEmptyOption(String emptyOption) {
        this.emptyOption = emptyOption;
    }

    public void setHeaderKey(String headerKey) {
        this.headerKey = headerKey;
    }

    public void setHeaderValue(String headerValue) {
        this.headerValue = headerValue;
    }

    public void setMultiple(String multiple) {
        this.multiple = multiple;
    }

    public void setSize(String size) {
        this.size = size;
    }
    
    public void setDoubleAccesskey(String doubleAccesskey) {
    	this.doubleAccesskey = doubleAccesskey;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/AbstractListTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import org.apache.struts2.components.ListUIBean;

/**
 */
public abstract class AbstractListTag extends AbstractUITag {
    protected String list;
    protected String listKey;
    protected String listValue;

    protected void populateParams() {
        super.populateParams();

        ListUIBean listUIBean = ((ListUIBean) component);
        listUIBean.setList(list);
        listUIBean.setListKey(listKey);
        listUIBean.setListValue(listValue);
    }

    public void setList(String list) {
        this.list = list;
    }

    public void setListKey(String listKey) {
        this.listKey = listKey;
    }

    public void setListValue(String listValue) {
        this.listValue = listValue;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/AbstractRequiredListTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;


import org.apache.struts2.components.ListUIBean;

/**
 */
public abstract class AbstractRequiredListTag extends AbstractListTag {

	protected void populateParams() {
		super.populateParams();
		
		ListUIBean listUIBean = (ListUIBean) component;
		listUIBean.setThrowExceptionOnNullValueAttribute(true);
	}

}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/AbstractUITag.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import org.apache.struts2.components.UIBean;
import org.apache.struts2.views.jsp.ComponentTagSupport;


/**
 * Abstract base class for all UI tags.
 *
 */
public abstract class AbstractUITag extends ComponentTagSupport {
    protected String cssClass;
    protected String cssStyle;
    protected String title;
    protected String disabled;
    protected String label;
    protected String labelPosition;
    protected String requiredposition;
    protected String name;
    protected String required;
    protected String tabindex;
    protected String value;
    protected String template;
    protected String theme;
    protected String templateDir;
    protected String onclick;
    protected String ondblclick;
    protected String onmousedown;
    protected String onmouseup;
    protected String onmouseover;
    protected String onmousemove;
    protected String onmouseout;
    protected String onfocus;
    protected String onblur;
    protected String onkeypress;
    protected String onkeydown;
    protected String onkeyup;
    protected String onselect;
    protected String onchange;
    protected String accesskey;
    
    // tooltip attributes
    protected String tooltip;
    protected String tooltipConfig;


    protected void populateParams() {
        super.populateParams();

        UIBean uiBean = (UIBean) component;
        uiBean.setCssClass(cssClass);
        uiBean.setCssClass(cssClass);
        uiBean.setCssStyle(cssStyle);
        uiBean.setTitle(title);
        uiBean.setDisabled(disabled);
        uiBean.setLabel(label);
        uiBean.setLabelposition(labelPosition);
        uiBean.setRequiredposition(requiredposition);
        uiBean.setName(name);
        uiBean.setRequired(required);
        uiBean.setTabindex(tabindex);
        uiBean.setValue(value);
        uiBean.setTemplate(template);
        uiBean.setTheme(theme);
        uiBean.setTemplateDir(templateDir);
        uiBean.setOnclick(onclick);
        uiBean.setOndblclick(ondblclick);
        uiBean.setOnmousedown(onmousedown);
        uiBean.setOnmouseup(onmouseup);
        uiBean.setOnmouseover(onmouseover);
        uiBean.setOnmousemove(onmousemove);
        uiBean.setOnmouseout(onmouseout);
        uiBean.setOnfocus(onfocus);
        uiBean.setOnblur(onblur);
        uiBean.setOnkeypress(onkeypress);
        uiBean.setOnkeydown(onkeydown);
        uiBean.setOnkeyup(onkeyup);
        uiBean.setOnselect(onselect);
        uiBean.setOnchange(onchange);
        uiBean.setTooltip(tooltip);
        uiBean.setTooltipConfig(tooltipConfig);
        uiBean.setAccesskey(accesskey);
    }

    public void setCssClass(String cssClass) {
        this.cssClass = cssClass;
    }

    public void setCssStyle(String cssStyle) {
        this.cssStyle = cssStyle;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public void setDisabled(String disabled) {
        this.disabled = disabled;
    }

    public void setLabel(String label) {
        this.label = label;
    }

    public void setLabelposition(String labelPosition) {
        this.labelPosition = labelPosition;
    }

    public void setRequiredposition(String requiredPosition) {
        this.requiredposition = requiredPosition;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setRequired(String required) {
        this.required = required;
    }

    public void setTabindex(String tabindex) {
        this.tabindex = tabindex;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public void setTemplateDir(String templateDir) {
    	this.templateDir = templateDir;
    }
    
    public void setTemplate(String template) {
        this.template = template;
    }

    public void setTheme(String theme) {
        this.theme = theme;
    }

    public void setOnclick(String onclick) {
        this.onclick = onclick;
    }

    public void setOndblclick(String ondblclick) {
        this.ondblclick = ondblclick;
    }

    public void setOnmousedown(String onmousedown) {
        this.onmousedown = onmousedown;
    }

    public void setOnmouseup(String onmouseup) {
        this.onmouseup = onmouseup;
    }

    public void setOnmouseover(String onmouseover) {
        this.onmouseover = onmouseover;
    }

    public void setOnmousemove(String onmousemove) {
        this.onmousemove = onmousemove;
    }

    public void setOnmouseout(String onmouseout) {
        this.onmouseout = onmouseout;
    }

    public void setOnfocus(String onfocus) {
        this.onfocus = onfocus;
    }

    public void setOnblur(String onblur) {
        this.onblur = onblur;
    }

    public void setOnkeypress(String onkeypress) {
        this.onkeypress = onkeypress;
    }

    public void setOnkeydown(String onkeydown) {
        this.onkeydown = onkeydown;
    }

    public void setOnkeyup(String onkeyup) {
        this.onkeyup = onkeyup;
    }

    public void setOnselect(String onselect) {
        this.onselect = onselect;
    }

    public void setOnchange(String onchange) {
        this.onchange = onchange;
    }
    
    public void setTooltip(String tooltip) {
    	this.tooltip = tooltip;
    }
    
    public void setTooltipConfig(String tooltipConfig) {
    	this.tooltipConfig = tooltipConfig;
    }
    
    public void setAccesskey(String accesskey) {
    	this.accesskey = accesskey;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/ActionErrorTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.ActionError;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * ActionError Tag.
 * 
 */
public class ActionErrorTag extends AbstractUITag {

	private static final long serialVersionUID = -3710234378022378639L;

	public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
		return new ActionError(stack, req, res);
	}

}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/ActionMessageTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.ActionMessage;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * ActionMessage Tag.
 * 
 */
public class ActionMessageTag extends AbstractUITag {

	private static final long serialVersionUID = 243396927554182506L;

	public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
		return new ActionMessage(stack, req, res);
	}
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/AnchorTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Anchor;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Anchor
 */
public class AnchorTag extends AbstractClosingTag {
	
	private static final long serialVersionUID = -1034616578492431113L;
	
	protected String href;
    protected String errorText;
    protected String showErrorTransportText;
    protected String notifyTopics;
    protected String afterLoading;
    protected String preInvokeJS;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Anchor(stack, req, res);
    }

    protected void populateParams() {
        super.populateParams();

        Anchor link = (Anchor) component;
        
        link.setHref(href);
        link.setErrorText(errorText);
        link.setShowErrorTransportText(showErrorTransportText);
        link.setNotifyTopics(notifyTopics);
        link.setAfterLoading(afterLoading);
        link.setPreInvokeJS(preInvokeJS);
    }

    public void setHref(String href) {
        this.href = href;
    }

    public void setErrorText(String errorText) {
        this.errorText = errorText;
    }

    public void setShowErrorTransportText(String showErrorTransportText) {
        this.showErrorTransportText = showErrorTransportText;
    }

    public void setNotifyTopics(String notifyTopics) {
        this.notifyTopics = notifyTopics;
    }

    public void setAfterLoading(String afterLoading) {
        this.afterLoading = afterLoading;
    }

    public void setPreInvokeJS(String preInvokeJS) {
        this.preInvokeJS = preInvokeJS;
    }
}

"
core/src/main/java/org/apache/struts2/views/jsp/ui/CheckboxListTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.CheckboxList;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * @see CheckboxList
 */
public class CheckboxListTag extends AbstractRequiredListTag {
	
	private static final long serialVersionUID = 4023034029558150010L;

	public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new CheckboxList(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/CheckboxTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Checkbox;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * @see Checkbox
 */
public class CheckboxTag extends AbstractUITag {
	
	private static final long serialVersionUID = -350752809266337636L;
	
	protected String fieldValue;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Checkbox(stack, req, res);
    }

    protected void populateParams() {
        super.populateParams();

        ((Checkbox) component).setFieldValue(fieldValue);
    }

    public void setFieldValue(String aValue) {
        this.fieldValue = aValue;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/ComboBoxTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.ComboBox;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see ComboBox
 */
public class ComboBoxTag extends TextFieldTag {
	
	private static final long serialVersionUID = 3509392460170385605L;
	
	protected String list;
	protected String listKey;
	protected String listValue;
	protected String headerKey;
	protected String headerValue;
	protected String emptyOption;

    public void setEmptyOption(String emptyOption) {
		this.emptyOption = emptyOption;
	}

	public void setHeaderKey(String headerKey) {
		this.headerKey = headerKey;
	}

	public void setHeaderValue(String headerValue) {
		this.headerValue = headerValue;
	}

	public void setListKey(String listKey) {
		this.listKey = listKey;
	}

	public void setListValue(String listValue) {
		this.listValue = listValue;
	}

	public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new ComboBox(stack, req, res);
    }

    protected void populateParams() {
        super.populateParams();

        ((ComboBox) component).setList(list);
        ((ComboBox) component).setListKey(listKey);
        ((ComboBox) component).setListValue(listValue);
        ((ComboBox) component).setHeaderKey(headerKey);
        ((ComboBox) component).setHeaderValue(headerValue);
        ((ComboBox) component).setEmptyOption(emptyOption);
    }

    public void setList(String list) {
        this.list = list;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/ComponentTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.GenericUIBean;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see GenericUIBean
 */
public class ComponentTag extends AbstractUITag {
	
	private static final long serialVersionUID = 5448365363044104731L;

	public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new GenericUIBean(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/DatePickerTag.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.DatePicker;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see DatePicker
 */
public class DatePickerTag extends TextFieldTag {

	private static final long serialVersionUID = 4054114507143447232L;
	
    protected String format;
    protected String dateIconPath;
    protected String templatePath;
    protected String templateCssPath;
    

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new DatePicker(stack, req, res);
    }

    protected void populateParams() {
        super.populateParams();

        final DatePicker datePicker = (DatePicker) component;
        datePicker.setFormat(format);
        datePicker.setDateIconPath(dateIconPath);
        datePicker.setTemplatePath(templatePath);
        datePicker.setTemplateCssPath(templateCssPath);
    }

    public void setFormat(String format) {
        this.format = format;
    }
    
    public void setDateIconPath(String dateIconPath) {
    	this.dateIconPath = dateIconPath;
    }
    
    public void setTemplatePath(String templatePath) {
    	this.templatePath = templatePath;
    }
    
    public void setTemplateCssPath(String templateCsspath) {
    	this.templateCssPath = templateCsspath;
    }

}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/DebugTag.java,false,"package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Debug;

import com.opensymphony.xwork2.util.OgnlValueStack;

public class DebugTag extends AbstractUITag {

    private static final long serialVersionUID = 3487684841317160628L;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Debug(stack, req, res);
    }

}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/DivTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Div;

import com.opensymphony.xwork2.util.OgnlValueStack;

public class DivTag extends AbstractClosingTag {
	
	private static final long serialVersionUID = 5309231035916461758L;
	
	protected String href;
    protected String updateFreq;
    protected String delay="1";
    protected String loadingText;
    protected String errorText;
    protected String showErrorTransportText;
    protected String listenTopics;
    protected String afterLoading;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Div(stack, req, res);
    }

    protected void populateParams() {
        super.populateParams();

        Div div = (Div) component;
        div.setHref(href);
        div.setUpdateFreq(updateFreq);
        div.setDelay(delay);
        div.setLoadingText(loadingText);
        div.setErrorText(errorText);
        div.setShowErrorTransportText(showErrorTransportText);
        div.setListenTopics(listenTopics);
        div.setAfterLoading(afterLoading);
    }

    public void setHref(String href) {
        this.href = href;
    }

    public void setUpdateFreq(String updateFreq) {
        this.updateFreq = updateFreq;
    }

    public void setDelay(String delay) {
        this.delay = delay;
    }

    public void setLoadingText(String loadingText) {
        this.loadingText = loadingText;
    }

    public void setErrorText(String errorText) {
        this.errorText = errorText;
    }

    public void setShowErrorTransportText(String showErrorTransportText) {
        this.showErrorTransportText = showErrorTransportText;
    }

    public void setListenTopics(String listenTopics) {
        this.listenTopics = listenTopics;
    }

    public void setAfterLoading(String afterLoading) {
        this.afterLoading = afterLoading;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/DoubleSelectTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.DoubleSelect;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see DoubleSelect
 */
public class DoubleSelectTag extends AbstractDoubleListTag {
    
	private static final long serialVersionUID = 7426011596359509386L;

	public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new DoubleSelect(stack, req, res);
    }

    protected void populateParams() {
        super.populateParams();

        DoubleSelect doubleSelect = ((DoubleSelect) component);
        doubleSelect.setEmptyOption(emptyOption);
        doubleSelect.setHeaderKey(headerKey);
        doubleSelect.setHeaderValue(headerValue);
        doubleSelect.setMultiple(multiple);
        doubleSelect.setSize(size);
        
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/FieldErrorTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.FieldError;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * FieldError Tag.
 */
public class FieldErrorTag extends AbstractUITag {

	private static final long serialVersionUID = -182532967507726323L;

	public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
		return new FieldError(stack, req, res);
	}
}

"
core/src/main/java/org/apache/struts2/views/jsp/ui/FileTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.File;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * @see File
 */
public class FileTag extends AbstractUITag {
	
	private static final long serialVersionUID = -2154950640215144864L;
	
	protected String accept;
    protected String size;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new File(stack, req, res);
    }

    protected void populateParams() {
        super.populateParams();

        File file = ((File) component);
        file.setAccept(accept);
        file.setSize(size);
    }

    public void setAccept(String accept) {
        this.accept = accept;
    }

    public void setSize(String size) {
        this.size = size;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/FormTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Form;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * @see Form
 */
public class FormTag extends AbstractClosingTag {
	
	private static final long serialVersionUID = 2792301046860819658L;
	
	protected String action;
    protected String target;
    protected String enctype;
    protected String method;
    protected String namespace;
    protected String validate;
    protected String onsubmit;
    protected String portletMode;
    protected String windowState;
    protected String acceptcharset;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Form(stack, req, res);
    }

    protected void populateParams() {
        super.populateParams();
        Form form = ((Form) component);
        form.setAction(action);
        form.setTarget(target);
        form.setEnctype(enctype);
        form.setMethod(method);
        form.setNamespace(namespace);
        form.setValidate(validate);
        form.setOnsubmit(onsubmit);
        form.setPortletMode(portletMode);
        form.setWindowState(windowState);
        form.setAcceptcharset(acceptcharset);
    }


    public void setAction(String action) {
        this.action = action;
    }

    public void setTarget(String target) {
        this.target = target;
    }

    public void setEnctype(String enctype) {
        this.enctype = enctype;
    }

    public void setMethod(String method) {
        this.method = method;
    }

    public void setNamespace(String namespace) {
        this.namespace = namespace;
    }

    public void setValidate(String validate) {
        this.validate = validate;
    }

    public void setOnsubmit(String onsubmit) {
        this.onsubmit = onsubmit;
    }

    public void setPortletMode(String portletMode) {
        this.portletMode = portletMode;
    }

    public void setWindowState(String windowState) {
        this.windowState = windowState;
    }

    public void setAcceptcharset(String acceptcharset) {
        this.acceptcharset = acceptcharset;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/HeadTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Head;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Head
 */
public class HeadTag extends AbstractUITag {

	private static final long serialVersionUID = 6876765769175246030L;
	
	private String calendarcss;
    private String debug;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Head(stack, req, res);
    }

    protected void populateParams() {
        super.populateParams();
        if (calendarcss != null) {
        	((Head) component).setCalendarcss(calendarcss);
        }
        if (debug != null) {
        	((Head) component).setDebug(Boolean.valueOf(debug).booleanValue());
        }
    }

    public String getCalendarcss() {
        return calendarcss;
    }

    public void setCalendarcss(String calendarcss) {
        this.calendarcss = calendarcss;
    }

    public void setDebug(String debug) {
        this.debug = debug;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/HiddenTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Hidden;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * @see Hidden
 */
public class HiddenTag extends AbstractUITag {
	
	private static final long serialVersionUID = -1124367972048371675L;

	public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Hidden(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/LabelTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Label;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * @see Label
 */
public class LabelTag extends AbstractUITag {
	
	private static final long serialVersionUID = 4008321310097730458L;
	
	protected String forAttr;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Label(stack, req, res);
    }

    protected void populateParams() {
        super.populateParams();

        ((Label) component).setFor(forAttr);
    }

    public void setFor(String aFor) {
        this.forAttr = aFor;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/OgnlTool.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import ognl.Ognl;
import ognl.OgnlException;

import com.opensymphony.xwork2.util.OgnlUtil;


/**
 */
public class OgnlTool {
    private static OgnlTool instance = new OgnlTool();

    private OgnlTool() {
    }

    public static OgnlTool getInstance() {
        return instance;
    }

    public Object findValue(String expr, Object context) {
        try {
            return Ognl.getValue(OgnlUtil.compile(expr), context);
        } catch (OgnlException e) {
            return null;
        }
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/OptGroupTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.OptGroup;
import org.apache.struts2.views.jsp.ComponentTagSupport;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * 
 */
public class OptGroupTag extends ComponentTagSupport {

	private static final long serialVersionUID = 7367401003498678762L;

	protected String list;
	protected String label;
	protected String disabled;
	protected String listKey;
	protected String listValue;
	
	public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
		return new OptGroup(stack, req, res);
	}

	protected void populateParams() {
		super.populateParams();
		
		OptGroup optGroup = (OptGroup) component;
		optGroup.setList(list);
		optGroup.setLabel(label);
		optGroup.setDisabled(disabled);
		optGroup.setListKey(listKey);
		optGroup.setListValue(listValue);
	}
	
	public void setList(String list) {
		this.list = list;
	}
	
	public void setLabel(String label) {
		this.label = label;
	}
	
	public void setDisabled(String disabled) {
		this.disabled = disabled;
	}
	
	public void setListKey(String listKey) {
		this.listKey = listKey;
	}

	public void setListValue(String listValue) {
		this.listValue = listValue;
	}
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/OptionTransferSelectTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.OptionTransferSelect;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * OptionTransferSelect jsp tag.
 */
public class OptionTransferSelectTag extends AbstractDoubleListTag {

	private static final long serialVersionUID = 250474334495763536L;
	
	protected String allowAddToLeft;
	protected String allowAddToRight;
	protected String allowAddAllToLeft;
	protected String allowAddAllToRight;
	protected String allowSelectAll;
	protected String allowUpDownOnLeft;
	protected String allowUpDownOnRight;
	
	protected String leftTitle;
	protected String rightTitle;
	
	protected String buttonCssClass;
	protected String buttonCssStyle;

	protected String addToLeftLabel;
	protected String addToRightLabel;
	protected String addAllToLeftLabel;
	protected String addAllToRightLabel;
	protected String selectAllLabel;
	protected String leftUpLabel;
	protected String leftDownLabel;
	protected String rightUpLabel;
	protected String rightDownLabel;
	
	
	public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
		return new OptionTransferSelect(stack, req, res);
	}
	
	protected void populateParams() {
		super.populateParams();
		
		OptionTransferSelect optionTransferSelect = (OptionTransferSelect) component;
		optionTransferSelect.setAllowAddToLeft(allowAddToLeft);
		optionTransferSelect.setAllowAddToRight(allowAddToRight);
		optionTransferSelect.setAllowAddAllToLeft(allowAddAllToLeft);
		optionTransferSelect.setAllowAddAllToRight(allowAddAllToRight);
		optionTransferSelect.setAllowSelectAll(allowSelectAll);
		optionTransferSelect.setAllowUpDownOnLeft(allowUpDownOnLeft);
		optionTransferSelect.setAllowUpDownOnRight(allowUpDownOnRight);
		
		optionTransferSelect.setAddToLeftLabel(addToLeftLabel);
		optionTransferSelect.setAddToRightLabel(addToRightLabel);
		optionTransferSelect.setAddAllToLeftLabel(addAllToLeftLabel);
		optionTransferSelect.setAddAllToRightLabel(addAllToRightLabel);
		optionTransferSelect.setSelectAllLabel(selectAllLabel);
		optionTransferSelect.setLeftUpLabel(leftUpLabel);
		optionTransferSelect.setLeftDownLabel(leftDownLabel);
		optionTransferSelect.setRightUpLabel(rightUpLabel);
		optionTransferSelect.setRightDownLabel(rightDownLabel);
		
		optionTransferSelect.setButtonCssClass(buttonCssClass);
		optionTransferSelect.setButtonCssStyle(buttonCssStyle);
		
		optionTransferSelect.setLeftTitle(leftTitle);
		optionTransferSelect.setRightTitle(rightTitle);
	}


	public String getAddAllToLeftLabel() {
		return addAllToLeftLabel;
	}


	public void setAddAllToLeftLabel(String addAllToLeftLabel) {
		this.addAllToLeftLabel = addAllToLeftLabel;
	}


	public String getAddAllToRightLabel() {
		return addAllToRightLabel;
	}


	public void setAddAllToRightLabel(String addAllToRightLabel) {
		this.addAllToRightLabel = addAllToRightLabel;
	}


	public String getAddToLeftLabel() {
		return addToLeftLabel;
	}


	public void setAddToLeftLabel(String addToLeftLabel) {
		this.addToLeftLabel = addToLeftLabel;
	}


	public String getAddToRightLabel() {
		return addToRightLabel;
	}


	public void setAddToRightLabel(String addToRightLabel) {
		this.addToRightLabel = addToRightLabel;
	}


	public String getAllowAddAllToLeft() {
		return allowAddAllToLeft;
	}


	public void setAllowAddAllToLeft(String allowAddAllToLeft) {
		this.allowAddAllToLeft = allowAddAllToLeft;
	}


	public String getAllowAddAllToRight() {
		return allowAddAllToRight;
	}


	public void setAllowAddAllToRight(String allowAddAllToRight) {
		this.allowAddAllToRight = allowAddAllToRight;
	}


	public String getAllowAddToLeft() {
		return allowAddToLeft;
	}


	public void setAllowAddToLeft(String allowAddToLeft) {
		this.allowAddToLeft = allowAddToLeft;
	}


	public String getAllowAddToRight() {
		return allowAddToRight;
	}


	public void setAllowAddToRight(String allowAddToRight) {
		this.allowAddToRight = allowAddToRight;
	}


	public String getLeftTitle() {
		return leftTitle;
	}


	public void setLeftTitle(String leftTitle) {
		this.leftTitle = leftTitle;
	}


	public String getRightTitle() {
		return rightTitle;
	}


	public void setRightTitle(String rightTitle) {
		this.rightTitle = rightTitle;
	}
	
	
	public void setAllowSelectAll(String allowSelectAll) {
		this.allowSelectAll = allowSelectAll;
	}
	
	public String getAllowSelectAll() {
		return this.allowSelectAll;
	}
	
	public void setSelectAllLabel(String selectAllLabel) {
		this.selectAllLabel = selectAllLabel;
	}
	
	public String getSelectAllLabel() {
		return this.selectAllLabel;
	}
	
	public void setButtonCssClass(String buttonCssId) {
		this.buttonCssClass = buttonCssId;
	}
	
	public String getButtonCssClass() {
		return buttonCssClass;
	}
	
	public void setButtonCssStyle(String buttonCssStyle) {
		this.buttonCssStyle = buttonCssStyle;
	}
	
	public String getButtonCssStyle() {
		return this.buttonCssStyle;
	}
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/PanelTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Panel;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Panel
 */
public class PanelTag extends DivTag {
	
	private static final long serialVersionUID = -1698805503599998611L;
	
	protected String tabName;
    protected String subscribeTopicName;
    protected String remote;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Panel(stack, req, res);
    }

    protected void populateParams() {
        super.populateParams();

        Panel panel = ((Panel) component);
        panel.setTabName(tabName);
        panel.setSubscribeTopicName(subscribeTopicName);
        panel.setRemote(remote);
    }

    public void setTabName(String tabName) {
        this.tabName = tabName;
    }

    public void setSubscribeTopicName(String subscribeTopicName) {
        this.subscribeTopicName = subscribeTopicName;
    }

    public void setRemote(String remote) {
        this.remote = remote;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/PasswordTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Password;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * @see Password
 */
public class PasswordTag extends TextFieldTag {
	
	private static final long serialVersionUID = 6802043323617377573L;
	
	protected String showPassword;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Password(stack, req, res);
    }

    protected void populateParams() {
        super.populateParams();

        ((Password) component).setShowPassword(showPassword);
    }

    public void setShow(String showPassword) {
        this.showPassword = showPassword;
    }

    public void setShowPassword(String showPassword) {
        this.showPassword = showPassword;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/RadioTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Radio;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * @see Radio
 */
public class RadioTag extends AbstractRequiredListTag {
	
	private static final long serialVersionUID = -6497403399521333624L;

	public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Radio(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/ResetTag.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Reset;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see org.apache.struts2.components.Reset
 */
public class ResetTag extends AbstractUITag {
	
	private static final long serialVersionUID = 4742704832277392108L;
	
	protected String action;
    protected String method;
    protected String align;
    protected String type;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Reset(stack, req, res);
    }

    protected void populateParams() {
        super.populateParams();

        Reset reset = ((Reset) component);
        reset.setAction(action);
        reset.setMethod(method);
        reset.setAlign(align);
        reset.setType(type);
    }

    public void setAction(String action) {
        this.action = action;
    }

    public void setMethod(String method) {
        this.method = method;
    }

    public void setAlign(String align) {
        this.align = align;
    }

    public void setType(String type) {
        this.type = type;
    }

}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/SelectTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Select;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * @see Select
 */
public class SelectTag extends AbstractRequiredListTag {
	
	private static final long serialVersionUID = 6121715260335609618L;
	
	protected String emptyOption;
    protected String headerKey;
    protected String headerValue;
    protected String multiple;
    protected String size;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Select(stack, req, res);
    }

    protected void populateParams() {
        super.populateParams();

        Select select = ((Select) component);
        select.setEmptyOption(emptyOption);
        select.setHeaderKey(headerKey);
        select.setHeaderValue(headerValue);
        select.setMultiple(multiple);
        select.setSize(size);
    }

    public void setEmptyOption(String emptyOption) {
        this.emptyOption = emptyOption;
    }

    public void setHeaderKey(String headerKey) {
        this.headerKey = headerKey;
    }

    public void setHeaderValue(String headerValue) {
        this.headerValue = headerValue;
    }

    public void setMultiple(String multiple) {
        this.multiple = multiple;
    }

    public void setSize(String size) {
        this.size = size;
    }

}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/SubmitTag.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Submit;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Submit
 */
public class SubmitTag extends AbstractUITag {
	
	private static final long serialVersionUID = 2179281109958301343L;
	
	protected String action;
    protected String method;
    protected String align;
    protected String resultDivId;
    protected String onLoadJS;
    protected String notifyTopics;
    protected String listenTopics;
    protected String preInvokeJS;
    protected String type;
    protected String src;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Submit(stack, req, res);
    }

    protected void populateParams() {
        super.populateParams();

        Submit submit = ((Submit) component);
        submit.setAction(action);
        submit.setMethod(method);
        submit.setAlign(align);
        submit.setResultDivId(resultDivId);
        submit.setOnLoadJS(onLoadJS);
        submit.setNotifyTopics(notifyTopics);
        submit.setListenTopics(listenTopics);
        submit.setPreInvokeJS(preInvokeJS);
        submit.setType(type);
        submit.setSrc(src);
    }

    public void setAction(String action) {
        this.action = action;
    }

    public void setMethod(String method) {
        this.method = method;
    }

    public void setAlign(String align) {
        this.align = align;
    }

    public void setResultDivId(String resultDivId) {
        this.resultDivId = resultDivId;
    }

    public void setOnLoadJS(String onLoadJS) {
        this.onLoadJS = onLoadJS;
    }

    public void setNotifyTopics(String notifyTopics) {
        this.notifyTopics = notifyTopics;
    }

    public void setListenTopics(String listenTopics) {
        this.listenTopics = listenTopics;
    }

    public void setPreInvokeJS(String preInvokeJS) {
        this.preInvokeJS = preInvokeJS;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public String getSrc() {
        return src;
    }

    public void setSrc(String src) {
        this.src = src;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/TabbedPanelTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import java.util.List;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Panel;
import org.apache.struts2.components.TabbedPanel;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see TabbedPanel
 */
public class TabbedPanelTag extends AbstractClosingTag {
	
	private static final long serialVersionUID = -4719930205515386252L;

	public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new TabbedPanel(stack, req, res);
    }

    public List getTabs() {
        return ((TabbedPanel) component).getTabs();
    }

    public void addTab(Panel pane) {
        ((TabbedPanel) component).addTab(pane);
    }

}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/TextareaTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.TextArea;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * @see TextArea
 */
public class TextareaTag extends AbstractUITag {
	
	private static final long serialVersionUID = -4107122506712927927L;
	
	protected String cols;
    protected String readonly;
    protected String rows;
    protected String wrap;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new TextArea(stack, req, res);
    }

    protected void populateParams() {
        super.populateParams();

        TextArea textArea = ((TextArea) component);
        textArea.setCols(cols);
        textArea.setReadonly(readonly);
        textArea.setRows(rows);
        textArea.setWrap(wrap);
    }

    public void setCols(String cols) {
        this.cols = cols;
    }

    public void setReadonly(String readonly) {
        this.readonly = readonly;
    }

    public void setRows(String rows) {
        this.rows = rows;
    }

    public void setWrap(String wrap) {
        this.wrap = wrap;
    }

}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/TextFieldTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.TextField;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see TextField
 */
public class TextFieldTag extends AbstractUITag {
	
	private static final long serialVersionUID = 5811285953670562288L;

	protected String maxlength;
    protected String readonly;
    protected String size;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new TextField(stack, req, res);
    }

    protected void populateParams() {
        super.populateParams();

        TextField textField = ((TextField) component);
        textField.setMaxlength(maxlength);
        textField.setReadonly(readonly);
        textField.setSize(size);
    }

    /**
     * @deprecated please use {@link #setMaxlength} instead
     */
    public void setMaxLength(String maxlength) {
        this.maxlength = maxlength;
    }

    public void setMaxlength(String maxlength) {
        this.maxlength = maxlength;
    }

    public void setReadonly(String readonly) {
        this.readonly = readonly;
    }

    public void setSize(String size) {
        this.size = size;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/TimePickerTag.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.TimePicker;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @version $Date$ $Id$
 */
public class TimePickerTag extends TextFieldTag {

	private static final long serialVersionUID = 3527737048468381376L;
	
	protected String format;
	protected String timeIconPath;
	protected String templatePath;
	protected String templateCssPath;

	public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
		return new TimePicker(stack, req, res);
	}
	
	protected void populateParams() {
		super.populateParams();
		
		final TimePicker timePicker = (TimePicker) component;
		timePicker.setFormat(format);
		timePicker.setTimeIconPath(timeIconPath);
		timePicker.setTemplatePath(templatePath);
		timePicker.setTemplateCssPath(templateCssPath);
	}
	
	public void setFormat(String format) {
        this.format = format;
    }
    
    public void setTimeIconPath(String timeIconPath) {
    	this.timeIconPath = timeIconPath;
    }
    
    public void setTemplatePath(String templatePath) {
    	this.templatePath = templatePath;
    }
    
    public void setTemplateCssPath(String templateCssPath) {
    	this.templateCssPath = templateCssPath;
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/TokenTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Token;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * @see Token
 */
public class TokenTag extends AbstractUITag {
	
	private static final long serialVersionUID = 722480798151703457L;

	public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Token(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/TreeNodeTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.TreeNode;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see TreeNode
 */
public class TreeNodeTag extends AbstractClosingTag {
	
	private static final long serialVersionUID = 7340746943017900803L;
	

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new TreeNode(stack,req,res);
    }

    public void setLabel(String label) {
        this.label = label;
    }

    // NOTE: not necessary, label property is inherited, will be populated 
    // by super-class
    /*protected void populateParams() {
        if (label != null) {
            TreeNode treeNode = (TreeNode)component;
            treeNode.setLabel(label);
        }
        super.populateParams();
    }*/
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/TreeTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Tree;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Tree
 */
public class TreeTag extends AbstractClosingTag {
	
	private static final long serialVersionUID = 2735218501058548013L;
	
	private String toggle;
    private String treeSelectedTopic;
    private String treeExpandedTopic;
    private String treeCollapsedTopic; 
    private String rootNode;
    private String childCollectionProperty;
    private String nodeTitleProperty;
    private String nodeIdProperty;
    private String showRootGrid;
    
    private String showGrid;
	private String blankIconSrc;
	private String gridIconSrcL;
	private String gridIconSrcV;
	private String gridIconSrcP;
	private String gridIconSrcC;
	private String gridIconSrcX;
	private String gridIconSrcY;
	private String expandIconSrcPlus;
	private String expandIconSrcMinus;
	private String iconWidth;
	private String iconHeight;
	private String toggleDuration;
    private String templateCssPath;
     

	public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Tree(stack,req,res);
    }

    protected void populateParams() {
        super.populateParams();

        Tree tree = (Tree) component;
        if (childCollectionProperty != null)
        	tree.setChildCollectionProperty(childCollectionProperty);
        if (nodeIdProperty != null)
        	tree.setNodeIdProperty(nodeIdProperty);
        if (nodeTitleProperty != null)
        	tree.setNodeTitleProperty(nodeTitleProperty);
        if (rootNode != null)
        	tree.setRootNode(rootNode);
        if (toggle != null)
        	tree.setToggle(toggle);
        if (treeCollapsedTopic != null)
        	tree.setTreeCollapsedTopic(treeCollapsedTopic);
        if (treeExpandedTopic != null)
        	tree.setTreeExpandedTopic(treeExpandedTopic);
        if (treeSelectedTopic != null)
        	tree.setTreeSelectedTopic(treeSelectedTopic);
        if (showRootGrid != null)
        	tree.setShowRootGrid(showRootGrid);
        
        if (showGrid != null)
        	tree.setShowGrid(showGrid);
        if (blankIconSrc != null)
        	tree.setBlankIconSrc(blankIconSrc);
        if (gridIconSrcL != null)
        	tree.setGridIconSrcL(gridIconSrcC);
        if (gridIconSrcV != null) 
        	tree.setGridIconSrcV(gridIconSrcV);
        if (gridIconSrcP != null)
        	tree.setGridIconSrcP(gridIconSrcP);
        if (gridIconSrcC != null)
        	tree.setGridIconSrcC(gridIconSrcC);
        if (gridIconSrcX != null)
        	tree.setGridIconSrcX(gridIconSrcX);
        if (gridIconSrcY != null)
        	tree.setGridIconSrcY(gridIconSrcY);
        if (expandIconSrcPlus != null) 
        	tree.setExpandIconSrcPlus(expandIconSrcPlus);
    	if (expandIconSrcMinus != null) 
    		tree.setExpandIconSrcMinus(expandIconSrcMinus);
    	if (iconWidth != null) 
    		tree.setIconWidth(iconWidth);
    	if (iconHeight != null)
    		tree.setIconHeight(iconHeight);
    	if (toggleDuration != null)
    		tree.setToggleDuration(toggleDuration);
    	if (templateCssPath != null)
    		tree.setTemplateCssPath(templateCssPath);
    }

    public String getToggle() {
        return toggle;
    }

    public void setToggle(String toggle) {
        this.toggle = toggle;
    }

    public String getTreeSelectedTopic() {
        return treeSelectedTopic;
    }

    public void setTreeSelectedTopic(String treeSelectedTopic) {
        this.treeSelectedTopic = treeSelectedTopic;
    }

    public String getTreeExpandedTopic() {
        return treeExpandedTopic;
    }

    public void setTreeExpandedTopic(String treeExpandedTopic) {
        this.treeExpandedTopic = treeExpandedTopic;
    }

    public String getTreeCollapsedTopic() {
        return treeCollapsedTopic;
    }

    public void setTreeCollapsedTopic(String treeCollapsedTopic) {
        this.treeCollapsedTopic = treeCollapsedTopic;
    }

    public String getRootNode() {
        return rootNode;
    }

    public void setRootNode(String rootNode) {
        this.rootNode = rootNode;
    }

    public String getChildCollectionProperty() {
        return childCollectionProperty;
    }

    public void setChildCollectionProperty(String childCollectionProperty) {
        this.childCollectionProperty = childCollectionProperty;
    }

    public String getNodeTitleProperty() {
        return nodeTitleProperty;
    }

    public void setNodeTitleProperty(String nodeTitleProperty) {
        this.nodeTitleProperty = nodeTitleProperty;
    }

    public String getNodeIdProperty() {
        return nodeIdProperty;
    }

    public void setNodeIdProperty(String nodeIdProperty) {
        this.nodeIdProperty = nodeIdProperty;
    }
    
    public String getShowRootGrid() {
    	return showRootGrid;
    }
    
    public void setShowRootGrid(String showRootGrid) {
    	this.showRootGrid = showRootGrid;
    }
    
    public String getBlankIconSrc() {
		return blankIconSrc;
	}

	public void setBlankIconSrc(String blankIconSrc) {
		this.blankIconSrc = blankIconSrc;
	}

	public String getExpandIconSrcMinus() {
		return expandIconSrcMinus;
	}

	public void setExpandIconSrcMinus(String expandIconSrcMinus) {
		this.expandIconSrcMinus = expandIconSrcMinus;
	}

	public String getExpandIconSrcPlus() {
		return expandIconSrcPlus;
	}

	public void setExpandIconSrcPlus(String expandIconSrcPlus) {
		this.expandIconSrcPlus = expandIconSrcPlus;
	}

	public String getGridIconSrcC() {
		return gridIconSrcC;
	}

	public void setGridIconSrcC(String gridIconSrcC) {
		this.gridIconSrcC = gridIconSrcC;
	}

	public String getGridIconSrcL() {
		return gridIconSrcL;
	}

	public void setGridIconSrcL(String gridIconSrcL) {
		this.gridIconSrcL = gridIconSrcL;
	}

	public String getGridIconSrcP() {
		return gridIconSrcP;
	}

	public void setGridIconSrcP(String gridIconSrcP) {
		this.gridIconSrcP = gridIconSrcP;
	}

	public String getGridIconSrcV() {
		return gridIconSrcV;
	}

	public void setGridIconSrcV(String gridIconSrcV) {
		this.gridIconSrcV = gridIconSrcV;
	}

	public String getGridIconSrcX() {
		return gridIconSrcX;
	}

	public void setGridIconSrcX(String gridIconSrcX) {
		this.gridIconSrcX = gridIconSrcX;
	}

	public String getGridIconSrcY() {
		return gridIconSrcY;
	}

	public void setGridIconSrcY(String gridIconSrcY) {
		this.gridIconSrcY = gridIconSrcY;
	}

	public String getIconHeight() {
		return iconHeight;
	}

	public void setIconHeight(String iconHeight) {
		this.iconHeight = iconHeight;
	}

	public String getIconWidth() {
		return iconWidth;
	}

	public void setIconWidth(String iconWidth) {
		this.iconWidth = iconWidth;
	}

	public String getTemplateCssPath() {
		return templateCssPath;
	}

	public void setTemplateCssPath(String templateCssPath) {
		this.templateCssPath = templateCssPath;
	}

	public String getToggleDuration() {
		return toggleDuration;
	}

	public void setToggleDuration(String toggleDuration) {
		this.toggleDuration = toggleDuration;
	}

	public String getShowGrid() {
		return showGrid;
	}

	public void setShowGrid(String showGrid) {
		this.showGrid = showGrid;
	}
}

"
core/src/main/java/org/apache/struts2/views/jsp/ui/UpDownSelectTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.UpDownSelect;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see UpDownSelect
 */
public class UpDownSelectTag extends SelectTag {

	private static final long serialVersionUID = -8136573053799541353L;
	
	protected String allowMoveUp;
	protected String allowMoveDown;
	protected String allowSelectAll;
	
	protected String moveUpLabel;
	protected String moveDownLabel;
	protected String selectAllLabel;
	
	
	public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
		return new UpDownSelect(stack, req, res);
	}
	
	protected void populateParams() {
		super.populateParams();
		
		UpDownSelect c = (UpDownSelect) component;
		
		c.setAllowMoveUp(allowMoveUp);
		c.setAllowMoveDown(allowMoveDown);
		c.setAllowSelectAll(allowSelectAll);
		
		c.setMoveUpLabel(moveUpLabel);
		c.setMoveDownLabel(moveDownLabel);
		c.setSelectAllLabel(selectAllLabel);
	
	}
	
	
	public String getAllowMoveUp() { 
		return allowMoveUp;
	}
	
	public void setAllowMoveUp(String allowMoveUp) {
		this.allowMoveUp = allowMoveUp;
	}
	
	
	
	public String getAllowMoveDown() {
		return allowMoveDown;
	}
	
	public void setAllowMoveDown(String allowMoveDown) {
		this.allowMoveDown = allowMoveDown;
	}
	
	
	
	public String getAllowSelectAll() {
		return allowSelectAll;
	}
	
	public void setAllowSelectAll(String allowSelectAll) {
		this.allowSelectAll = allowSelectAll;
	}
	
	
	public String getMoveUpLabel() {
		return moveUpLabel;
	}
	
	public void setMoveUpLabel(String moveUpLabel) {
		this.moveUpLabel = moveUpLabel;
	}
	
	
	
	public String getMoveDownLabel() {
		return moveDownLabel;
	}
	
	public void setMoveDownLabel(String moveDownLabel) {
		this.moveDownLabel = moveDownLabel;
	}
	

	
	public String getSelectAllLabel() {
		return selectAllLabel;
	}
	
	public void setSelectAllLabel(String selectAllLabel) {
		this.selectAllLabel = selectAllLabel;
	}
}
"
core/src/main/java/org/apache/struts2/views/jsp/ui/table/WebTableTag.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jsp.ui.table;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.table.WebTable;
import org.apache.struts2.views.jsp.ui.ComponentTag;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * @see WebTable
 */
public class WebTableTag extends ComponentTag {

	private static final long serialVersionUID = 2978932111492397942L;
	
	protected String sortOrder;
    protected String modelName;
    protected boolean sortable;
    protected int sortColumn;

    public Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new WebTable(stack, req, res);
    }

    protected void populateParams() {
        super.populateParams();

        WebTable table = (WebTable) component;
        table.setSortOrder(sortOrder);
        table.setSortable(sortable);
        table.setModelName(modelName);
        table.setSortOrder(sortOrder);
    }

    public void setSortOrder(String sortOrder) {
        this.sortOrder = sortOrder;
    }

    public void setModelName(String modelName) {
        this.modelName = modelName;
    }

    public void setSortable(boolean sortable) {
        this.sortable = sortable;
    }

    public void setSortColumn(int sortColumn) {
        this.sortColumn = sortColumn;
    }
}
"
core/src/main/java/org/apache/struts2/views/tiles/TilesResult.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.tiles;

import java.util.Locale;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.ServletActionContext;
import org.apache.struts2.dispatcher.ServletDispatcherResult;
import org.apache.tiles.ComponentContext;
import org.apache.tiles.ComponentDefinition;
import org.apache.tiles.ComponentDefinitions;
import org.apache.tiles.Controller;
import org.apache.tiles.DefinitionsFactory;
import org.apache.tiles.TilesUtilImpl;

import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.LocaleProvider;

/**
 * <!-- START SNIPPET: description -->
 * Renders a view using struts-tiles.
 * <!-- END SNIPPET: description -->
 *
 * <!-- START SNIPPET: webxml -->
 * In your web.xml file, you need to add a servlet entry for TilesServlet to load the tiles
 * definitions into the ServletContext.
 *
 * &lt;servlet&gt;
 *      &lt;servlet-name&gt;tiles&lt;/servlet-name&gt;
 *      &lt;servlet-class&gt;org.apache.tiles.servlets.TilesServlet&lt;/servlet-class&gt;
 *      &lt;init-param&gt;
 *          &lt;param-name&gt;definitions-config&lt;/param-name&gt;
 *          &lt;param-value&gt;/WEB-INF/tiles-config.xml&lt;/param-value&gt;
 *      &lt;/init-param&gt;
 *      &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
 * &lt;/servlet&gt;
 * <!-- END SNIPPET: webxml -->
 *
 * <!-- START SNIPPET: strutsxml -->
 * In struts.xml, use type="tiles" on your &lt;result&gt;.
 *
 * &lt;action name="editUser" class="userAction" method="edit"&gt;
 *      &lt;result name="success" type="tiles"&gt;userForm&lt;/result&gt;
 *      &lt;result name="input" type="tiles"&gt;userList&lt;/result&gt;
 * &lt;/action&gt;
 * <!-- END SNIPPET: strutsxml -->
 *
 *
 * <!-- START SNIPPET: packageconfig -->
 *
 * Making this result type the default for the current package.
 *
 * &lt;result-types&gt;
 *      &lt;result-type name="tiles"
 * class="org.apache.struts2.views.tiles.TilesResult" default="true" /&gt;
 * &lt;/result-types&gt;
 * <!-- END SNIPPET: packageconfig -->
 *
 */
public class TilesResult extends ServletDispatcherResult {

	private static final long serialVersionUID = -3806939435493086243L;

	private static final Log log = LogFactory.getLog(TilesResult.class);

    protected ActionInvocation invocation;
    private DefinitionsFactory definitionsFactory;

    /**
     * Dispatches to the given location. Does its forward via a RequestDispatcher. If the
     * dispatch fails a 404 error will be sent back in the http response.
     *
     * @param location the location to dispatch to.
     * @param invocation    the execution state of the action
     * @throws Exception if an error occurs. If the dispatch fails the error will go back via the
     *                   HTTP request.
     */
    public void doExecute(String location, ActionInvocation invocation) throws Exception {
        this.location = location;
        this.invocation = invocation;

        HttpServletRequest request = ServletActionContext.getRequest();
        HttpServletResponse response = ServletActionContext.getResponse();
        ServletContext servletContext = ServletActionContext.getServletContext();

        this.definitionsFactory =
                (DefinitionsFactory) servletContext.getAttribute(TilesUtilImpl.DEFINITIONS_FACTORY);

        // get component definition
        ComponentDefinition definition = getComponentDefinition(this.definitionsFactory, request);
        if (definition == null) {
            throw new ServletException("No Tiles definition found for name '" + location + "'");
        }

        // get current component context
        ComponentContext context = getComponentContext(definition, request);
        ComponentContext.setContext(context, request);

        // execute component controller associated with definition, if any
        Controller controller = getController(definition, request);
        if (controller != null) {
            if (log.isDebugEnabled()) {
                log.debug("Executing Tiles controller [" + controller + "]");
            }
            executeController(controller, context, request, response);
        }

        // determine the path of the definition
        String path = getDispatcherPath(definition, request);
        if (path == null) {
            throw new ServletException(
                    "Could not determine a path for Tiles definition '" + definition.getName() + "'");
        }

        super.doExecute(path, invocation);
    }

    protected Locale deduceLocale(HttpServletRequest request) {
        if (invocation.getAction() instanceof LocaleProvider) {
            return ((LocaleProvider) invocation.getAction()).getLocale();
        } else {
            return request.getLocale();
        }
    }

    /**
     * Determine the Tiles component definition for the given Tiles
     * definitions factory.
     *
     * @param factory the Tiles definitions factory
     * @param request current HTTP request
     * @return the component definition
     */
    protected ComponentDefinition getComponentDefinition(DefinitionsFactory factory, HttpServletRequest request)
            throws Exception {
        ComponentDefinitions definitions = factory.readDefinitions();
        return definitions.getDefinition(location, deduceLocale(request));
    }

    /**
     * Determine the Tiles component context for the given Tiles definition.
     *
     * @param definition the Tiles definition to render
     * @param request    current HTTP request
     * @return the component context
     * @throws Exception if preparations failed
     */
    protected ComponentContext getComponentContext(ComponentDefinition definition, HttpServletRequest request)
            throws Exception {
        ComponentContext context = ComponentContext.getContext(request);
        if (context == null) {
            context = new ComponentContext(definition.getAttributes());
            ComponentContext.setContext(context, request);
        } else {
            context.addMissing(definition.getAttributes());
        }
        return context;
    }

    /**
     * Determine and initialize the Tiles component controller for the
     * given Tiles definition, if any.
     *
     * @param definition the Tiles definition to render
     * @param request    current HTTP request
     * @return the component controller to execute, or <code>null</code> if none
     * @throws Exception if preparations failed
     */
    protected Controller getController(ComponentDefinition definition, HttpServletRequest request)
            throws Exception {
        return definition.getOrCreateController();
    }

    /**
     * Execute the given Tiles controller.
     *
     * @param controller the component controller to execute
     * @param context    the component context
     * @param request    current HTTP request
     * @param response   current HTTP response
     * @throws Exception if controller execution failed
     */
    protected void executeController(
            Controller controller, ComponentContext context, HttpServletRequest request, HttpServletResponse response)
            throws Exception {
        controller.execute(context, request, response, ServletActionContext.getServletContext());
    }

    /**
     * Determine the dispatcher path for the given Tiles definition,
     * i.e. the request dispatcher path of the layout page.
     * @param definition the Tiles definition to render
     * @param request current HTTP request
     * @return the path of the layout page to render
     * @throws Exception if preparations failed
     */
    protected String getDispatcherPath(ComponentDefinition definition, HttpServletRequest request)
            throws Exception {
        Object pathAttr = null;
        return (pathAttr != null ? pathAttr.toString() : definition.getPath());
	}
}
"
core/src/main/java/org/apache/struts2/views/util/ContextUtil.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.util;

import java.util.HashMap;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.StrutsConstants;
import org.apache.struts2.config.Settings;
import org.apache.struts2.util.StrutsUtil;
import org.apache.struts2.views.jsp.ui.OgnlTool;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * Value Stack's Context related Utilities.
 * 
 */
public class ContextUtil {
    public static final String REQUEST = "request";
    public static final String REQUEST2 = "request";
    public static final String RESPONSE = "response";
    public static final String RESPONSE2 = "response";
    public static final String SESSION = "session";
    public static final String BASE = "base";
    public static final String STACK = "stack";
    public static final String OGNL = "ognl";
    public static final String STRUTS = "struts";
    public static final String ACTION = "action";

    public static Map getStandardContext(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        HashMap map = new HashMap();
        map.put(REQUEST, req);
        map.put(REQUEST2, req);
        map.put(RESPONSE, res);
        map.put(RESPONSE2, res);
        map.put(SESSION, req.getSession(false));
        map.put(BASE, req.getContextPath());
        map.put(STACK, stack);
        map.put(OGNL, OgnlTool.getInstance());
        map.put(STRUTS, new StrutsUtil(stack, req, res));

        ActionInvocation invocation = (ActionInvocation) stack.getContext().get(ActionContext.ACTION_INVOCATION);
        if (invocation != null) {
            map.put(ACTION, invocation.getAction());
        }
        return map;
    }
    
    /**
     * Return true if either Configuration's altSyntax is on or the stack context's useAltSyntax is on
     * @param context stack's context
     * @return boolean
     */
    public static boolean isUseAltSyntax(Map context) {
        // We didn't make altSyntax static cause, if so, struts.configuration.xml.reload will not work
        // plus the Configuration implementation should cache the properties, which the framework's
        // configuration implementation does
        boolean altSyntax = "true".equals(Settings.get(StrutsConstants.STRUTS_TAG_ALTSYNTAX));
        return altSyntax ||(
                (context.containsKey("useAltSyntax") &&
                        context.get("useAltSyntax") != null &&
                        "true".equals(context.get("useAltSyntax").toString())));
    }

    /**
     * Returns a String for overriding the default templateSuffix if templateSuffix is on the stack
     * @param context stack's context
     * @return String
     */
    public static String getTemplateSuffix(Map context) {
        return context.containsKey("templateSuffix") ? (String) context.get("templateSuffix") : null;
    }
}
"
core/src/main/java/org/apache/struts2/views/util/ResourceUtil.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.util;

import javax.servlet.http.HttpServletRequest;

import org.apache.struts2.RequestUtils;

/**
 */
public class ResourceUtil {
    public static String getResourceBase(HttpServletRequest req) {
        String path = RequestUtils.getServletPath(req);
        if (path == null || "".equals(path)) {
            return "";
        }

        return path.substring(0, path.lastIndexOf('/'));
    }
}
"
core/src/main/java/org/apache/struts2/views/util/TextUtil.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.util;


/**
 * This class handles HTML escaping of text.
 * It was written and optimized to be as fast as possible.
 *
 */
public class TextUtil {

    protected static final int MAX_LENGTH = 300;

    /**
     * We use arrays of char in the lookup table because it is faster
     * appending this to a StringBuffer than appending a String
     */
    protected static final char[][] _stringChars = new char[MAX_LENGTH][];

    static {
        // Initialize the mapping table
        initMapping();
    }


    /**
     * Call escapeHTML(s, false)
     */
    public static final String escapeHTML(String s) {
        return escapeHTML(s, false);
    }

    /**
     * Escape HTML.
     *
     * @param s           string to be escaped
     * @param escapeEmpty if true, then empty string will be escaped.
     */
    public static final String escapeHTML(String s, boolean escapeEmpty) {
        int len = s.length();

        if (len == 0) {
            return s;
        }

        if (!escapeEmpty) {
            String trimmed = s.trim();

            if ((trimmed.length() == 0) || ("\"\"").equals(trimmed)) {
                return s;
            }
        }

        int i = 0;

        // First loop through String and check if escaping is needed at all
        // No buffers are copied at this time
        do {
            int index = s.charAt(i);

            if (index >= MAX_LENGTH) {
                if (index != 0x20AC) { // If not euro symbol

                    continue;
                }

                break;
            } else if (_stringChars[index] != null) {
                break;
            }
        } while (++i < len);

        // If the check went to the end with no escaping then i should be == len now
        // otherwise we must continue escaping for real
        if (i == len) {
            return s;
        }

        // We found a character to escape and broke out at position i
        // Now copy all characters before that to StringBuffer sb
        // Since a char[] will be used for copying we might as well get
        // a complete copy of it so that we can use array indexing instead of charAt
        StringBuffer sb = new StringBuffer(len + 40);
        char[] chars = new char[len];

        // Copy all chars from the String s to the chars buffer
        s.getChars(0, len, chars, 0);

        // Append the first i characters that we have checked to the resulting StringBuffer
        sb.append(chars, 0, i);

        int last = i;
        char[] subst;

        for (; i < len; i++) {
            char c = chars[i];
            int index = c;

            if (index < MAX_LENGTH) {
                subst = _stringChars[index];

                // It is faster to append a char[] than a String which is why we use this
                if (subst != null) {
                    if (i > last) {
                        sb.append(chars, last, i - last);
                    }

                    sb.append(subst);
                    last = i + 1;
                }
            }
            // Check if it is the euro symbol. This could be changed to check in a second lookup
            // table in case one wants to convert more characters in that area
            else if (index == 0x20AC) {
                if (i > last) {
                    sb.append(chars, last, i - last);
                }

                sb.append("&euro;");
                last = i + 1;
            }
        }

        if (i > last) {
            sb.append(chars, last, i - last);
        }

        return sb.toString();
    }

    protected static void addMapping(int c, String txt, String[] strings) {
        strings[c] = txt;
    }

    protected static void initMapping() {
        String[] strings = new String[MAX_LENGTH];

        addMapping(0x22, "&quot;", strings); // "
        addMapping(0x26, "&amp;", strings); // &
        addMapping(0x3c, "&lt;", strings); // <
        addMapping(0x3e, "&gt;", strings); // >

        addMapping(0xa1, "&iexcl;", strings); //
        addMapping(0xa2, "&cent;", strings); //
        addMapping(0xa3, "&pound;", strings); //
        addMapping(0xa9, "&copy;", strings); // �
        addMapping(0xae, "&reg;", strings); // �
        addMapping(0xbf, "&iquest;", strings); //

        addMapping(0xc0, "&Agrave;", strings); // �
        addMapping(0xc1, "&Aacute;", strings); // �
        addMapping(0xc2, "&Acirc;", strings); // �
        addMapping(0xc3, "&Atilde;", strings); // �
        addMapping(0xc4, "&Auml;", strings); // �
        addMapping(0xc5, "&Aring;", strings); // �
        addMapping(0xc6, "&AElig;", strings); // �
        addMapping(0xc7, "&Ccedil;", strings); // �
        addMapping(0xc8, "&Egrave;", strings); //
        addMapping(0xc9, "&Eacute;", strings); //
        addMapping(0xca, "&Ecirc;", strings); //
        addMapping(0xcb, "&Euml;", strings); //
        addMapping(0xcc, "&Igrave;", strings); //
        addMapping(0xcd, "&Iacute;", strings); //
        addMapping(0xce, "&Icirc;", strings); //
        addMapping(0xcf, "&Iuml;", strings); //

        addMapping(0xd0, "&ETH;", strings); //
        addMapping(0xd1, "&Ntilde;", strings); //
        addMapping(0xd2, "&Ograve;", strings); //
        addMapping(0xd3, "&Oacute;", strings); //
        addMapping(0xd4, "&Ocirc;", strings); //
        addMapping(0xd5, "&Otilde;", strings); //
        addMapping(0xd6, "&Ouml;", strings); // �
        addMapping(0xd7, "&times;", strings); //
        addMapping(0xd8, "&Oslash;", strings); //
        addMapping(0xd9, "&Ugrave;", strings); //
        addMapping(0xda, "&Uacute;", strings); //
        addMapping(0xdb, "&Ucirc;", strings); //
        addMapping(0xdc, "&Uuml;", strings); //
        addMapping(0xdd, "&Yacute;", strings); //
        addMapping(0xde, "&THORN;", strings); //
        addMapping(0xdf, "&szlig;", strings); //

        addMapping(0xe0, "&agrave;", strings); //
        addMapping(0xe1, "&aacute;", strings); //
        addMapping(0xe2, "&acirc;", strings); //
        addMapping(0xe3, "&atilde;", strings); //
        addMapping(0xe4, "&auml;", strings); // �
        addMapping(0xe5, "&aring;", strings); // �
        addMapping(0xe6, "&aelig;", strings); //
        addMapping(0xe7, "&ccedil;", strings); //
        addMapping(0xe8, "&egrave;", strings); //
        addMapping(0xe9, "&eacute;", strings); //
        addMapping(0xea, "&ecirc;", strings); //
        addMapping(0xeb, "&euml;", strings); //
        addMapping(0xec, "&igrave;", strings); //
        addMapping(0xed, "&iacute;", strings); //
        addMapping(0xee, "&icirc;", strings); //
        addMapping(0xef, "&iuml;", strings); //

        addMapping(0xf0, "&eth;", strings); //
        addMapping(0xf1, "&ntilde;", strings); //
        addMapping(0xf2, "&ograve;", strings); //
        addMapping(0xf3, "&oacute;", strings); //
        addMapping(0xf4, "&ocirc;", strings); //
        addMapping(0xf5, "&otilde;", strings); //
        addMapping(0xf6, "&ouml;", strings); // �
        addMapping(0xf7, "&divide;", strings); //
        addMapping(0xf8, "&oslash;", strings); //
        addMapping(0xf9, "&ugrave;", strings); //
        addMapping(0xfa, "&uacute;", strings); //
        addMapping(0xfb, "&ucirc;", strings); //
        addMapping(0xfc, "&uuml;", strings); //
        addMapping(0xfd, "&yacute;", strings); //
        addMapping(0xfe, "&thorn;", strings); //
        addMapping(0xff, "&yuml;", strings); //

        for (int i = 0; i < strings.length; i++) {
            String str = strings[i];

            if (str != null) {
                _stringChars[i] = str.toCharArray();
            }
        }
    }
}
"
core/src/main/java/org/apache/struts2/views/util/UrlHelper.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.util;

import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.ServletActionContext;
import org.apache.struts2.StrutsConstants;
import org.apache.struts2.config.Settings;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.util.OgnlValueStack;
import com.opensymphony.xwork2.util.TextParseUtil;
import com.opensymphony.xwork2.util.XWorkContinuationConfig;


/**
 * UrlHelper
 *
 */
public class UrlHelper {
    private static final Log LOG = LogFactory.getLog(UrlHelper.class);

    /**
     * Default HTTP port (80).
     */
    private static final int DEFAULT_HTTP_PORT = 80;

    /**
     * Default HTTPS port (443).
     */
    private static final int DEFAULT_HTTPS_PORT = 443;

    private static final String AMP = "&amp;";

    public static String buildUrl(String action, HttpServletRequest request, HttpServletResponse response, Map params) {
        return buildUrl(action, request, response, params, null, true, true);
    }
    
    public static String buildUrl(String action, HttpServletRequest request, HttpServletResponse response, Map params, String scheme, boolean includeContext, boolean encodeResult) {
    	return buildUrl(action, request, response, params, scheme, includeContext, encodeResult, false);
    }

    public static String buildUrl(String action, HttpServletRequest request, HttpServletResponse response, Map params, String scheme, boolean includeContext, boolean encodeResult, boolean forceAddSchemeHostAndPort) {
        StringBuffer link = new StringBuffer();

        boolean changedScheme = false;

        int httpPort = DEFAULT_HTTP_PORT;

        try {
            httpPort = Integer.parseInt((String) Settings.get(StrutsConstants.STRUTS_URL_HTTP_PORT));
        } catch (Exception ex) {
        }

        int httpsPort = DEFAULT_HTTPS_PORT;

        try {
            httpsPort = Integer.parseInt((String) Settings.get(StrutsConstants.STRUTS_URL_HTTPS_PORT));
        } catch (Exception ex) {
        }

        // only append scheme if it is different to the current scheme *OR*
        // if we explicity want it to be appended by having forceAddSchemeHostAndPort = true
        if (forceAddSchemeHostAndPort) {
        	String reqScheme = request.getScheme();
        	changedScheme = true;
        	link.append(scheme != null ? scheme : reqScheme);
        	link.append("://");
        	link.append(request.getServerName());
        	
        	if ((scheme.equals("http") && (httpPort != DEFAULT_HTTP_PORT)) || (scheme.equals("https") && httpsPort != DEFAULT_HTTPS_PORT))
            {
                link.append(":");
                link.append(scheme.equals("http") ? httpPort : httpsPort);
            }
        }
        else if (  
           (scheme != null) && !scheme.equals(request.getScheme())) {
            changedScheme = true;
            link.append(scheme);
            link.append("://");
            link.append(request.getServerName());

            if ((scheme.equals("http") && (httpPort != DEFAULT_HTTP_PORT)) || (scheme.equals("https") && httpsPort != DEFAULT_HTTPS_PORT))
            {
                link.append(":");
                link.append(scheme.equals("http") ? httpPort : httpsPort);
            }
        }

        if (action != null) {
            // Check if context path needs to be added
            // Add path to absolute links
            if (action.startsWith("/") && includeContext) {
                String contextPath = request.getContextPath();
                if (!contextPath.equals("/")) {
                    link.append(contextPath);
                }
            } else if (changedScheme) {
                String uri = request.getRequestURI();
                link.append(uri.substring(0, uri.lastIndexOf('/')));
            }

            // Add page
            link.append(action);
        } else {
            // Go to "same page"
            String requestURI = (String) request.getAttribute("struts.request_uri");

            if (requestURI == null) {
                requestURI = request.getRequestURI();
            }

            link.append(requestURI);
        }

        // tie in the continuation parameter
        String continueId = (String) ActionContext.getContext().get(XWorkContinuationConfig.CONTINUE_KEY);
        if (continueId != null) {
            if (params == null) {
                params = Collections.singletonMap(XWorkContinuationConfig.CONTINUE_PARAM, continueId);
            } else {
                params.put(XWorkContinuationConfig.CONTINUE_PARAM, continueId);
            }
        }

        //if the action was not explicitly set grab the params from the request
        buildParametersString(params, link);

        String result;

        try {
            result = encodeResult ? response.encodeURL(link.toString()) : link.toString();
        } catch (Exception ex) {
            // Could not encode the URL for some reason
            // Use it unchanged
            result = link.toString();
        }

        return result;
    }

    public static void buildParametersString(Map params, StringBuffer link) {
    	buildParametersString(params, link, AMP);
    }
    
    public static void buildParametersString(Map params, StringBuffer link, String paramSeparator) {
        if ((params != null) && (params.size() > 0)) {
            if (link.toString().indexOf("?") == -1) {
                link.append("?");
            } else {
                link.append(paramSeparator);
            }

            // Set params
            Iterator iter = params.entrySet().iterator();

            String[] valueHolder = new String[1];

            while (iter.hasNext()) {
                Map.Entry entry = (Map.Entry) iter.next();
                String name = (String) entry.getKey();
                Object value = entry.getValue();

                String[] values;

                if (value instanceof String[]) {
                    values = (String[]) value;
                } else {
                    valueHolder[0] = value.toString();
                    values = valueHolder;
                }

                for (int i = 0; i < values.length; i++) {
                    if (values[i] != null) {
                        link.append(name);
                        link.append('=');
                        link.append(translateAndEncode(values[i]));
                    }

                    if (i < (values.length - 1)) {
                        link.append(paramSeparator);
                    }
                }

                if (iter.hasNext()) {
                    link.append(paramSeparator);
                }
            }
        }
    }

    /**
     * Translates any script expressions using {@link com.opensymphony.xwork2.util.TextParseUtil#translateVariables} and
     * encodes the URL using {@link java.net.URLEncoder#encode} with the encoding specified in the configuration.
     *
     * @param input
     * @return the translated and encoded string
     */
    public static String translateAndEncode(String input) {
        String translatedInput = translateVariable(input);
        String encoding = getEncodingFromConfiguration();

        try {
            return URLEncoder.encode(translatedInput, encoding);
        } catch (UnsupportedEncodingException e) {
            LOG.warn("Could not encode URL parameter '" + input + "', returning value un-encoded");
            return translatedInput;
        }
    }
    
    public static String translateAndDecode(String input) {
    	String translatedInput = translateVariable(input);
    	String encoding = getEncodingFromConfiguration();

        try {
            return URLDecoder.decode(translatedInput, encoding);
        } catch (UnsupportedEncodingException e) {
            LOG.warn("Could not encode URL parameter '" + input + "', returning value un-encoded");
            return translatedInput;
        }
    }
    
    private static String translateVariable(String input) {
    	OgnlValueStack valueStack = ServletActionContext.getContext().getValueStack();
        String output = TextParseUtil.translateVariables(input, valueStack);
        return output;
    }
    
    private static String getEncodingFromConfiguration() {
    	final String encoding;
        if (Settings.isSet(StrutsConstants.STRUTS_I18N_ENCODING)) {
            encoding = Settings.get(StrutsConstants.STRUTS_I18N_ENCODING);
        } else {
            encoding = "UTF-8";
        }
        return encoding;
    }
    
    public static Map parseQueryString(String queryString) {
    	Map queryParams = new LinkedHashMap();
    	if (queryString != null) {
    		String[] params = queryString.split("&");
    		for (int a=0; a< params.length; a++) {
    			if (params[a].trim().length() > 0) {
    				String[] tmpParams = params[a].split("=");
    				String paramName = null;
    				String paramValue = "";
    				if (tmpParams.length > 0) {
    					paramName = tmpParams[0];
    				}
    				if (tmpParams.length > 1) {
    					paramValue = tmpParams[1];
    				}
    				if (paramName != null) {
    					String translatedParamValue = translateAndDecode(paramValue);
    					queryParams.put(paramName, translatedParamValue);
    				}
    			}
    		}
    	}
    	return queryParams;
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/StrutsResourceLoader.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity;

import java.io.InputStream;

import org.apache.struts2.util.ClassLoaderUtils;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader;


/**
 * Loads resource from the Thread's context ClassLoader.
 *
 */
public class StrutsResourceLoader extends ClasspathResourceLoader {

    public synchronized InputStream getResourceStream(String name) throws ResourceNotFoundException {
        if ((name == null) || (name.length() == 0)) {
            throw new ResourceNotFoundException("No template name provided");
        }

        if (name.startsWith("/")) {
            name = name.substring(1);
        }

        try {
            return ClassLoaderUtils.getResourceAsStream(name, StrutsResourceLoader.class);
        } catch (Exception e) {
            throw new ResourceNotFoundException(e.getMessage());
        }
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/StrutsVelocityContext.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity;

import org.apache.velocity.VelocityContext;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 */
public class StrutsVelocityContext extends VelocityContext {

    private static final long serialVersionUID = 8497212428904436963L;
    OgnlValueStack stack;
    VelocityContext[] chainedContexts;


    public StrutsVelocityContext(OgnlValueStack stack) {
        this(null, stack);
    }

    public StrutsVelocityContext(VelocityContext[] chainedContexts, OgnlValueStack stack) {
        this.chainedContexts = chainedContexts;
        this.stack = stack;
    }


    public boolean internalContainsKey(Object key) {
        boolean contains = super.internalContainsKey(key);

        // first let's check to see if we contain the requested key
        if (contains) {
            return true;
        }

        // if not, let's search for the key in the ognl value stack
        if (stack != null) {
            Object o = stack.findValue(key.toString());

            if (o != null) {
                return true;
            }

            o = stack.getContext().get(key.toString());
            if (o != null) {
                return true;
            }
        }

        // if we still haven't found it, le's search through our chained contexts
        if (chainedContexts != null) {
            for (int index = 0; index < chainedContexts.length; index++) {
                if (chainedContexts[index].containsKey(key)) {
                    return true;
                }
            }
        }

        // nope, i guess it's really not here
        return false;
    }

    public Object internalGet(String key) {
        // first, let's check to see if have the requested value
        if (super.internalContainsKey(key)) {
            return super.internalGet(key);
        }

        // still no luck?  let's look against the value stack
        if (stack != null) {
            Object object = stack.findValue(key);

            if (object != null) {
                return object;
            }

            object = stack.getContext().get(key);
            if (object != null) {
                return object;
            }

        }

        // finally, if we're chained to other contexts, let's look in them
        if (chainedContexts != null) {
            for (int index = 0; index < chainedContexts.length; index++) {
                if (chainedContexts[index].containsKey(key)) {
                    return chainedContexts[index].internalGet(key);
                }
            }
        }

        // nope, i guess it's really not here
        return null;
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/StrutsVelocityServlet.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.util.Properties;

import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.jsp.JspFactory;
import javax.servlet.jsp.PageContext;

import org.apache.struts2.RequestUtils;
import org.apache.struts2.ServletActionContext;
import org.apache.struts2.StrutsConstants;
import org.apache.struts2.config.Settings;
import org.apache.struts2.views.util.ContextUtil;
import org.apache.velocity.Template;
import org.apache.velocity.context.Context;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.runtime.RuntimeSingleton;
import org.apache.velocity.servlet.VelocityServlet;

import com.opensymphony.xwork2.ActionContext;


/**
 * @deprecated please use {@link org.apache.struts2.dispatcher.VelocityResult} instead of direct access
 */
public class StrutsVelocityServlet extends VelocityServlet {
    private static final long serialVersionUID = -2078492831396251182L;
    private VelocityManager velocityManager;

    public StrutsVelocityServlet() {
        velocityManager = VelocityManager.getInstance();
    }

    public void init(ServletConfig servletConfig) throws ServletException {
        super.init(servletConfig);

        // initialize our VelocityManager
        velocityManager.init(servletConfig.getServletContext());
    }

    protected Context createContext(HttpServletRequest request, HttpServletResponse response) {
        return velocityManager.createContext(ActionContext.getContext().getValueStack(), request, response);
    }

    protected Template handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Context context) throws Exception {
        String servletPath = (String) httpServletRequest.getAttribute("javax.servlet.include.servlet_path");

        if (servletPath == null) {
            servletPath = RequestUtils.getServletPath(httpServletRequest);
        }

        return getTemplate(servletPath, getEncoding());
    }

    /**
     * This method extends the VelocityServlet's loadConfiguration method by performing the following actions:
     * <ul>
     * <li>invokes VelocityServlet.loadConfiguration to create a properties object</li>
     * <li>alters the RESOURCE_LOADER to include a class loader</li>
     * <li>configures the class loader using the StrutsResourceLoader</li>
     * </ul>
     *
     * @param servletConfig
     * @throws IOException
     * @throws FileNotFoundException
     * @see org.apache.velocity.servlet.VelocityServlet#loadConfiguration
     */
    protected Properties loadConfiguration(ServletConfig servletConfig) throws IOException, FileNotFoundException {
        return velocityManager.loadConfiguration(servletConfig.getServletContext());
    }

    /**
     * create a PageContext and render the template to PageContext.getOut()
     *
     * @see VelocityServlet#mergeTemplate(Template, Context, HttpServletResponse) for additional documentation
     */
    protected void mergeTemplate(Template template, Context context, HttpServletResponse response) throws ResourceNotFoundException, ParseErrorException, MethodInvocationException, IOException, UnsupportedEncodingException, Exception {
        // save the old PageContext
        PageContext oldPageContext = ServletActionContext.getPageContext();

        // create a new PageContext
        JspFactory jspFactory = JspFactory.getDefaultFactory();
        HttpServletRequest request = (HttpServletRequest) context.get(ContextUtil.REQUEST);
        PageContext pageContext = jspFactory.getPageContext(this, request, response, null, true, 8192, true);

        // put the new PageContext into ActionContext
        ActionContext actionContext = ActionContext.getContext();
        actionContext.put(ServletActionContext.PAGE_CONTEXT, pageContext);

        try {
            Writer writer = pageContext.getOut();
            template.merge(context, writer);
            writer.flush();
        } finally {
            // perform cleanup
            jspFactory.releasePageContext(pageContext);
            actionContext.put(ServletActionContext.PAGE_CONTEXT, oldPageContext);
        }
    }

    private String getEncoding() {
        // todo look into converting this to using XWork/Struts encoding rules
        try {
            return Settings.get(StrutsConstants.STRUTS_I18N_ENCODING);
        } catch (IllegalArgumentException e) {
            return RuntimeSingleton.getString(RuntimeSingleton.OUTPUT_ENCODING, DEFAULT_OUTPUT_ENCODING);
        }
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/VelocityManager.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.StringTokenizer;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.ServletActionContext;
import org.apache.struts2.StrutsConstants;
import org.apache.struts2.StrutsException;
import org.apache.struts2.config.Settings;
import org.apache.struts2.util.VelocityStrutsUtil;
import org.apache.struts2.views.jsp.ui.OgnlTool;
import org.apache.struts2.views.util.ContextUtil;
import org.apache.struts2.views.velocity.components.ActionDirective;
import org.apache.struts2.views.velocity.components.ActionErrorDirective;
import org.apache.struts2.views.velocity.components.ActionMessageDirective;
import org.apache.struts2.views.velocity.components.AnchorDirective;
import org.apache.struts2.views.velocity.components.BeanDirective;
import org.apache.struts2.views.velocity.components.CheckBoxDirective;
import org.apache.struts2.views.velocity.components.CheckBoxListDirective;
import org.apache.struts2.views.velocity.components.ComboBoxDirective;
import org.apache.struts2.views.velocity.components.ComponentDirective;
import org.apache.struts2.views.velocity.components.DateDirective;
import org.apache.struts2.views.velocity.components.DatePickerDirective;
import org.apache.struts2.views.velocity.components.DivDirective;
import org.apache.struts2.views.velocity.components.DoubleSelectDirective;
import org.apache.struts2.views.velocity.components.FieldErrorDirective;
import org.apache.struts2.views.velocity.components.FileDirective;
import org.apache.struts2.views.velocity.components.FormDirective;
import org.apache.struts2.views.velocity.components.HeadDirective;
import org.apache.struts2.views.velocity.components.HiddenDirective;
import org.apache.struts2.views.velocity.components.I18nDirective;
import org.apache.struts2.views.velocity.components.IncludeDirective;
import org.apache.struts2.views.velocity.components.LabelDirective;
import org.apache.struts2.views.velocity.components.OptionTransferSelectDirective;
import org.apache.struts2.views.velocity.components.PanelDirective;
import org.apache.struts2.views.velocity.components.ParamDirective;
import org.apache.struts2.views.velocity.components.PasswordDirective;
import org.apache.struts2.views.velocity.components.PropertyDirective;
import org.apache.struts2.views.velocity.components.PushDirective;
import org.apache.struts2.views.velocity.components.RadioDirective;
import org.apache.struts2.views.velocity.components.ResetDirective;
import org.apache.struts2.views.velocity.components.SelectDirective;
import org.apache.struts2.views.velocity.components.SetDirective;
import org.apache.struts2.views.velocity.components.SubmitDirective;
import org.apache.struts2.views.velocity.components.TabbedPanelDirective;
import org.apache.struts2.views.velocity.components.TextAreaDirective;
import org.apache.struts2.views.velocity.components.TextDirective;
import org.apache.struts2.views.velocity.components.TextFieldDirective;
import org.apache.struts2.views.velocity.components.TokenDirective;
import org.apache.struts2.views.velocity.components.TreeDirective;
import org.apache.struts2.views.velocity.components.TreeNodeDirective;
import org.apache.struts2.views.velocity.components.URLDirective;
import org.apache.struts2.views.velocity.components.UpDownSelectDirective;
import org.apache.struts2.views.velocity.components.WebTableDirective;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.Velocity;
import org.apache.velocity.app.VelocityEngine;
import org.apache.velocity.context.Context;
import org.apache.velocity.tools.view.ToolboxManager;
import org.apache.velocity.tools.view.context.ChainedContext;
import org.apache.velocity.tools.view.servlet.ServletToolboxManager;

import com.opensymphony.xwork2.ObjectFactory;
import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * Manages the environment for Velocity result types
 *
 */
public class VelocityManager {
    private static final Log log = LogFactory.getLog(VelocityManager.class);
    private static VelocityManager instance;
    public static final String STRUTS = "struts";

    /**
     * the parent JSP tag
     */
    public static final String PARENT = "parent";

    /**
     * the current JSP tag
     */
    public static final String TAG = "tag";

    private VelocityEngine velocityEngine;

    /**
     * A reference to the toolbox manager.
     */
    protected ToolboxManager toolboxManager = null;
    private String toolBoxLocation;


    /**
     * Names of contexts that will be chained on every request
     */
    private String[] chainedContextNames;
    
    private Properties velocityProperties;

    protected VelocityManager() {
        init();
    }

    /**
     * retrieve an instance to the current VelocityManager
     */
    public synchronized static VelocityManager getInstance() {
        if (instance == null) {
            String classname = VelocityManager.class.getName();

            if (Settings.isSet(StrutsConstants.STRUTS_VELOCITY_MANAGER_CLASSNAME)) {
                classname = Settings.get(StrutsConstants.STRUTS_VELOCITY_MANAGER_CLASSNAME).trim();
            }

            if (!classname.equals(VelocityManager.class.getName())) {
                try {
                    log.info("Instantiating VelocityManager!, " + classname);
                    // singleton instances shouldn't be built accessing request or session-specific context data
                    instance = (VelocityManager) ObjectFactory.getObjectFactory().buildBean(classname, null);
                } catch (Exception e) {
                    log.fatal("Fatal exception occurred while trying to instantiate a VelocityManager instance, " + classname, e);
                    instance = new VelocityManager();
                }
            } else {
                instance = new VelocityManager();
            }
        }

        return instance;
    }

    /**
     * @return a reference to the VelocityEngine used by <b>all</b> struts velocity thingies with the exception of
     *         directly accessed *.vm pages
     */
    public VelocityEngine getVelocityEngine() {
        return velocityEngine;
    }

    /**
     * This method is responsible for creating the standard VelocityContext used by all WW2 velocity views.  The
     * following context parameters are defined:
     * <p/>
     * <ul>
     * <li><strong>request</strong> - the current HttpServletRequest</li>
     * <li><strong>response</strong> - the current HttpServletResponse</li>
     * <li><strong>stack</strong> - the current {@link OgnlValueStack}</li>
     * <li><strong>ognl</strong> - an {@link OgnlTool}</li>
     * <li><strong>struts</strong> - an instance of {@link org.apache.struts2.util.StrutsUtil}</li>
     * <li><strong>action</strong> - the current Struts action</li>
     * </ul>
     *
     * @return a new StrutsVelocityContext
     */
    public Context createContext(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        VelocityContext[] chainedContexts = prepareChainedContexts(req, res, stack.getContext());
        StrutsVelocityContext context = new StrutsVelocityContext(chainedContexts, stack);
        Map standardMap = ContextUtil.getStandardContext(stack, req, res);
        for (Iterator iterator = standardMap.entrySet().iterator(); iterator.hasNext();) {
            Map.Entry entry = (Map.Entry) iterator.next();
            context.put((String) entry.getKey(), entry.getValue());
        }
        context.put(STRUTS, new VelocityStrutsUtil(context, stack, req, res));


        ServletContext ctx = null;
        try {
            ctx = ServletActionContext.getServletContext();
        } catch (NullPointerException npe) {
            // in case this was used outside the lifecycle of struts servlet
            log.debug("internal toolbox context ignored");
        }

        if (toolboxManager != null && ctx != null) {
            ChainedContext chained = new ChainedContext(context, req, res, ctx);
            chained.setToolbox(toolboxManager.getToolboxContext(chained));
            return chained;
        } else {
            return context;
        }

    }

    /**
     * constructs contexts for chaining on this request.  This method does not
     * perform any initialization of the contexts.  All that must be done in the
     * context itself.
     *
     * @param servletRequest
     * @param servletResponse
     * @param extraContext
     * @return an VelocityContext[] of contexts to chain
     */
    protected VelocityContext[] prepareChainedContexts(HttpServletRequest servletRequest, HttpServletResponse servletResponse, Map extraContext) {
        if (this.chainedContextNames == null) {
            return null;
        }
        List contextList = new ArrayList();
        for (int i = 0; i < chainedContextNames.length; i++) {
            String className = chainedContextNames[i];
            try {
                VelocityContext velocityContext = (VelocityContext) ObjectFactory.getObjectFactory().buildBean(className, null);
                contextList.add(velocityContext);
            } catch (Exception e) {
                log.warn("Warning.  " + e.getClass().getName() + " caught while attempting to instantiate a chained VelocityContext, " + className + " -- skipping");
            }
        }
        if (contextList.size() > 0) {
            VelocityContext[] extraContexts = new VelocityContext[contextList.size()];
            contextList.toArray(extraContexts);
            return extraContexts;
        } else {
            return null;
        }
    }

    /**
     * initializes the VelocityManager.  this should be called during the initialization process, say by
     * ServletDispatcher.  this may be called multiple times safely although calls beyond the first won't do anything
     *
     * @param context the current servlet context
     */
    public synchronized void init(ServletContext context) {
        if (velocityEngine == null) {
            velocityEngine = newVelocityEngine(context);
        }
        this.initToolbox(context);
    }

    /**
     * load optional velocity properties using the following loading strategy
     * <ul>
     * <li>relative to the servlet context path</li>
     * <li>relative to the WEB-INF directory</li>
     * <li>on the classpath</li>
     * </ul>
     *
     * @param context the current ServletContext.  may <b>not</b> be null
     * @return the optional properties if struts.velocity.configfile was specified, an empty Properties file otherwise
     */
    public Properties loadConfiguration(ServletContext context) {
        if (context == null) {
            String gripe = "Error attempting to create a loadConfiguration from a null ServletContext!";
            log.error(gripe);
            throw new IllegalArgumentException(gripe);
        }

        Properties properties = new Properties();

        // now apply our systemic defaults, then allow user to override
        applyDefaultConfiguration(context, properties);
        

        String defaultUserDirective = properties.getProperty("userdirective");

        /**
         * if the user has specified an external velocity configuration file, we'll want to search for it in the
         * following order
         *
         * 1. relative to the context path
         * 2. relative to /WEB-INF
         * 3. in the class path
         */
        String configfile;

        if (Settings.isSet(StrutsConstants.STRUTS_VELOCITY_CONFIGFILE)) {
            configfile = Settings.get(StrutsConstants.STRUTS_VELOCITY_CONFIGFILE);
        } else {
            configfile = "velocity.properties";
        }

        configfile = configfile.trim();

        InputStream in = null;
        String resourceLocation = null;

        try {
            if (context.getRealPath(configfile) != null) {
                // 1. relative to context path, i.e. /velocity.properties
                String filename = context.getRealPath(configfile);

                if (filename != null) {
                    File file = new File(filename);

                    if (file.isFile()) {
                        resourceLocation = file.getCanonicalPath() + " from file system";
                        in = new FileInputStream(file);
                    }

                    // 2. if nothing was found relative to the context path, search relative to the WEB-INF directory
                    if (in == null) {
                        file = new File(context.getRealPath("/WEB-INF/" + configfile));

                        if (file.isFile()) {
                            resourceLocation = file.getCanonicalPath() + " from file system";
                            in = new FileInputStream(file);
                        }
                    }
                }
            }

            // 3. finally, if there's no physical file, how about something in our classpath
            if (in == null) {
                in = VelocityManager.class.getClassLoader().getResourceAsStream(configfile);
                if (in != null) {
                    resourceLocation = configfile + " from classloader";
                }
            }

            // if we've got something, load 'er up
            if (in != null) {
                log.info("Initializing velocity using " + resourceLocation);
                properties.load(in);
            }
        } catch (IOException e) {
            log.warn("Unable to load velocity configuration " + resourceLocation, e);
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                }
            }
        }
        
        // overide with programmatically set properties
        if (this.velocityProperties != null) {
        	Iterator keys = this.velocityProperties.keySet().iterator();
        	while (keys.hasNext()) {
        		String key = (String) keys.next();
        		properties.setProperty(key, this.velocityProperties.getProperty(key));
			}
        }

        String userdirective = properties.getProperty("userdirective");

        if ((userdirective == null) || userdirective.trim().equals("")) {
            userdirective = defaultUserDirective;
        } else {
            userdirective = userdirective.trim() + "," + defaultUserDirective;
        }

        properties.setProperty("userdirective", userdirective);

        
        // for debugging purposes, allows users to dump out the properties that have been configured
        if (log.isDebugEnabled()) {
            log.debug("Initializing Velocity with the following properties ...");

            for (Iterator iter = properties.keySet().iterator();
                 iter.hasNext();) {
                String key = (String) iter.next();
                String value = properties.getProperty(key);

                if (log.isDebugEnabled()) {
                    log.debug("    '" + key + "' = '" + value + "'");
                }
            }
        }

        return properties;
    }

    /**
     * performs one-time initializations
     */
    protected void init() {

        // read in the names of contexts to add to each request
        initChainedContexts();


        if (Settings.isSet(StrutsConstants.STRUTS_VELOCITY_TOOLBOXLOCATION)) {
            toolBoxLocation = Settings.get(StrutsConstants.STRUTS_VELOCITY_TOOLBOXLOCATION).toString();
        }

    }


    /**
     * Initializes the ServletToolboxManager for this servlet's
     * toolbox (if any).
     */
    protected void initToolbox(ServletContext context) {
        /* if we have a toolbox, get a manager for it */
        if (toolBoxLocation != null) {
            toolboxManager = ServletToolboxManager.getInstance(context, toolBoxLocation);
        } else {
            Velocity.info("VelocityViewServlet: No toolbox entry in configuration.");
        }
    }


    /**
     * allow users to specify via the struts.properties file a set of additional VelocityContexts to chain to the
     * the StrutsVelocityContext.  The intent is to allow these contexts to store helper objects that the ui
     * developer may want access to.  Examples of reasonable VelocityContexts would be an IoCVelocityContext, a
     * SpringReferenceVelocityContext, and a ToolboxVelocityContext
     */
    protected void initChainedContexts() {

        if (Settings.isSet(StrutsConstants.STRUTS_VELOCITY_CONTEXTS)) {
            // we expect contexts to be a comma separated list of classnames
            String contexts = Settings.get(StrutsConstants.STRUTS_VELOCITY_CONTEXTS).toString();
            StringTokenizer st = new StringTokenizer(contexts, ",");
            List contextList = new ArrayList();

            while (st.hasMoreTokens()) {
                String classname = st.nextToken();
                contextList.add(classname);
            }
            if (contextList.size() > 0) {
                String[] chainedContexts = new String[contextList.size()];
                contextList.toArray(chainedContexts);
                this.chainedContextNames = chainedContexts;
            }


        }

    }

    /**
     * <p/>
     * Instantiates a new VelocityEngine.
     * </p>
     * <p/>
     * The following is the default Velocity configuration
     * </p>
     * <pre>
     *  resource.loader = file, class
     *  file.resource.loader.path = real path of webapp
     *  class.resource.loader.description = Velocity Classpath Resource Loader
     *  class.resource.loader.class = org.apache.struts2.views.velocity.StrutsResourceLoader
     * </pre>
     * <p/>
     * this default configuration can be overridden by specifying a struts.velocity.configfile property in the
     * struts.properties file.  the specified config file will be searched for in the following order:
     * </p>
     * <ul>
     * <li>relative to the servlet context path</li>
     * <li>relative to the WEB-INF directory</li>
     * <li>on the classpath</li>
     * </ul>
     *
     * @param context the current ServletContext.  may <b>not</b> be null
     */
    protected VelocityEngine newVelocityEngine(ServletContext context) {
        if (context == null) {
            String gripe = "Error attempting to create a new VelocityEngine from a null ServletContext!";
            log.error(gripe);
            throw new IllegalArgumentException(gripe);
        }

        Properties p = loadConfiguration(context);

        VelocityEngine velocityEngine = new VelocityEngine();
        
        //	Set the velocity attribute for the servlet context
        //  if this is not set the webapp loader WILL NOT WORK
        velocityEngine.setApplicationAttribute(ServletContext.class.getName(),
                context);

        try {
            velocityEngine.init(p);
        } catch (Exception e) {
            String gripe = "Unable to instantiate VelocityEngine!";
            throw new StrutsException(gripe, e);
        }

        return velocityEngine;
    }

    /**
     * once we've loaded up the user defined configurations, we will want to apply Struts specification configurations.
     * <ul>
     * <li>if Velocity.RESOURCE_LOADER has not been defined, then we will use the defaults which is a joined file,
     * class loader for unpackaed wars and a straight class loader otherwise</li>
     * <li>we need to define the various Struts custom user directives such as #param, #tag, and #bodytag</li>
     * </ul>
     *
     * @param context
     * @param p
     */
    private void applyDefaultConfiguration(ServletContext context, Properties p) {
        // ensure that caching isn't overly aggressive

        /**
         * Load a default resource loader definition if there isn't one present.
         * Ben Hall (22/08/2003)
         */
        if (p.getProperty(Velocity.RESOURCE_LOADER) == null) {
            p.setProperty(Velocity.RESOURCE_LOADER, "strutsfile, strutsclass");
        }

        /**
         * If there's a "real" path add it for the strutsfile resource loader.
         * If there's no real path and they haven't configured a loader then we change
         * resource loader property to just use the strutsclass loader
         * Ben Hall (22/08/2003)
         */
        if (context.getRealPath("") != null) {
            p.setProperty("strutsfile.resource.loader.description", "Velocity File Resource Loader");
            p.setProperty("strutsfile.resource.loader.class", "org.apache.velocity.runtime.resource.loader.FileResourceLoader");
            p.setProperty("strutsfile.resource.loader.path", context.getRealPath(""));
            p.setProperty("strutsfile.resource.loader.modificationCheckInterval", "2");
            p.setProperty("strutsfile.resource.loader.cache", "true");
        } else {
            // remove strutsfile from resource loader property
            String prop = p.getProperty(Velocity.RESOURCE_LOADER);
            if (prop.indexOf("strutsfile,") != -1) {
                prop = replace(prop, "strutsfile,", "");
            } else if (prop.indexOf(", strutsfile") != -1) {
                prop = replace(prop, ", strutsfile", "");
            } else if (prop.indexOf("strutsfile") != -1) {
                prop = replace(prop, "strutsfile", "");
            }

            p.setProperty(Velocity.RESOURCE_LOADER, prop);
        }

        /**
         * Refactored the Velocity templates for the Struts taglib into the classpath from the web path.  This will
         * enable Struts projects to have access to the templates by simply including the Struts jar file.
         * Unfortunately, there does not appear to be a macro for the class loader keywords
         * Matt Ho - Mon Mar 17 00:21:46 PST 2003
         */
        p.setProperty("strutsclass.resource.loader.description", "Velocity Classpath Resource Loader");
        p.setProperty("strutsclass.resource.loader.class", "org.apache.struts2.views.velocity.StrutsResourceLoader");
        p.setProperty("strutsclass.resource.loader.modificationCheckInterval", "2");
        p.setProperty("strutsclass.resource.loader.cache", "true");

        // components
        StringBuffer sb = new StringBuffer();

        addDirective(sb, ActionDirective.class);
        addDirective(sb, BeanDirective.class);
        addDirective(sb, CheckBoxDirective.class);
        addDirective(sb, CheckBoxListDirective.class);
        addDirective(sb, ComboBoxDirective.class);
        addDirective(sb, ComponentDirective.class);
        addDirective(sb, DateDirective.class);
        addDirective(sb, DatePickerDirective.class);
        addDirective(sb, DivDirective.class);
        addDirective(sb, DoubleSelectDirective.class);
        addDirective(sb, FileDirective.class);
        addDirective(sb, FormDirective.class);
        addDirective(sb, HeadDirective.class);
        addDirective(sb, HiddenDirective.class);
        addDirective(sb, AnchorDirective.class);
        addDirective(sb, I18nDirective.class);
        addDirective(sb, IncludeDirective.class);
        addDirective(sb, LabelDirective.class);
        addDirective(sb, PanelDirective.class);
        addDirective(sb, ParamDirective.class);
        addDirective(sb, PasswordDirective.class);
        addDirective(sb, PushDirective.class);
        addDirective(sb, PropertyDirective.class);
        addDirective(sb, RadioDirective.class);
        addDirective(sb, SelectDirective.class);
        addDirective(sb, SetDirective.class);
        addDirective(sb, SubmitDirective.class);
        addDirective(sb, ResetDirective.class);
        addDirective(sb, TabbedPanelDirective.class);
        addDirective(sb, TextAreaDirective.class);
        addDirective(sb, TextDirective.class);
        addDirective(sb, TextFieldDirective.class);
        addDirective(sb, TokenDirective.class);
        addDirective(sb, TreeDirective.class);
        addDirective(sb, TreeNodeDirective.class);
        addDirective(sb, URLDirective.class);
        addDirective(sb, WebTableDirective.class);
        addDirective(sb, ActionErrorDirective.class);
        addDirective(sb, ActionMessageDirective.class);
        addDirective(sb, FieldErrorDirective.class);
        addDirective(sb, OptionTransferSelectDirective.class);
        addDirective(sb, UpDownSelectDirective.class);

        String directives = sb.toString();

        String userdirective = p.getProperty("userdirective");
        if ((userdirective == null) || userdirective.trim().equals("")) {
            userdirective = directives;
        } else {
            userdirective = userdirective.trim() + "," + directives;
        }

        p.setProperty("userdirective", userdirective);
    }

    private void addDirective(StringBuffer sb, Class clazz) {
        sb.append(clazz.getName()).append(",");
    }

    private static final String replace(String string, String oldString, String newString) {
        if (string == null) {
            return null;
        }
        // If the newString is null, just return the string since there's nothing to replace.
        if (newString == null) {
            return string;
        }
        int i = 0;
        // Make sure that oldString appears at least once before doing any processing.
        if ((i = string.indexOf(oldString, i)) >= 0) {
            // Use char []'s, as they are more efficient to deal with.
            char[] string2 = string.toCharArray();
            char[] newString2 = newString.toCharArray();
            int oLength = oldString.length();
            StringBuffer buf = new StringBuffer(string2.length);
            buf.append(string2, 0, i).append(newString2);
            i += oLength;
            int j = i;
            // Replace all remaining instances of oldString with newString.
            while ((i = string.indexOf(oldString, i)) > 0) {
                buf.append(string2, j, i - j).append(newString2);
                i += oLength;
                j = i;
            }
            buf.append(string2, j, string2.length - j);
            return buf.toString();
        }
        return string;
    }

	/**
	 * @return the velocityProperties
	 */
	public Properties getVelocityProperties() {
		return velocityProperties;
	}

	/**
	 * @param velocityProperties the velocityProperties to set
	 */
	public void setVelocityProperties(Properties velocityProperties) {
		this.velocityProperties = velocityProperties;
	}
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/AbstractDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import java.io.IOException;
import java.io.Writer;
import java.util.HashMap;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.ServletActionContext;
import org.apache.struts2.components.Component;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.runtime.directive.Directive;
import org.apache.velocity.runtime.parser.node.Node;

import com.opensymphony.xwork2.util.OgnlValueStack;

public abstract class AbstractDirective extends Directive {
    public String getName() {
        return "s" + getBeanName();
    }

    public abstract String getBeanName();

    /**
     * All components, unless otherwise stated, are LINE-level directives.
     */
    public int getType() {
        return LINE;
    }

    protected abstract Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res);

    public boolean render(InternalContextAdapter ctx, Writer writer, Node node) throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
        // get the bean
        OgnlValueStack stack = (OgnlValueStack) ctx.get("stack");
        HttpServletRequest req = (HttpServletRequest) stack.getContext().get(ServletActionContext.HTTP_REQUEST);
        HttpServletResponse res = (HttpServletResponse) stack.getContext().get(ServletActionContext.HTTP_RESPONSE);
        Component bean = getBean(stack, req, res);

        // get the parameters
        Map params = createPropertyMap(ctx, node);
        bean.copyParams(params);
        //bean.addAllParameters(params);
        bean.start(writer);

        if (getType() == BLOCK) {
            Node body = node.jjtGetChild(node.jjtGetNumChildren() - 1);
            body.render(ctx, writer);
        }

        bean.end(writer, "");
        return true;
    }

    /**
     * create a Map of properties that the user has passed in.  for example,
     * <pre>
     * #xxx("name=hello" "value=world" "template=foo")
     * </pre>
     * would yield a params that contains {["name", "hello"], ["value", "world"], ["template", "foo"]}
     *
     * @param node the Node passed in to the render method
     * @return a Map of the user specified properties
     * @throws org.apache.velocity.exception.ParseErrorException
     *          if the was an error in the format of the property
     */
    protected Map createPropertyMap(InternalContextAdapter contextAdapter, Node node) throws ParseErrorException, MethodInvocationException {
        Map propertyMap = new HashMap();

        int children = node.jjtGetNumChildren();
        if (getType() == BLOCK) {
            children--;
        }

        for (int index = 0, length = children; index < length; index++) {
            this.putProperty(propertyMap, contextAdapter, node.jjtGetChild(index));
        }

        return propertyMap;
    }

    /**
     * adds a given Node's key/value pair to the propertyMap.  For example, if this Node contained the value "rows=20",
     * then the key, rows, would be added to the propertyMap with the String value, 20.
     *
     * @param propertyMap a params containing all the properties that we wish to set
     * @param node        the parameter to set expressed in "name=value" format
     */
    protected void putProperty(Map propertyMap, InternalContextAdapter contextAdapter, Node node) throws ParseErrorException, MethodInvocationException {
        // node.value uses the StrutsValueStack to evaluate the directive's value parameter
        String param = node.value(contextAdapter).toString();

        int idx = param.indexOf("=");

        if (idx != -1) {
            String property = param.substring(0, idx);

            String value = param.substring(idx + 1);
            propertyMap.put(property, value);
        } else {
            throw new ParseErrorException("#" + this.getName() + " arguments must include an assignment operator!  For example #tag( Component \"template=mytemplate\" ).  #tag( TextField \"mytemplate\" ) is illegal!");
        }
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/ActionDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.ActionComponent;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see ActionComponent
 */
public class ActionDirective extends AbstractDirective {
    public String getBeanName() {
        return "action";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new ActionComponent(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/ActionErrorDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.ActionError;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see ActionError
 */
public class ActionErrorDirective extends AbstractDirective {
    public String getBeanName() {
        return "actionerror";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new ActionError(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/ActionMessageDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.ActionMessage;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see ActionMessage
 */
public class ActionMessageDirective extends AbstractDirective {
    public String getBeanName() {
        return "actionmessage";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new ActionMessage(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/AnchorDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Anchor;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Anchor
 */
public class AnchorDirective extends AbstractDirective {
    public String getBeanName() {
        return "a";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Anchor(stack, req, res);
    }

    public int getType() {
        return BLOCK;
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/BeanDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Bean;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Bean
 */
public class BeanDirective extends AbstractDirective {
    public String getBeanName() {
        return "bean";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Bean(stack);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/CheckBoxDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Checkbox;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Checkbox
 */
public class CheckBoxDirective extends AbstractDirective {
    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Checkbox(stack, req, res);
    }

    public String getBeanName() {
        return "checkbox";
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/CheckBoxListDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.CheckboxList;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see CheckboxList
 */
public class CheckBoxListDirective extends AbstractDirective {
    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new CheckboxList(stack, req, res);
    }

    public String getBeanName() {
        return "checkboxlist";
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/ComboBoxDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.ComboBox;
import org.apache.struts2.components.Component;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see ComboBox
 */
public class ComboBoxDirective extends AbstractDirective {
    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new ComboBox(stack, req, res);
    }

    public String getBeanName() {
        return "combobox";
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/ComponentDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.GenericUIBean;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see GenericUIBean
 */
public class ComponentDirective extends AbstractDirective {
    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new GenericUIBean(stack, req, res);
    }

    public String getBeanName() {
        return "component";
    }

    public int getType() {
        return BLOCK;
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/DateDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Date;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <code>DateDirective</code>
 */
public class DateDirective extends AbstractDirective {

    public String getBeanName() {
        return "date";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Date(stack);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/DatePickerDirective.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.DatePicker;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see DatePicker
 */
public class DatePickerDirective extends TextFieldDirective {
    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new DatePicker(stack, req, res);
    }

    public String getBeanName() {
        return "datepicker";
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/DivDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Div;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Div
 */
public class DivDirective extends AbstractDirective {
    public String getBeanName() {
        return "div";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Div(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/DoubleSelectDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.DoubleSelect;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see DoubleSelect
 */
public class DoubleSelectDirective extends AbstractDirective {
    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new DoubleSelect(stack, req, res);
    }

    public String getBeanName() {
        return "doubleselect";
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/FieldErrorDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.FieldError;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see FieldError
 */
public class FieldErrorDirective extends AbstractDirective {
    public String getBeanName() {
        return "fielderror";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new FieldError(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/FileDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.File;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see File
 */
public class FileDirective extends AbstractDirective {
    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new File(stack, req, res);
    }

    public String getBeanName() {
        return "file";
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/FormDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Form;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Form
 */
public class FormDirective extends AbstractDirective {
    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Form(stack, req, res);
    }

    public String getBeanName() {
        return "form";
    }

    public int getType() {
        return BLOCK;
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/HeadDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Head;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Head
 */
public class HeadDirective extends AbstractDirective {
    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Head(stack, req, res);
    }

    public String getBeanName() {
        return "head";
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/HiddenDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Hidden;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Hidden
 */
public class HiddenDirective extends AbstractDirective {
    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Hidden(stack, req, res);
    }

    public String getBeanName() {
        return "hidden";
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/I18nDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.I18n;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see I18n
 */
public class I18nDirective extends AbstractDirective {
    public String getBeanName() {
        return "i18n";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new I18n(stack);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/IncludeDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Include;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Include
 */
public class IncludeDirective extends AbstractDirective {
    public String getBeanName() {
        return "include";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Include(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/LabelDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Label;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Label
 */
public class LabelDirective extends AbstractDirective {
    public String getBeanName() {
        return "label";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Label(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/OptGroupDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.OptGroup;

import com.opensymphony.xwork2.util.OgnlValueStack;


/**
 * OptGroup velocity directive.
 */
public class OptGroupDirective extends AbstractDirective {

	protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
		return new OptGroup(stack, req, res);
	}

	public String getBeanName() {
		return "optgroup";
	}
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/OptionTransferSelectDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.OptionTransferSelect;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see OptionTransferSelect
 */
public class OptionTransferSelectDirective extends AbstractDirective {

	public String getBeanName() {
		return "optiontransferselect";
	}

	protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
		return new OptionTransferSelect(stack, req, res);
	}

}
"
core/src/main/java/org/apache/struts2/views/velocity/components/PanelDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Panel;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Panel
 */
public class PanelDirective extends AbstractDirective {
    public String getBeanName() {
        return "panel";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Panel(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/ParamDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Param;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Param
 */
public class ParamDirective extends AbstractDirective {
    public String getBeanName() {
        return "param";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Param(stack);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/PasswordDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Password;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Password
 */
public class PasswordDirective extends AbstractDirective {
    public String getBeanName() {
        return "password";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Password(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/PropertyDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Property;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 */
public class PropertyDirective extends AbstractDirective {
    public String getBeanName() {
        return "property";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Property(stack);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/PushDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Push;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Push
 */
public class PushDirective extends AbstractDirective {
    public String getBeanName() {
        return "push";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Push(stack);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/RadioDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Radio;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Radio
 */
public class RadioDirective extends AbstractDirective {
    public String getBeanName() {
        return "radio";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Radio(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/ResetDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Reset;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see org.apache.struts2.components.Reset
 */
public class ResetDirective extends AbstractDirective {
    public String getBeanName() {
        return "reset";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Reset(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/SelectDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Select;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Select
 */
public class SelectDirective extends AbstractDirective {
    public String getBeanName() {
        return "select";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Select(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/SetDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Set;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Set
 */
public class SetDirective extends AbstractDirective {
    public String getBeanName() {
        return "set";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Set(stack);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/SubmitDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Submit;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Submit
 */
public class SubmitDirective extends AbstractDirective {
    public String getBeanName() {
        return "submit";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Submit(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/TabbedPanelDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.TabbedPanel;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see TabbedPanel
 */
public class TabbedPanelDirective extends AbstractDirective {
    public String getBeanName() {
        return "tabbedpanel";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new TabbedPanel(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/TextAreaDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.TextArea;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see TextArea
 */
public class TextAreaDirective extends AbstractDirective {
    public String getBeanName() {
        return "textarea";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new TextArea(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/TextDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Text;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Text
 */
public class TextDirective extends AbstractDirective {
    public String getBeanName() {
        return "text";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Text(stack);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/TextFieldDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.TextField;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see TextField
 */
public class TextFieldDirective extends AbstractDirective {
    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new TextField(stack, req, res);
    }

    public String getBeanName() {
        return "textfield";
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/TokenDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Token;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see Token
 */
public class TokenDirective extends AbstractDirective {
    public String getBeanName() {
        return "token";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Token(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/TreeDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.Tree;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <code>TreeDirective</code>
 * @see Tree
 */
public class TreeDirective  extends AbstractDirective {
    public String getBeanName() {
        return "tree";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new Tree(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/TreeNodeDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.TreeNode;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <code>TreeNodeDirective</code>
 * @see TreeNode
 */
public class TreeNodeDirective  extends AbstractDirective {
    public String getBeanName() {
        return "treenode";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new TreeNode(stack, req, res);
    }
}

"
core/src/main/java/org/apache/struts2/views/velocity/components/UpDownSelectDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.UpDownSelect;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see UpDownSelect
 * 
 */
public class UpDownSelectDirective extends AbstractDirective {

	public String getBeanName() {
		return "updownselect";
	}

	protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
		return new UpDownSelect(stack, req, res);
	}
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/URLDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.URL;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see URL
 */
public class URLDirective extends AbstractDirective {
    public String getBeanName() {
        return "url";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new URL(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/velocity/components/WebTableDirective.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.velocity.components;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.struts2.components.Component;
import org.apache.struts2.components.table.WebTable;

import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * @see WebTable
 */
public class WebTableDirective extends AbstractDirective {
    public String getBeanName() {
        return "table";
    }

    protected Component getBean(OgnlValueStack stack, HttpServletRequest req, HttpServletResponse res) {
        return new WebTable(stack, req, res);
    }
}
"
core/src/main/java/org/apache/struts2/views/xslt/AbstractAdapterElement.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.xslt;

import java.util.HashMap;
import java.util.Map;

import org.w3c.dom.Attr;
import org.w3c.dom.DOMException;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.TypeInfo;

/**
 * AbstractAdapterElement extends the abstract Node type and implements
 * the DOM Element interface.
 */
public abstract class AbstractAdapterElement extends AbstractAdapterNode implements Element {

    private Map attributeAdapters;

    public AbstractAdapterElement() { }

    public void setAttribute(String string, String string1) throws DOMException {
        throw operationNotSupported();
    }

    protected Map getAttributeAdapters() {
        if ( attributeAdapters == null )
            attributeAdapters = buildAttributeAdapters();
        return attributeAdapters;
    }

    protected Map buildAttributeAdapters() {
        return new HashMap();
    }

    /**
     * No attributes, return empty attributes if asked.
     */
    public String getAttribute(String string) {
        return "";
    }

    public void setAttributeNS(String string, String string1, String string2) throws DOMException {
        throw operationNotSupported();
    }

    public String getAttributeNS(String string, String string1) {
        return null;
    }

    public Attr setAttributeNode(Attr attr) throws DOMException {
        throw operationNotSupported();
    }

    public Attr getAttributeNode( String name ) {
        return (Attr)getAttributes().getNamedItem( name );
    }

    public Attr setAttributeNodeNS(Attr attr) throws DOMException {
        throw operationNotSupported();
    }

    public Attr getAttributeNodeNS(String string, String string1) {
        throw operationNotSupported();
    }

    public String getNodeName() {
        return getTagName();
    }

    public short getNodeType() {
        return Node.ELEMENT_NODE;
    }

    public String getTagName() {
        return getPropertyName();
    }

    public boolean hasAttribute(String string) {
        return false;
    }

    public boolean hasAttributeNS(String string, String string1) {
        return false;
    }

    public boolean hasChildNodes() {
        return getElementsByTagName("*").getLength() > 0;
    }

    public void removeAttribute(String string) throws DOMException {
        throw operationNotSupported();
    }

    public void removeAttributeNS(String string, String string1) throws DOMException {
        throw operationNotSupported();
    }

    public Attr removeAttributeNode(Attr attr) throws DOMException {
        throw operationNotSupported();
    }

    public void setIdAttributeNode(Attr attr, boolean b) throws DOMException {
        throw operationNotSupported();
    }

    public TypeInfo getSchemaTypeInfo() {
        throw operationNotSupported();
    }

    public void setIdAttribute(String string, boolean b) throws DOMException {
        throw operationNotSupported();
    }

    public void setIdAttributeNS(String string, String string1, boolean b) throws DOMException {
        throw operationNotSupported();
    }

}

"
core/src/main/java/org/apache/struts2/views/xslt/AbstractAdapterNode.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.xslt;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.StrutsException;
import org.w3c.dom.DOMException;
import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.UserDataHandler;

/**
 * AbstractAdapterNode is the base for childAdapters that expose a read-only view
 * of a Java object as a DOM Node.  This class implements the core parent-child
 * and sibling node traversal functionality shared by all adapter type nodes
 * and used in proxy node support.
 *
 * @see AbstractAdapterElement
 */
public abstract class AbstractAdapterNode implements AdapterNode {

    private static final NamedNodeMap EMPTY_NAMEDNODEMAP =
            new NamedNodeMap() {
                public int getLength() {
                    return 0;
                }

                public Node item(int index) {
                    return null;
                }

                public Node getNamedItem(String name) {
                    return null;
                }

                public Node removeNamedItem(String name) throws DOMException {
                    return null;
                }

                public Node setNamedItem(Node arg) throws DOMException {
                    return null;
                }

                public Node setNamedItemNS(Node arg) throws DOMException {
                    return null;
                }

                public Node getNamedItemNS(String namespaceURI, String localName) {
                    return null;
                }

                public Node removeNamedItemNS(String namespaceURI, String localName) throws DOMException {
                    return null;
                }
            };

    private List<Node> childAdapters;
    private Log log = LogFactory.getLog(this.getClass());

    // The domain object that we are adapting
    private Object propertyValue;
    private String propertyName;
    private AdapterNode parent;
    private AdapterFactory adapterFactory;


    public AbstractAdapterNode() {
        if (LogFactory.getLog(getClass()).isDebugEnabled()) {
            LogFactory.getLog(getClass()).debug("Creating " + this);
        }
    }

    /**
     *
     * @param adapterFactory
     * @param parent
     * @param propertyName
     * @param value
     */
    protected void setContext(AdapterFactory adapterFactory, AdapterNode parent, String propertyName, Object value) {
        setAdapterFactory(adapterFactory);
        setParent(parent);
        setPropertyName(propertyName);
        setPropertyValue(value);
    }

    /**
     * subclasses override to produce their children
     *
     * @return List of child adapters.
     */
    protected List<Node> buildChildAdapters() {
        return new ArrayList<Node>();
    }

    /**
     * Lazily initialize child childAdapters
     */
    protected List<Node> getChildAdapters() {
        if (childAdapters == null) {
            childAdapters = buildChildAdapters();
        }
        return childAdapters;
    }

    public Node getChildBeforeOrAfter(Node child, boolean before) {
        log.debug("getChildBeforeOrAfter: ");
        List adapters = getChildAdapters();
        log.debug("childAdapters = " + adapters);
        log.debug("child = " + child);
        int index = adapters.indexOf(child);
        if (index < 0)
            throw new StrutsException(child + " is no child of " + this);
        int siblingIndex = before ? index - 1 : index + 1;
        return ((0 < siblingIndex) && (siblingIndex < adapters.size())) ?
                ((Node) adapters.get(siblingIndex)) : null;
    }

    public Node getChildAfter(Node child) {
        log.trace("getChildafter");
        return getChildBeforeOrAfter(child, false/*after*/);
    }

    public Node getChildBefore(Node child) {
        log.trace("getchildbefore");
        return getChildBeforeOrAfter(child, true/*after*/);
    }

    public NodeList getElementsByTagName(String tagName) {
        if (tagName.equals("*")) {
            return getChildNodes();
        } else {
            LinkedList<Node> filteredChildren = new LinkedList<Node>();

            for (Node adapterNode : getChildAdapters()) {
                if (adapterNode.getNodeName().equals(tagName)) {
                    filteredChildren.add(adapterNode);
                }
            }

            return new SimpleNodeList(filteredChildren);
        }
    }

    public NodeList getElementsByTagNameNS(String string, String string1) {
        // TODO:
        return null;
    }

    // Begin Node methods

    public NamedNodeMap getAttributes() {
        return EMPTY_NAMEDNODEMAP;
    }

    public NodeList getChildNodes() {
        NodeList nl = new SimpleNodeList(getChildAdapters());
        if (log.isDebugEnabled())
            log.debug("getChildNodes for tag: "
                    + getNodeName() + " num children: " + nl.getLength());
        return nl;
    }

    public Node getFirstChild() {
        return (getChildNodes().getLength() > 0) ? getChildNodes().item(0) : null;
    }

    public Node getLastChild() {
        return (getChildNodes().getLength() > 0) ? getChildNodes().item(getChildNodes().getLength() - 1) : null;
    }


    public String getLocalName() {
        return null;
    }

    public String getNamespaceURI() {
        return null;
    }

    public void setNodeValue(String string) throws DOMException {
        throw operationNotSupported();
    }

    public String getNodeValue() throws DOMException {
        throw operationNotSupported();
    }

    public Document getOwnerDocument() {
        return null;
    }

    public Node getParentNode() {
        log.trace("getParentNode");
        return getParent();
    }

    public AdapterNode getParent() {
        return parent;
    }

    public void setParent(AdapterNode parent) {
        this.parent = parent;
    }

    public Object getPropertyValue() {
        return propertyValue;
    }

    public void setPropertyValue(Object prop) {
        this.propertyValue = prop;
    }

    public void setPrefix(String string) throws DOMException {
        throw operationNotSupported();
    }

    public String getPrefix() {
        return null;
    }

    public Node getNextSibling() {
        Node next = getParent().getChildAfter(this);
        if (log.isTraceEnabled()) {
            log.trace("getNextSibling on " + getNodeName() + ": "
                    + ((next == null) ? "null" : next.getNodeName()));
        }

        return getParent().getChildAfter(this);
    }

    public Node getPreviousSibling() {
        return getParent().getChildBefore(this);
    }

    public String getPropertyName() {
        return propertyName;
    }

    public void setPropertyName(String name) {
        this.propertyName = name;
    }

    public AdapterFactory getAdapterFactory() {
        return adapterFactory;
    }

    public void setAdapterFactory(AdapterFactory adapterFactory) {
        this.adapterFactory = adapterFactory;
    }

    public boolean isSupported(String string, String string1) {
        throw operationNotSupported();
    }

    public Node appendChild(Node node) throws DOMException {
        throw operationNotSupported();
    }

    public Node cloneNode(boolean b) {
        log.trace("cloneNode");
        throw operationNotSupported();
    }

    public boolean hasAttributes() {
        return false;
    }

    public boolean hasChildNodes() {
        return false;
    }

    public Node insertBefore(Node node, Node node1) throws DOMException {
        throw operationNotSupported();
    }

    public void normalize() {
        log.trace("normalize");
        throw operationNotSupported();
    }

    public Node removeChild(Node node) throws DOMException {
        throw operationNotSupported();
    }

    public Node replaceChild(Node node, Node node1) throws DOMException {
        throw operationNotSupported();
    }

    // Begin DOM 3 methods

    public boolean isDefaultNamespace(String string) {
        throw operationNotSupported();
    }

    public String lookupNamespaceURI(String string) {
        throw operationNotSupported();
    }

    public String getNodeName() {
        throw operationNotSupported();
    }

    public short getNodeType() {
        throw operationNotSupported();
    }

    public String getBaseURI() {
        throw operationNotSupported();
    }

    public short compareDocumentPosition(Node node) throws DOMException {
        throw operationNotSupported();
    }

    public String getTextContent() throws DOMException {
        throw operationNotSupported();
    }

    public void setTextContent(String string) throws DOMException {
        throw operationNotSupported();

    }

    public boolean isSameNode(Node node) {
        throw operationNotSupported();
    }

    public String lookupPrefix(String string) {
        throw operationNotSupported();
    }

    public boolean isEqualNode(Node node) {
        throw operationNotSupported();
    }

    public Object getFeature(String string, String string1) {
        throw operationNotSupported();
    }

    public Object setUserData(String string, Object object, UserDataHandler userDataHandler) {
        throw operationNotSupported();
    }

    public Object getUserData(String string) {
        throw operationNotSupported();
    }

    // End node methods

    protected StrutsException operationNotSupported() {
        return new StrutsException("Operation not supported.");
    }

    public String toString() {
        return getClass() + ": " + getNodeName() + " parent=" + getParentNode();
    }
}
"
core/src/main/java/org/apache/struts2/views/xslt/AdapterFactory.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.xslt;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

import org.apache.struts2.StrutsException;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.Text;

/**
 * AdapterFactory produces Node adapters for Java object types.
 * Adapter classes are generally instantiated dynamically via a no-args constructor
 * and populated with their context information via the AdapterNode interface.
 *
 * This factory supports proxying of generic DOM Node trees, allowing arbitrary
 * Node types to be mixed together.  You may simply return a Document or Node
 * type as an object property and it will appear as a sub-tree in the XML as
 * you'd expect. See #proxyNode().
 *
 * Customization of the result XML can be accomplished by providing
 * alternate adapters for Java types.  Adapters are associated with Java
 * types through the registerAdapterType() method.
 *
 * For example, since there is no default Date adapter, Date objects will be
 * rendered with the generic Bean introspecting adapter, producing output
 * like:
 * <pre>
     <date>
        <date>19</date>
        <day>1</day>
        <hours>0</hours>
        <minutes>7</minutes>
        <month>8</month>
        <seconds>4</seconds>
        <time>1127106424531</time>
        <timezoneOffset>300</timezoneOffset>
        <year>105</year>
    </date>
 * </pre>
 *
 * By extending the StringAdapter and overriding its normal behavior we can
 * create a custom Date formatter:
 *
 * <pre>
      public static class CustomDateAdapter extends StringAdapter {
        protected String getStringValue() {
            Date date = (Date)getPropertyValue();
            return DateFormat.getTimeInstance( DateFormat.FULL ).format( date );
        }
    }
 * </pre>
 *
 * Producing output like:
 *
<pre>
     <date>12:02:54 AM CDT</date>
 </pre>
 *
 * The StringAdapter (which is normally invoked only to adapt String values)
 * is a useful base for these kinds of customizations and can produce
 * structured XML output as well as plain text by setting its parseStringAsXML()
 * property to true.
 *
 * See provided examples.
 */
public class AdapterFactory {

    /**
     * Map<Class, Class<AdapterNode>>
     */
    private Map<Class, Class> adapterTypes = new HashMap<Class, Class>();

    /**
     * Register an adapter type for a Java class type.
     *
     * @param type        the Java class type which is to be handled by the adapter.
     * @param adapterType The adapter class, which implements AdapterNode.
     */
    public void registerAdapterType(Class type, Class adapterType) {
        adapterTypes.put(type, adapterType);
    }

    /**
     * Create a top level Document adapter for the specified Java object.
     * The document will have a root element with the specified property name
     * and contain the specified Java object content.
     *
     * @param propertyName The name of the root document element
     * @return
     * @throws IllegalAccessException
     * @throws InstantiationException
     */
    public Document adaptDocument(String propertyName, Object propertyValue)
            throws IllegalAccessException, InstantiationException {
        //if ( propertyValue instanceof Document )
        //	return (Document)propertyValue;

        return new SimpleAdapterDocument(this, null, propertyName, propertyValue);
    }


    /**
     * Create an Node adapter for a child element.
     * Note that the parent of the created node must be an AdapterNode, however
     * the child node itself may be any type of Node.
     *
     * @see #adaptDocument( String, Object )
     */
    public Node adaptNode(AdapterNode parent, String propertyName, Object value) {
        Class adapterClass = getAdapterForValue(value);
        if (adapterClass != null)
            return constructAdapterInstance(adapterClass, parent, propertyName, value);

        // If the property is a Document, "unwrap" it to the root element
        if (value instanceof Document)
            value = ((Document) value).getDocumentElement();

        // If the property is already a Node, proxy it
        if (value instanceof Node)
            return proxyNode(parent, (Node) value);

        // Check other supported types or default to generic JavaBean introspecting adapter
        Class valueType = value.getClass();

        if (valueType.isArray())
            adapterClass = ArrayAdapter.class;
        else if (value instanceof String || value instanceof Number || valueType.isPrimitive())
            adapterClass = StringAdapter.class;
        else if (value instanceof Collection)
            adapterClass = CollectionAdapter.class;
        else if (value instanceof Map)
            adapterClass = MapAdapter.class;
        else
            adapterClass = BeanAdapter.class;

        return constructAdapterInstance(adapterClass, parent, propertyName, value);
    }

    /**
     * Construct a proxy adapter for a value that is an existing DOM Node.
     * This allows arbitrary DOM Node trees to be mixed in with our results.
     * The proxied nodes are read-only and currently support only
     * limited types of Nodes including Element, Text, and Attributes.  (Other
     * Node types may be ignored by the proxy and not appear in the result tree).
     * <p/>
     * // TODO:
     * NameSpaces are not yet supported.
     * <p/>
     * This method is primarily for use by the adapter node classes.
     */
    public Node proxyNode(AdapterNode parent, Node node) {
        // If the property is a Document, "unwrap" it to the root element
        if (node instanceof Document)
            node = ((Document) node).getDocumentElement();

        if (node == null)
            return null;
        if (node.getNodeType() == Node.ELEMENT_NODE)
            return new ProxyElementAdapter(this, parent, (Element) node);
        if (node.getNodeType() == Node.TEXT_NODE)
            return new ProxyTextNodeAdapter(this, parent, (Text) node);
        if (node.getNodeType() == Node.ATTRIBUTE_NODE)
            return new ProxyAttrAdapter(this, parent, (Attr) node);

        return null; // Unsupported Node type - ignore for now
    }

    public NamedNodeMap proxyNamedNodeMap(AdapterNode parent, NamedNodeMap nnm) {
        return new ProxyNamedNodeMap(this, parent, nnm);
    }

    /**
     * Create an instance of an adapter dynamically and set its context via
     * the AdapterNode interface.
     */
    private Node constructAdapterInstance(Class adapterClass, AdapterNode parent, String propertyName, Object propertyValue) {
        // Check to see if the class has a no-args constructor
        try {
            adapterClass.getConstructor(new Class []{});
        } catch (NoSuchMethodException e1) {
            throw new StrutsException("Adapter class: " + adapterClass
                    + " does not have a no-args consructor.");
        }

        try {
            AdapterNode adapterNode = (AdapterNode) adapterClass.newInstance();
            adapterNode.setAdapterFactory(this);
            adapterNode.setParent(parent);
            adapterNode.setPropertyName(propertyName);
            adapterNode.setPropertyValue(propertyValue);

            return adapterNode;

        } catch (IllegalAccessException e) {
            e.printStackTrace();
            throw new StrutsException("Cannot adapt " + propertyValue + " (" + propertyName + ") :" + e.getMessage());
        } catch (InstantiationException e) {
            e.printStackTrace();
            throw new StrutsException("Cannot adapt " + propertyValue + " (" + propertyName + ") :" + e.getMessage());
        }
    }

    /**
     * Create an appropriate adapter for a null value.
     *
     * @param parent
     * @param propertyName
     */
    public Node adaptNullValue(BeanAdapter parent, String propertyName) {
        return new StringAdapter(this, parent, propertyName, "null");
    }

    //TODO: implement Configuration option to provide additional adapter classes
    public Class getAdapterForValue(Object value) {
        return adapterTypes.get(value.getClass());
    }
}
"
core/src/main/java/org/apache/struts2/views/xslt/AdapterNode.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.xslt;

import org.w3c.dom.Node;

/**
 */
public interface AdapterNode extends Node {

    /**
     * The adapter factory that created this node.
     */
    AdapterFactory getAdapterFactory();

    /**
     * The adapter factory that created this node.
     */
    void setAdapterFactory(AdapterFactory factory);

    /**
     * The parent adapter node of this node. Note that our parent must be another adapter node, but our children may be any
     * kind of Node.
     */
    AdapterNode getParent();

    /**
     * The parent adapter node of this node. Note that our parent must be another adapter node, but our children may be any
     * kind of Node.
     */
    void setParent(AdapterNode parent);

    /**
     * The child node before the specified sibling
     */
    Node getChildBefore(Node thisNode);

    /**
     * The child node after the specified sibling
     */
    Node getChildAfter(Node thisNode);

    /**
     * The name of the Java object (property) that we are adapting
     */
    String getPropertyName();

    /**
     * The name of the Java object (property) that we are adapting
     */
    void setPropertyName(String name);

    /**
     * The Java object (property) that we are adapting
     */
    Object getPropertyValue();

    /** The Java object (property) that we are adapting */
    void setPropertyValue(Object prop );
}
"
core/src/main/java/org/apache/struts2/views/xslt/ArrayAdapter.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.xslt;

import java.util.ArrayList;
import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.w3c.dom.Node;


/**
 */
public class ArrayAdapter extends AbstractAdapterElement {

    private Log log = LogFactory.getLog(this.getClass());

    public ArrayAdapter() {
    }

    public ArrayAdapter(AdapterFactory adapterFactory, AdapterNode parent, String propertyName, Object value) {
        setContext(adapterFactory, parent, propertyName, value);
    }

    protected List<Node> buildChildAdapters() {
        List<Node> children = new ArrayList<Node>();
        Object[] values = (Object[]) getPropertyValue();

        for (Object value : values) {
            Node childAdapter = getAdapterFactory().adaptNode(this, "item", value);
            if (childAdapter != null)
                children.add(childAdapter);

            if (log.isDebugEnabled()) {
                log.debug(this + " adding adapter: " + childAdapter);
            }
        }

        return children;
    }
}
"
core/src/main/java/org/apache/struts2/views/xslt/BeanAdapter.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.xslt;

import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.StrutsException;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;


/**
 * This class is the most general type of adapter, utilizing reflective introspection to present a DOM view of all of
 * the public properties of its value.  For example, a property returning a JavaBean such as:
 *
 * <pre>
 * public Person getMyPerson() { ... }
 * ...
 * class Person {
 * 		public String getFirstName();
 * 		public String getLastName();
 * }
 * </pre>
 *
 * would be rendered as: <myPerson> <firstName>...</firstName> <lastName>...</lastName> </myPerson>
 */
public class BeanAdapter extends AbstractAdapterElement {
    //~ Static fields/initializers /////////////////////////////////////////////

    private static final Object[] NULLPARAMS = new Object[0];

    /**
     * Cache can savely be static because the cached information is the same for all instances of this class.
     */
    private static Map<Class, PropertyDescriptor[]> propertyDescriptorCache;

    //~ Instance fields ////////////////////////////////////////////////////////

    private Log log = LogFactory.getLog(this.getClass());

    //~ Constructors ///////////////////////////////////////////////////////////

    public BeanAdapter() {
    }

    public BeanAdapter(
            AdapterFactory adapterFactory, AdapterNode parent, String propertyName, Object value) {
        setContext(adapterFactory, parent, propertyName, value);
    }

    //~ Methods ////////////////////////////////////////////////////////////////

    public String getTagName() {
        return getPropertyName();
    }

    public NodeList getChildNodes() {
        NodeList nl = super.getChildNodes();
        // Log child nodes for debug:
        if (log.isDebugEnabled() && nl != null) {
            log.debug("BeanAdapter getChildNodes for: " + getTagName());
            log.debug(nl.toString());
        }
        return nl;
    }

    protected List<Node> buildChildAdapters() {
        log.debug("BeanAdapter building children.  PropName = " + getPropertyName());
        List<Node> newAdapters = new ArrayList<Node>();
        Class type = getPropertyValue().getClass();
        PropertyDescriptor[] props = getPropertyDescriptors(getPropertyValue());

        if (props.length > 0) {
            for (PropertyDescriptor prop : props) {
                Method m = prop.getReadMethod();
                log.debug("Bean reading property method: " + m.getName());

                if (m == null) {
                    //FIXME: write only property or indexed access
                    continue;
                }

                String propertyName = prop.getName();
                Object propertyValue;

                /*
                    Unwrap any invocation target exceptions and log them.
                    We really need a way to control which properties are accessed.
                    Perhaps with annotations in Java5?
                */
                try {
                    propertyValue = m.invoke(getPropertyValue(), NULLPARAMS);
                } catch (Exception e) {
                    if (e instanceof InvocationTargetException)
                        e = (Exception) ((InvocationTargetException) e).getTargetException();
                    log.error(e);
                    continue;
                }

                Node childAdapter;

                if (propertyValue == null) {
                    childAdapter = getAdapterFactory().adaptNullValue(this, propertyName);
                } else {
                    childAdapter = getAdapterFactory().adaptNode(this, propertyName, propertyValue);
                }

                if (childAdapter != null)
                    newAdapters.add(childAdapter);

                if (log.isDebugEnabled()) {
                    log.debug(this + " adding adapter: " + childAdapter);
                }
            }
        } else {
            // No properties found
            log.info(
                    "Class " + type.getName() + " has no readable properties, " + " trying to adapt " + getPropertyName() + " with StringAdapter...");
        }

        return newAdapters;
    }

    /**
     * Caching facade method to Introspector.getBeanInfo(Class, Class).getPropertyDescriptors();
     */
    private synchronized PropertyDescriptor[] getPropertyDescriptors(Object bean) {
        try {
            if (propertyDescriptorCache == null) {
                propertyDescriptorCache = new HashMap<Class, PropertyDescriptor[]>();
            }

            PropertyDescriptor[] props = propertyDescriptorCache.get(bean.getClass());

            if (props == null) {
                log.debug("Caching property descriptor for " + bean.getClass().getName());
                props = Introspector.getBeanInfo(bean.getClass(), Object.class).getPropertyDescriptors();
                propertyDescriptorCache.put(bean.getClass(), props);
            }

            return props;
        } catch (IntrospectionException e) {
            e.printStackTrace();
            throw new StrutsException("Error getting property descriptors for " + bean + " : " + e.getMessage());
        }
    }
}
"
core/src/main/java/org/apache/struts2/views/xslt/CollectionAdapter.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.xslt;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.w3c.dom.Node;


/**
 */
public class CollectionAdapter extends AbstractAdapterElement {

    private Log log = LogFactory.getLog(this.getClass());

	public CollectionAdapter() { }

	public CollectionAdapter(AdapterFactory rootAdapterFactory, AdapterNode parent, String propertyName, Object value) {
        setContext(rootAdapterFactory, parent, propertyName, value);
    }

    protected List<Node> buildChildAdapters() {
        Collection values = (Collection) getPropertyValue();
        List<Node> children = new ArrayList<Node>(values.size());

        for (Object value : values) {
            Node childAdapter = getAdapterFactory().adaptNode(this, "item", value);
            if (childAdapter != null)
                children.add(childAdapter);

            if (log.isDebugEnabled()) {
                log.debug(this + " adding adapter: " + childAdapter);
            }
        }

        return children;
    }
}
"
core/src/main/java/org/apache/struts2/views/xslt/MapAdapter.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.xslt;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.w3c.dom.Node;

/**
 * MapAdapter adapters a java.util.Map type to an XML DOM with the following
 * structure:
 * <pre>
 * 	<myMap>
 * 		<entry>
 * 			<key>...</key>
 * 			<value>...</value>
 * 		</entry>
 * 		...
 * 	</myMap>
 * </pre>
 */
public class MapAdapter extends AbstractAdapterElement {

    public MapAdapter() { }

    public MapAdapter(AdapterFactory adapterFactory, AdapterNode parent, String propertyName, Map value) {
        setContext( adapterFactory, parent, propertyName, value );
    }

    public Map map() {
        return (Map)getPropertyValue();
    }

    protected List<Node> buildChildAdapters() {
        List<Node> children = new ArrayList<Node>(map().entrySet().size());

        for (Object o : map().entrySet()) {
            Map.Entry entry = (Map.Entry) o;
            Object key = entry.getKey();
            Object value = entry.getValue();
            EntryElement child = new EntryElement(
                    getAdapterFactory(), this, "entry", key, value);
            children.add(child);
        }

        return children;
    }

    class EntryElement extends AbstractAdapterElement {
        Object key, value;

        public EntryElement(  AdapterFactory adapterFactory,
                              AdapterNode parent, String propertyName, Object key, Object value ) {
            setContext( adapterFactory, parent, propertyName, null/*we have two values*/ );
            this.key = key;
            this.value = value;
        }

        protected List<Node> buildChildAdapters() {
            List<Node> children = new ArrayList<Node>();
            children.add( getAdapterFactory().adaptNode( this, "key", key ) );
            children.add( getAdapterFactory().adaptNode( this, "value", value ) );
            return children;
        }
    }
}
"
core/src/main/java/org/apache/struts2/views/xslt/ProxyAttrAdapter.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.xslt;

import org.w3c.dom.Attr;
import org.w3c.dom.DOMException;
import org.w3c.dom.Element;
import org.w3c.dom.TypeInfo;

/**
 * ProxyAttrAdapter is a pass-through adapter for objects which already
 * implement the Attr interface.  All methods are proxied to the underlying
 * Node except node traversal (e.g. getParent()) related methods which
 * are implemented by the abstract adapter node to work with the parent adapter.
 */
public class ProxyAttrAdapter extends ProxyNodeAdapter implements Attr {

    public ProxyAttrAdapter(AdapterFactory factory, AdapterNode parent, Attr value) {
        super(factory, parent, value);
    }

    // convenience
    protected Attr attr() {
        return (Attr) getPropertyValue();
    }

    // Proxied Attr methods

    public String getName() {
        return attr().getName();
    }

    public boolean getSpecified() {
        return attr().getSpecified();
    }

    public String getValue() {
        return attr().getValue();
    }

    public void setValue(String string) throws DOMException {
        throw new UnsupportedOperationException();
    }

    public Element getOwnerElement() {
        return (Element) getParent();
    }

    // DOM level 3

    public TypeInfo getSchemaTypeInfo() {
        throw operationNotSupported();
    }

    public boolean isId() {
        throw operationNotSupported();
    }

    // end DOM level 3

    // End Proxied Attr methods

    public String toString() {
        return "ProxyAttribute for: " + attr();
    }
}

"
core/src/main/java/org/apache/struts2/views/xslt/ProxyElementAdapter.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.xslt;

import java.util.ArrayList;
import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.w3c.dom.Attr;
import org.w3c.dom.DOMException;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.TypeInfo;

/**
 * ProxyElementAdapter is a pass-through adapter for objects which already
 * implement the Element interface.  All methods are proxied to the underlying
 * Node except getParent(), getNextSibling() and getPreviousSibling(), which
 * are implemented by the abstract adapter node to work with the parent adapter.
 *
 * Note: this class wants to be (extend) both an AbstractElementAdapter
 * and ProxyElementAdapter, but its proxy-ness is winning right now.
 */
public class ProxyElementAdapter extends ProxyNodeAdapter implements Element {

    private Log log = LogFactory.getLog(this.getClass());

    public ProxyElementAdapter(AdapterFactory factory, AdapterNode parent, Element value) {
        super(factory, parent, value);
    }

    /**
     * Get the proxied Element
     */
    protected Element element() {
        return (Element) getPropertyValue();
    }

    protected List<Node> buildChildAdapters() {
        List<Node> adapters = new ArrayList<Node>();
        NodeList children = node().getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            Node child = children.item(i);
            Node adapter = wrap(child);
            if (adapter != null) {
                log.debug("wrapped child node: " + child.getNodeName());
                adapters.add(adapter);
            }
        }
        return adapters;
    }

    // Proxied Element methods

    public String getTagName() {
        return element().getTagName();
    }

    public boolean hasAttribute(String name) {
        return element().hasAttribute(name);
    }

    public String getAttribute(String name) {
        return element().getAttribute(name);
    }

    public boolean hasAttributeNS(String namespaceURI, String localName) {
        return element().hasAttributeNS(namespaceURI, localName);
    }

    public Attr getAttributeNode(String name) {
        log.debug("wrapping attribute");
        return (Attr) wrap(element().getAttributeNode(name));
    }

    // I'm overriding this just for clarity.  The base impl is correct.
    public NodeList getElementsByTagName(String name) {
        return super.getElementsByTagName(name);
    }

    public String getAttributeNS(String namespaceURI, String localName) {
        return element().getAttributeNS(namespaceURI, localName);
    }

    public Attr getAttributeNodeNS(String namespaceURI, String localName) {
        return (Attr) wrap(element().getAttributeNodeNS(namespaceURI, localName));
    }

    public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {
        return super.getElementsByTagNameNS(namespaceURI, localName);
    }

    // Unsupported mutators of Element

    public void removeAttribute(String name) throws DOMException {
        throw new UnsupportedOperationException();
    }

    public void removeAttributeNS(String namespaceURI, String localName) throws DOMException {
        throw new UnsupportedOperationException();
    }

    public void setAttribute(String name, String value) throws DOMException {
        throw new UnsupportedOperationException();
    }

    public Attr removeAttributeNode(Attr oldAttr) throws DOMException {
        throw new UnsupportedOperationException();
    }

    public Attr setAttributeNode(Attr newAttr) throws DOMException {
        throw new UnsupportedOperationException();
    }

    public Attr setAttributeNodeNS(Attr newAttr) throws DOMException {
        throw new UnsupportedOperationException();
    }

    public void setAttributeNS(String namespaceURI, String qualifiedName, String value) throws DOMException {
        throw new UnsupportedOperationException();
    }

    // end proxied Element methods

    // unsupported DOM level 3 methods

    public TypeInfo getSchemaTypeInfo() {
        throw operationNotSupported();
    }

    public void setIdAttribute(String string, boolean b) throws DOMException {
        throw operationNotSupported();
    }

    public void setIdAttributeNS(String string, String string1, boolean b) throws DOMException {
        throw operationNotSupported();
    }

    public void setIdAttributeNode(Attr attr, boolean b) throws DOMException {
        throw operationNotSupported();
    }

    // end DOM level 3 methods

    public String toString() {
        return "ProxyElement for: " + element();
    }
}
"
core/src/main/java/org/apache/struts2/views/xslt/ProxyNamedNodeMap.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.xslt;

import org.w3c.dom.DOMException;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;

/**
 * A NamedNodeMap that wraps the Nodes returned in their proxies.
 *
 * Note: Since maps have no guaranteed order we don't need to worry about identity
 * here as we do with "child" adapters.  In that case we need to preserve identity
 * in order to support finding the next/previous siblings.
 */
public class ProxyNamedNodeMap implements NamedNodeMap {

    private NamedNodeMap nodes;
    private AdapterFactory adapterFactory;
    private AdapterNode parent;

    public ProxyNamedNodeMap(AdapterFactory factory, AdapterNode parent, NamedNodeMap nodes) {
        this.nodes = nodes;
        this.adapterFactory = factory;
        this.parent = parent;
    }

    protected Node wrap(Node node) {
        return adapterFactory.proxyNode(parent, node);
    }

    public int getLength() {
        return nodes.getLength();
    }

    public Node item(int index) {
        return wrap(nodes.item(index));
    }

    public Node getNamedItem(String name) {
        return wrap(nodes.getNamedItem(name));
    }

    public Node removeNamedItem(String name) throws DOMException {
        throw new UnsupportedOperationException();
    }

    public Node setNamedItem(Node arg) throws DOMException {
        throw new UnsupportedOperationException();
    }

    public Node setNamedItemNS(Node arg) throws DOMException {
        throw new UnsupportedOperationException();
    }

    public Node getNamedItemNS(String namespaceURI, String localName) {
        return wrap(nodes.getNamedItemNS(namespaceURI, localName));
    }

    public Node removeNamedItemNS(String namespaceURI, String localName) throws DOMException {
        throw new UnsupportedOperationException();
    }
}
"
core/src/main/java/org/apache/struts2/views/xslt/ProxyNodeAdapter.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.xslt;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.w3c.dom.DOMException;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;

/**
 * ProxyNodeAdapter is a read-only delegating adapter for objects which already
 * implement the Node interface.  All methods are proxied to the underlying
 * Node except getParent(), getNextSibling() and getPreviousSibling(), which
 * are implemented by the abstract adapter node to work with the parent adapter.
 */
public abstract class ProxyNodeAdapter extends AbstractAdapterNode {
    
    private Log log = LogFactory.getLog(this.getClass());

    public ProxyNodeAdapter(AdapterFactory factory, AdapterNode parent, Node value) {
        setContext(factory, parent, "document"/*propname unused*/, value);
        log.debug("proxied node is: " + value);
        log.debug("node class is: " + value.getClass());
        log.debug("node type is: " + value.getNodeType());
        log.debug("node name is: " + value.getNodeName());
    }

    /**
     * Get the proxied Node value
     */
    protected Node node() {
        return (Node) getPropertyValue();
    }

    /**
     * Get and adapter to wrap the proxied node.
     *
     * @param node
     */
    protected Node wrap(Node node) {
        return getAdapterFactory().proxyNode(this, node);
    }

    protected NamedNodeMap wrap(NamedNodeMap nnm) {
        return getAdapterFactory().proxyNamedNodeMap(this, nnm);
    }
    //protected NodeList wrap( NodeList nl ) { }

    //protected Node unwrap( Node child ) {
    //	return ((ProxyNodeAdapter)child).node();
    //}

    // Proxied Node methods

    public String getNodeName() {
        log.trace("getNodeName");
        return node().getNodeName();
    }

    public String getNodeValue() throws DOMException {
        log.trace("getNodeValue");
        return node().getNodeValue();
    }

    public short getNodeType() {
        if (log.isTraceEnabled())
            log.trace("getNodeType: " + getNodeName() + ": " + node().getNodeType());
        return node().getNodeType();
    }

    public NamedNodeMap getAttributes() {
        NamedNodeMap nnm = wrap(node().getAttributes());
        if (log.isTraceEnabled())
            log.trace("getAttributes: " + nnm);
        return nnm;
    }

    public boolean hasChildNodes() {
        log.trace("hasChildNodes");
        return node().hasChildNodes();
    }

    public boolean isSupported(String s, String s1) {
        log.trace("isSupported");
        // Is this ok?  What kind of features are they asking about?
        return node().isSupported(s, s1);
    }

    public String getNamespaceURI() {
        log.trace("getNamespaceURI");
        return node().getNamespaceURI();
    }

    public String getPrefix() {
        log.trace("getPrefix");
        return node().getPrefix();
    }

    public String getLocalName() {
        log.trace("getLocalName");
        return node().getLocalName();
    }

    public boolean hasAttributes() {
        log.trace("hasAttributes");
        return node().hasAttributes();
    }

    // End proxied Node methods

    public String toString() {
        return "ProxyNode for: " + node();
    }
}

"
core/src/main/java/org/apache/struts2/views/xslt/ProxyTextNodeAdapter.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.xslt;

import org.w3c.dom.DOMException;
import org.w3c.dom.Text;

/**
 * ProxyTextNodeAdapter is a pass-through adapter for objects which already
 * implement the Text interface.  All methods are proxied to the underlying
 * Node except getParent(), getNextSibling() and getPreviousSibling(), which
 * are implemented by the abstract adapter node to work with the parent adapter.
 */
public class ProxyTextNodeAdapter extends ProxyNodeAdapter implements Text {

    public ProxyTextNodeAdapter(AdapterFactory factory, AdapterNode parent, Text value) {
        super(factory, parent, value);
    }

    // convenience
    Text text() {
        return (Text) getPropertyValue();
    }

    public String toString() {
        return "ProxyTextNode for: " + text();
    }

    public Text splitText(int offset) throws DOMException {
        throw new UnsupportedOperationException();
    }

    public int getLength() {
        return text().getLength();
    }

    public void deleteData(int offset, int count) throws DOMException {
        throw new UnsupportedOperationException();
    }

    public String getData() throws DOMException {
        return text().getData();
    }

    public String substringData(int offset, int count) throws DOMException {
        return text().substringData(offset, count);
    }

    public void replaceData(int offset, int count, String arg) throws DOMException {
        throw new UnsupportedOperationException();
    }

    public void insertData(int offset, String arg) throws DOMException {
        throw new UnsupportedOperationException();
    }

    public void appendData(String arg) throws DOMException {
        throw new UnsupportedOperationException();
    }

    public void setData(String data) throws DOMException {
        throw new UnsupportedOperationException();
    }

    // DOM level 3

    public boolean isElementContentWhitespace() {
        throw operationNotSupported();
    }

    public String getWholeText() {
        throw operationNotSupported();
    }

    public Text replaceWholeText(String string) throws DOMException {
        throw operationNotSupported();
    }
}

"
core/src/main/java/org/apache/struts2/views/xslt/ServletURIResolver.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.xslt;

import java.io.InputStream;

import javax.servlet.ServletContext;
import javax.xml.transform.Source;
import javax.xml.transform.TransformerException;
import javax.xml.transform.URIResolver;
import javax.xml.transform.stream.StreamSource;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;


/**
 * ServletURIResolver is a URIResolver that can retrieve resources from the servlet context using the scheme "response".
 * e.g.
 *
 * A URI resolver is called when a stylesheet uses an xsl:include, xsl:import, or document() function to find the
 * resource (file).
 */
public class ServletURIResolver implements URIResolver {

    private Log log = LogFactory.getLog(getClass());
    static final String PROTOCOL = "response:";

    private ServletContext sc;

    public ServletURIResolver(ServletContext sc) {
        log.trace("ServletURIResolver: " + sc);
        this.sc = sc;
    }

    public Source resolve(String href, String base) throws TransformerException {
        log.debug("ServletURIResolver resolve(): href=" + href + ", base=" + base);
        if (href.startsWith(PROTOCOL)) {
            String res = href.substring(PROTOCOL.length());
            log.debug("Resolving resource <" + res + ">");

            InputStream is = sc.getResourceAsStream(res);

            if (is == null) {
                throw new TransformerException(
                        "Resource " + res + " not found in resources.");
            }

            return new StreamSource(is);
        }

        throw new TransformerException(
                "Cannot handle procotol of resource " + href);
    }
}
"
core/src/main/java/org/apache/struts2/views/xslt/SimpleAdapterDocument.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.xslt;

import java.util.Arrays;
import java.util.List;

import org.apache.struts2.StrutsException;
import org.w3c.dom.Attr;
import org.w3c.dom.CDATASection;
import org.w3c.dom.Comment;
import org.w3c.dom.DOMConfiguration;
import org.w3c.dom.DOMException;
import org.w3c.dom.DOMImplementation;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentFragment;
import org.w3c.dom.DocumentType;
import org.w3c.dom.Element;
import org.w3c.dom.EntityReference;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.ProcessingInstruction;
import org.w3c.dom.Text;

/**
 * SimpleAdapterDocument adapted a Java object and presents it as
 * a Document.  This class represents the Document container and uses
 * the AdapterFactory to produce a child adapter for the wrapped object.
 * The adapter produced must be of an Element type or an exception is thrown.
 *
 * Note: in theory we could base this on AbstractAdapterElement and then allow
 * the wrapped object to be a more general Node type.  We would just use
 * ourselves as the root element.  However I don't think this is an issue as
 * people expect Documents to wrap Elements.
 */
public class SimpleAdapterDocument extends AbstractAdapterNode implements Document {

    private Element rootElement;

    public SimpleAdapterDocument(
            AdapterFactory adapterFactory, AdapterNode parent, String propertyName, Object value) {
        setContext(adapterFactory, parent, propertyName, value);

    }

    public void setPropertyValue(Object prop) {
        super.setPropertyValue(prop);
        rootElement = null; // recreate the root element
    }

    /**
     * Lazily construct the root element adapter from the value object.
     */
    private Element getRootElement() {
        if (rootElement != null)
            return rootElement;

        Node node = getAdapterFactory().adaptNode(
                this, getPropertyName(), getPropertyValue());
        if (node instanceof Element)
            rootElement = (Element) node;
        else
            throw new StrutsException(
                    "Document adapter expected to wrap an Element type.  Node is not an element:" + node);

        return rootElement;
    }

    protected List<Node> getChildAdapters() {
        return Arrays.asList(new Node[]{getRootElement()});
    }

    public NodeList getChildNodes() {
        return new NodeList() {
            public Node item(int i) {
                return getRootElement();
            }

            public int getLength() {
                return 1;
            }
        };
    }

    public DocumentType getDoctype() {
        return null;
    }

    public Element getDocumentElement() {
        return getRootElement();
    }

    public Element getElementById(String string) {
        return null;
    }

    public NodeList getElementsByTagName(String string) {
        return null;
    }

    public NodeList getElementsByTagNameNS(String string, String string1) {
        return null;
    }

    public Node getFirstChild() {
        return getRootElement();
    }

    public DOMImplementation getImplementation() {
        return null;
    }

    public Node getLastChild() {
        return getRootElement();
    }

    public String getNodeName() {
        return "#document";
    }

    public short getNodeType() {
        return Node.DOCUMENT_NODE;
    }

    public Attr createAttribute(String string) throws DOMException {
        return null;
    }

    public Attr createAttributeNS(String string, String string1) throws DOMException {
        return null;
    }

    public CDATASection createCDATASection(String string) throws DOMException {
        return null;
    }

    public Comment createComment(String string) {
        return null;
    }

    public DocumentFragment createDocumentFragment() {
        return null;
    }

    public Element createElement(String string) throws DOMException {
        return null;
    }

    public Element createElementNS(String string, String string1) throws DOMException {
        return null;
    }

    public EntityReference createEntityReference(String string) throws DOMException {
        return null;
    }

    public ProcessingInstruction createProcessingInstruction(String string, String string1) throws DOMException {
        return null;
    }

    public Text createTextNode(String string) {
        return null;
    }

    public boolean hasChildNodes() {
        return true;
    }

    public Node importNode(Node node, boolean b) throws DOMException {
        return null;
    }

    public Node getChildAfter(Node child) {
        return null;
    }

    public Node getChildBefore(Node child) {
        return null;
    }

    // DOM level 3

    public String getInputEncoding() {
        throw operationNotSupported();
    }

    public String getXmlEncoding() {
        throw operationNotSupported();
    }

    public boolean getXmlStandalone() {
        throw operationNotSupported();
    }

    public void setXmlStandalone(boolean b) throws DOMException {
        throw operationNotSupported();
    }

    public String getXmlVersion() {
        throw operationNotSupported();
    }

    public void setXmlVersion(String string) throws DOMException {
        throw operationNotSupported();
    }

    public boolean getStrictErrorChecking() {
        throw operationNotSupported();
    }

    public void setStrictErrorChecking(boolean b) {
        throw operationNotSupported();
    }

    public String getDocumentURI() {
        throw operationNotSupported();
    }

    public void setDocumentURI(String string) {
        throw operationNotSupported();
    }

    public Node adoptNode(Node node) throws DOMException {
        throw operationNotSupported();
    }

    public DOMConfiguration getDomConfig() {
        throw operationNotSupported();
    }

    public void normalizeDocument() {
        throw operationNotSupported();
    }

    public Node renameNode(Node node, String string, String string1) throws DOMException {
        return null;
    }
    // end DOM level 3
}
"
core/src/main/java/org/apache/struts2/views/xslt/SimpleNodeList.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.xslt;

import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class SimpleNodeList implements NodeList {

    private Log log = LogFactory.getLog(SimpleNodeList.class);

    private List<Node> nodes;

    public SimpleNodeList(List<Node> nodes) {
        this.nodes = nodes;
    }

    public int getLength() {
        if (log.isTraceEnabled())
            log.trace("getLength: " + nodes.size());
        return nodes.size();
    }

    public Node item(int i) {
        log.trace("getItem: " + i);
        return nodes.get(i);
    }

    public String toString() {
        StringBuffer sb = new StringBuffer("SimpleNodeList: [");
        for (int i = 0; i < getLength(); i++)
            sb.append(item(i).getNodeName() + ',');
        sb.append("]");
        return sb.toString();
    }
}
"
core/src/main/java/org/apache/struts2/views/xslt/SimpleTextNode.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.xslt;

import org.apache.struts2.StrutsException;
import org.w3c.dom.DOMException;
import org.w3c.dom.Node;
import org.w3c.dom.Text;


/**
 * 
 */
public class SimpleTextNode extends AbstractAdapterNode implements Node, Text {

    public SimpleTextNode(AdapterFactory rootAdapterFactory, AdapterNode parent, String propertyName, Object value) {
        setContext(rootAdapterFactory, parent, propertyName, value);
    }

    protected String getStringValue() {
        return getPropertyValue().toString();
    }

    public void setData(String string) throws DOMException {
        throw new StrutsException("Operation not supported");
    }

    public String getData() throws DOMException {
        return getStringValue();
    }

    public int getLength() {
        return getStringValue().length();
    }

    public String getNodeName() {
        return "#text";
    }

    public short getNodeType() {
        return Node.TEXT_NODE;
    }

    public String getNodeValue() throws DOMException {
        return getStringValue();
    }

    public void appendData(String string) throws DOMException {
        throw new StrutsException("Operation not supported");
    }

    public void deleteData(int i, int i1) throws DOMException {
        throw new StrutsException("Operation not supported");
    }

    public void insertData(int i, String string) throws DOMException {
        throw new StrutsException("Operation not supported");
    }

    public void replaceData(int i, int i1, String string) throws DOMException {
        throw new StrutsException("Operation not supported");
    }

    public Text splitText(int i) throws DOMException {
        throw new StrutsException("Operation not supported");
    }

    public String substringData(int beginIndex, int endIndex) throws DOMException {
        return getStringValue().substring(beginIndex, endIndex);
    }

    // DOM level 3

    public boolean isElementContentWhitespace() {
        throw operationNotSupported();
    }

    public String getWholeText() {
        throw operationNotSupported();
    }

    public Text replaceWholeText(String string) throws DOMException {
        throw operationNotSupported();
    }
    // end DOM level 3

}
"
core/src/main/java/org/apache/struts2/views/xslt/StringAdapter.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.xslt;

import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;

import javax.xml.parsers.ParserConfigurationException;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.StrutsException;
import org.w3c.dom.Node;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import com.opensymphony.xwork2.util.DomHelper;

/**
 * StringAdapter adapts a Java String value to a DOM Element with the specified
 * property name containing the String's text.
 * e.g. a property <pre>String getFoo() { return "My Text!"; }</pre>
 * will appear in the result DOM as:
 * <foo>MyText!</foo>
 *
 * Subclasses may override the getStringValue() method in order to use StringAdapter
 * as a simplified custom XML adapter for Java types.  A subclass can enable XML
 * parsing of the value string via the setParseStringAsXML() method and then
 * override getStringValue() to return a String containing the custom formatted XML.
 *
 */
public class StringAdapter extends AbstractAdapterElement {

    private Log log = LogFactory.getLog(this.getClass());
    boolean parseStringAsXML;

    public StringAdapter() {
    }

    public StringAdapter(AdapterFactory adapterFactory, AdapterNode parent, String propertyName, String value) {
        setContext(adapterFactory, parent, propertyName, value);
    }

    /**
     * Get the object to be adapted as a String value.
     * <p/>
     * This method can be overridden by subclasses that wish to use StringAdapter
     * as a simplified customizable XML adapter for Java types. A subclass can
     * enable parsing of the value string as containing XML text via the
     * setParseStringAsXML() method and then override getStringValue() to return a
     * String containing the custom formatted XML.
     */
    protected String getStringValue() {
        return getPropertyValue().toString();
    }

    protected List<Node> buildChildAdapters() {
        Node node;
        if (getParseStringAsXML()) {
            log.debug("parsing string as xml: " + getStringValue());
            // Parse the String to a DOM, then proxy that as our child
            node = DomHelper.parse(new InputSource(new StringReader(getStringValue())));
            node = getAdapterFactory().proxyNode(this, node);
        } else {
            log.debug("using string as is: " + getStringValue());
            // Create a Text node as our child
            node = new SimpleTextNode(getAdapterFactory(), this, "text", getStringValue());
        }

        List<Node> children = new ArrayList<Node>();
        children.add(node);
        return children;
    }

    /**
     * Is this StringAdapter to interpret its string values as containing
     * XML Text?
     *
     * @see #setParseStringAsXML(boolean)
     */
    public boolean getParseStringAsXML() {
        return parseStringAsXML;
    }

    /**
     * When set to true the StringAdapter will interpret its String value
     * as containing XML text and parse it to a DOM Element.  The new DOM
     * Element will be a child of this String element. (i.e. wrapped in an
     * element of the property name specified for this StringAdapter).
     *
     * @param parseStringAsXML
     * @see #getParseStringAsXML()
     */
    public void setParseStringAsXML(boolean parseStringAsXML) {
        this.parseStringAsXML = parseStringAsXML;
    }

}
"
core/src/main/java/org/apache/struts2/views/xslt/XSLTResult.java,true,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.xslt;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.Writer;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;

import javax.servlet.http.HttpServletResponse;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Source;
import javax.xml.transform.Templates;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.URIResolver;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts2.ServletActionContext;
import org.apache.struts2.config.Settings;

import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.Result;
import com.opensymphony.xwork2.util.OgnlValueStack;
import com.opensymphony.xwork2.util.TextParseUtil;


/**
 * <!-- START SNIPPET: description -->
 *
 * XSLTResult uses XSLT to transform action object to XML. Recent version has 
 * been specifically modified to deal with Xalan flaws. When using Xalan you may
 * notice that even though you have very minimal stylesheet like this one
 * <pre>
 * &lt;xsl:template match="/result"&gt;
 *   &lt;result /&gt;
 * &lt;/xsl:template&gt;</pre>
 *
 * <p>
 * then Xalan would still iterate through every property of your action and it's
 * all descendants.
 * </p>
 *
 * <p>
 * If you had double-linked objects then Xalan would work forever analysing
 * infinite object tree. Even if your stylesheet was not constructed to process
 * them all. It's becouse current Xalan eagerly and extensively converts
 * everything to it's internal DTM model before further processing.
 * </p>
 * 
 * <p>
 * Thet's why there's a loop eliminator added that works by indexing every
 * object-property combination during processing. If it notices that some
 * object's property were already walked through, it doesn't get any deeper.
 * Say, you have two objects x and y with the following properties set
 * (pseudocode):
 * </p>
 * <pre>
 * x.y = y;
 * and
 * y.x = x;
 * action.x=x;</pre>
 *
 * <p>
 * Due to that modification the resulting XML document based on x would be:
 * </p>
 *
 * <pre>
 * &lt;result&gt;
 *   &lt;x&gt;
 *     &lt;y/&gt;
 *   &lt;/x&gt;
 * &lt;/result&gt;</pre>
 *
 * <p>
 * Without it there would be an endless x/y/x/y/x/y/... elements.
 * </p>
 *
 * <p>
 * The XSLTResult code tries also to deal with the fact that DTM model is built
 * in a manner that childs are processed before siblings. The result is that if
 * there is object x that is both set in action's x property, and very deeply
 * under action's a property then it would only appear under a, not under x.
 * That's not what we expect, and that's why XSLTResult allows objects to repeat
 * in various places to some extent.
 * </p>
 *
 * <p>
 * Sometimes the object mesh is still very dense and you may notice that even
 * though you have relatively simple stylesheet execution takes a tremendous
 * amount of time. To help you to deal with that obstacle of Xalan you may
 * attach regexp filters to elements paths (xpath). 
 * </p>
 *
 * <p>
 * <b>Note:</b> In your .xsl file the root match must be named <tt>result</tt>.
 * <br/>This example will output the username by using <tt>getUsername</tt> on your
 * action class:
 * <pre>
 * &lt;xsl:template match="result"&gt;
 *   &lt;html&gt;
 *   &lt;body&gt;
 *   Hello &lt;xsl:value-of select="username"/&gt; how are you?
 *   &lt;/body&gt;
 *   &lt;html&gt;
 * &lt;xsl:template/&gt;
 * </pre>
 *
 * <p>
 * In the following example the XSLT result would only walk through action's
 * properties without their childs. It would also skip every property that has
 * "hugeCollection" in their name. Element's path is first compared to
 * excludingPattern - if it matches it's no longer processed. Then it is
 * compared to matchingPattern and processed only if there's a match.
 * </p>
 *
 * <!-- END SNIPPET: description -->
 *
 * <pre><!-- START SNIPPET: description.example -->
 * &lt;result name="success" type="xslt"&gt;
 *   &lt;param name="location"&gt;foo.xslt&lt;/param&gt;
 *   &lt;param name="matchingPattern"&gt;^/result/[^/*]$&lt;/param&gt;
 *   &lt;param name="excludingPattern"&gt;.*(hugeCollection).*&lt;/param&gt;
 * &lt;/result&gt;
 * <!-- END SNIPPET: description.example --></pre>
 *
 * <b>This result type takes the following parameters:</b>
 *
 * <!-- START SNIPPET: params -->
 *
 * <ul>
 *
 * <li><b>location (default)</b> - the location to go to after execution.</li>
 *
 * <li><b>parse</b> - true by default. If set to false, the location param will 
 * not be parsed for Ognl expressions.</li>
 *
 * <li><b>matchingPattern</b> - Pattern that matches only desired elements, by
 * default it matches everything.</li>
 *
 * <li><b>excludingPattern</b> - Pattern that eliminates unwanted elements, by
 * default it matches none.</li>
 *
 * </ul>
 *
 * <p>
 * <code>struts.properties</code> related configuration:
 * </p>
 * <ul>
 *
 * <li><b>struts.xslt.nocache</b> - Defaults to false. If set to true, disables
 * stylesheet caching. Good for development, bad for production.</li>
 *
 * </ul>
 *
 * <!-- END SNIPPET: params -->
 *
 * <b>Example:</b>
 *
 * <pre><!-- START SNIPPET: example -->
 * &lt;result name="success" type="xslt"&gt;foo.xslt&lt;/result&gt;
 * <!-- END SNIPPET: example --></pre>
 *
 */
public class XSLTResult implements Result {

    private static final long serialVersionUID = 6424691441777176763L;
    private static final Log log = LogFactory.getLog(XSLTResult.class);
    public static final String DEFAULT_PARAM = "stylesheetLocation";

    protected boolean noCache;
    private final Map<String, Templates> templatesCache;
    private String stylesheetLocation;
    private boolean parse;
    private AdapterFactory adapterFactory;

    public XSLTResult() {
        templatesCache = new HashMap<String, Templates>();
        noCache = Settings.get("struts.xslt.nocache").trim().equalsIgnoreCase("true");
    }

    /**
     * @deprecated Use #setStylesheetLocation(String)
     */
    public void setLocation(String location) {
        setStylesheetLocation(location);
    }

    public void setStylesheetLocation(String location) {
        if (location == null)
            throw new IllegalArgumentException("Null location");
        System.out.println("location = " + location);
        this.stylesheetLocation = location;
    }

    public String getStylesheetLocation() {
        return stylesheetLocation;
    }

    /**
     * If true, parse the stylesheet location for OGNL expressions.
     *
     * @param parse
     */
    public void setParse(boolean parse) {
        this.parse = parse;
    }

    public void execute(ActionInvocation invocation) throws Exception {
        long startTime = System.currentTimeMillis();
        String location = getStylesheetLocation();

        if (parse) {
            OgnlValueStack stack = ActionContext.getContext().getValueStack();
            location = TextParseUtil.translateVariables(location, stack);
        }

        try {
            HttpServletResponse response = ServletActionContext.getResponse();

            Writer writer = response.getWriter();

            // Create a transformer for the stylesheet.
            Templates templates = null;
            Transformer transformer;
            if (location != null) {
                templates = getTemplates(location);
                transformer = templates.newTransformer();
            } else
                transformer = TransformerFactory.newInstance().newTransformer();

            transformer.setURIResolver(getURIResolver());

            String mimeType;
            if (templates == null)
                mimeType = "text/xml"; // no stylesheet, raw xml
            else
                mimeType = templates.getOutputProperties().getProperty(OutputKeys.MEDIA_TYPE);
            if (mimeType == null) {
                // guess (this is a servlet, so text/html might be the best guess)
                mimeType = "text/html";
            }

            response.setContentType(mimeType);

            Source xmlSource = getDOMSourceForStack(invocation.getAction());

            // Transform the source XML to System.out.
            PrintWriter out = response.getWriter();

            log.debug("xmlSource = " + xmlSource);
            transformer.transform(xmlSource, new StreamResult(out));

            out.close(); // ...and flush...

            if (log.isDebugEnabled()) {
                log.debug("Time:" + (System.currentTimeMillis() - startTime) + "ms");
            }

            writer.flush();
        } catch (Exception e) {
            log.error("Unable to render XSLT Template, '" + location + "'", e);
            throw e;
        }
    }

    protected AdapterFactory getAdapterFactory() {
        if (adapterFactory == null)
            adapterFactory = new AdapterFactory();
        return adapterFactory;
    }

    protected void setAdapterFactory(AdapterFactory adapterFactory) {
        this.adapterFactory = adapterFactory;
    }

    /**
     * Get the URI Resolver to be called by the processor when it encounters an xsl:include, xsl:import, or document()
     * function. The default is an instance of ServletURIResolver, which operates relative to the servlet context.
     */
    protected URIResolver getURIResolver() {
        return new ServletURIResolver(
                ServletActionContext.getServletContext());
    }

    protected Templates getTemplates(String path) throws TransformerException, IOException {
        String pathFromRequest = ServletActionContext.getRequest().getParameter("xslt.location");

        if (pathFromRequest != null)
            path = pathFromRequest;

        if (path == null)
            throw new TransformerException("Stylesheet path is null");

        Templates templates = templatesCache.get(path);

        if (noCache || (templates == null)) {
            synchronized (templatesCache) {
                URL resource = ServletActionContext.getServletContext().getResource(path);

                if (resource == null) {
                    throw new TransformerException("Stylesheet " + path + " not found in resources.");
                }

                log.debug("Preparing XSLT stylesheet templates: " + path);

                TransformerFactory factory = TransformerFactory.newInstance();
                templates = factory.newTemplates(new StreamSource(resource.openStream()));
                templatesCache.put(path, templates);
            }
        }

        return templates;
    }

    protected Source getDOMSourceForStack(Object action)
            throws IllegalAccessException, InstantiationException {
        return new DOMSource(getAdapterFactory().adaptDocument("result", action) );
	}
}
"
extras/src/main/java/org/apache/struts2/dispatcher/ChartResult.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher;

import org.apache.struts2.ServletActionContext;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.Result;
import org.jfree.chart.ChartUtilities;
import org.jfree.chart.JFreeChart;

import javax.servlet.http.HttpServletResponse;
import java.io.OutputStream;


/**
 * A custom Result type for chart data. Built on top of
 * <a href="http://www.jfree.org/jfreechart/" target="_blank">JFreeChart</a>. When executed
 * this Result will write the given chart as a PNG to the servlet output stream.
 *
 */
public class ChartResult implements Result {

	private static final long serialVersionUID = -6484761870055986612L;
	
	JFreeChart chart;
    boolean chartSet = false;
    private int height;
    private int width;


    /**
     * Sets the JFreeChart to use.
     *
     * @param chart a JFreeChart object.
     */
    public void setChart(JFreeChart chart) {
        this.chart = chart;
        chartSet = true;
    }

    /**
     * Sets the chart height.
     *
     * @param height the height of the chart in pixels.
     */
    public void setHeight(int height) {
        this.height = height;
    }

    /**
     * Sets the chart width.
     *
     * @param width the width of the chart in pixels.
     */
    public void setWidth(int width) {
        this.width = width;
    }

    /**
     * Executes the result. Writes the given chart as a PNG to the servlet output stream.
     *
     * @param invocation an encapsulation of the action execution state.
     * @throws Exception if an error occurs when creating or writing the chart to the servlet output stream.
     */
    public void execute(ActionInvocation invocation) throws Exception {
        JFreeChart chart = null;

        if (chartSet) {
            chart = this.chart;
        } else {
            chart = (JFreeChart) invocation.getStack().findValue("chart");
        }

        if (chart == null) {
            throw new NullPointerException("No chart found");
        }

        HttpServletResponse response = ServletActionContext.getResponse();
        OutputStream os = response.getOutputStream();
        ChartUtilities.writeChartAsPNG(os, chart, width, height);
        os.flush();
    }
}
"
extras/src/main/java/org/apache/struts2/dispatcher/multipart/PellMultiPartRequest.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.dispatcher.multipart;

import org.apache.struts2.config.Settings;
import org.apache.struts2.StrutsConstants;
import http.utils.multipartrequest.ServletMultipartRequest;

import javax.servlet.http.HttpServletRequest;
import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.List;


/**
 * Multipart form data request adapter for Jason Pell's multipart utils package.
 *
 */
public class PellMultiPartRequest extends MultiPartRequest {

    private ServletMultipartRequest multi;


    /**
     * Creates a new request wrapper to handle multi-part data using methods adapted from Jason Pell's
     * multipart classes (see class description).
     *
     * @param maxSize        maximum size post allowed
     * @param saveDir        the directory to save off the file
     * @param servletRequest the request containing the multipart
     */
    public PellMultiPartRequest(HttpServletRequest servletRequest, String saveDir, int maxSize) throws IOException {
        //this needs to be synchronised, as we should not change the encoding at the same time as
        //calling the constructor.  See javadoc for MultipartRequest.setEncoding().
        synchronized (this) {
            setEncoding();
            multi = new ServletMultipartRequest(servletRequest, saveDir, maxSize);
        }
    }


    public Enumeration getFileParameterNames() {
        return multi.getFileParameterNames();
    }

    public String[] getContentType(String fieldName) {
        return new String[]{multi.getContentType(fieldName)};
    }

    public File[] getFile(String fieldName) {
        return new File[]{multi.getFile(fieldName)};
    }

    public String[] getFileNames(String fieldName) {

        // TODO - not sure about this - is this the filename of the actual file or
        // TODO - the uploaded filename as provided by the browser?
        // TODO - Not sure what version of Pell this class uses as it doesn't seem to be the latest
        return new String[]{multi.getFile(fieldName).getName()};
    }

    public String[] getFilesystemName(String fieldName) {
        return new String[]{multi.getFileSystemName(fieldName)};
    }

    public String getParameter(String name) {
        return multi.getURLParameter(name);
    }

    public Enumeration getParameterNames() {
        return multi.getParameterNames();
    }

    public String[] getParameterValues(String name) {
        Enumeration enumeration = multi.getURLParameters(name);

        if (!enumeration.hasMoreElements()) {
            return null;
        }

        List values = new ArrayList();

        while (enumeration.hasMoreElements()) {
            values.add(enumeration.nextElement());
        }

        return (String[]) values.toArray(new String[values.size()]);
    }

    public List getErrors() {
        return Collections.EMPTY_LIST;
    }

    /**
     * Sets the encoding for the uploaded params.  This needs to be set if you are using character sets other than
     * ASCII.
     * <p/>
     * The encoding is looked up from the configuration setting 'struts.i18n.encoding'.  This is usually set in
     * default.properties & struts.properties.
     */
    private static void setEncoding() {
        String encoding = null;

        try {
            encoding = Settings.get(StrutsConstants.STRUTS_I18N_ENCODING);

            if (encoding != null) {
                //NB: This should never be called at the same time as the constructor for
                //ServletMultiPartRequest, as it can cause problems.
                //See javadoc for MultipartRequest.setEncoding()
                http.utils.multipartrequest.MultipartRequest.setEncoding(encoding);
            } else {
                http.utils.multipartrequest.MultipartRequest.setEncoding("UTF-8");
            }
        } catch (IllegalArgumentException e) {
            log.info("Could not get encoding property 'struts.i18n.encoding' for file upload.  Using system default");
        } catch (UnsupportedEncodingException e) {
            log.error("Encoding " + encoding + " is not a valid encoding.  Please check your struts.properties file.");
        }
    }
}
"
extras/src/main/java/org/apache/struts2/views/jasperreports/CompileReport.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jasperreports;

import net.sf.jasperreports.engine.JRException;
import net.sf.jasperreports.engine.JasperCompileManager;

/**
 * Ported to Struts:
 *
 */
public class CompileReport {

    public static void main(String[] args) {
        if (args.length < 1) {
            System.out.println("Please supply the name of the report(s) source to compile.");
            System.exit(-1);
        }

        try {
            for (int i = 0; i < args.length; i++) {
                System.out.println("JasperReports Compiling: " + args[i]);
                JasperCompileManager.compileReportToFile(args[i]);
            }
        } catch (JRException e) {
            e.printStackTrace();
            System.exit(-1);
        }

        System.exit(0);
    }
}
"
extras/src/main/java/org/apache/struts2/views/jasperreports/JasperReportConstants.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jasperreports;


/**
 * <code>JasperReportConstants</code>
 *
 */
public interface JasperReportConstants {

    /**
     * PDF format constant
     */
    public static final String FORMAT_PDF = "PDF";

    /**
     * XML format constant
     */
    public static final String FORMAT_XML = "XML";

    /**
     * HTML format constant
     */
    public static final String FORMAT_HTML = "HTML";

    /**
     * XLS format constant
     */
    public static final String FORMAT_XLS = "XLS";

    /**
     * CSV format constant
     */
    public static final String FORMAT_CSV = "CSV";
}
"
extras/src/main/java/org/apache/struts2/views/jasperreports/JasperReportsResult.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jasperreports;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import net.sf.jasperreports.engine.*;
import net.sf.jasperreports.engine.export.JRCsvExporter;
import net.sf.jasperreports.engine.export.JRCsvExporterParameter;
import net.sf.jasperreports.engine.export.JRHtmlExporter;
import net.sf.jasperreports.engine.export.JRHtmlExporterParameter;
import net.sf.jasperreports.engine.export.JRXlsExporter;
import net.sf.jasperreports.engine.export.JRXmlExporter;
import net.sf.jasperreports.engine.util.JRLoader;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.opensymphony.xwork2.util.TextUtils;
import org.apache.struts2.ServletActionContext;
import org.apache.struts2.dispatcher.StrutsResultSupport;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.util.OgnlValueStack;

/**
 * <!-- START SNIPPET: description -->
 *
 * Generates a JasperReports report using the specified format or PDF if no
 * format is specified.
 *
 * <!-- END SNIPPET: description -->
 * <p />
 * <b>This result type takes the following parameters:</b>
 *
 * <!-- START SNIPPET: params -->
 *
 * <ul>
 *
 * <li><b>location (default)</b> - the location where the compiled jasper report
 * definition is (foo.jasper), relative from current URL.</li>
 *
 * <li><b>dataSource (required)</b> - the Ognl expression used to retrieve the
 * datasource from the value stack (usually a List).</li>
 *
 * <li><b>parse</b> - true by default. If set to false, the location param will
 * not be parsed for Ognl expressions.</li>
 *
 * <li><b>format</b> - the format in which the report should be generated. Valid
 * values can be found in {@link JasperReportConstants}. If no format is
 * specified, PDF will be used.</li>
 *
 * <li><b>contentDisposition</b> - disposition (defaults to "inline", values are
 * typically <i>filename="document.pdf"</i>).</li>
 *
 * <li><b>documentName</b> - name of the document (will generate the http header
 * <code>Content-disposition = X; filename=X.[format]</code>).</li>
 *
 * <li><b>delimiter</b> - the delimiter used when generating CSV reports. By
 * default, the character used is ",".</li>
 *
 * <li><b>imageServletUrl</b> - name of the url that, when prefixed with the
 * context page, can return report images.</li>
 *
 * </ul>
 *
 * <p>
 * This result follows the same rules from {@link StrutsResultSupport}.
 * Specifically, all parameters will be parsed if the "parse" parameter is not 
 * set to false.
 * </p>
 * <!-- END SNIPPET: params -->
 *
 * <b>Example:</b>
 *
 * <pre><!-- START SNIPPET: example1 -->
 * &lt;result name="success" type="jasper"&gt;
 *   &lt;param name="location"&gt;foo.jasper&lt;/param&gt;
 *   &lt;param name="dataSource"&gt;mySource&lt;/param&gt;
 *   &lt;param name="format"&gt;CSV&lt;/param&gt;
 * &lt;/result&gt;
 * <!-- END SNIPPET: example1 --></pre>
 * or for pdf
 * <pre><!-- START SNIPPET: example2 -->
 * &lt;result name="success" type="jasper"&gt;
 *   &lt;param name="location"&gt;foo.jasper&lt;/param&gt;
 *   &lt;param name="dataSource"&gt;mySource&lt;/param&gt;
 * &lt;/result&gt;
 * <!-- END SNIPPET: example2 --></pre>
 *
 */
public class JasperReportsResult extends StrutsResultSupport implements JasperReportConstants {
	
	private static final long serialVersionUID = -2523174799621182907L;


	private final static Log LOG = LogFactory.getLog(JasperReportsResult.class);


    protected String dataSource;
    protected String format;
    protected String documentName;
    protected String contentDisposition;
    protected String delimiter;
    protected String imageServletUrl = "/images/"; 
    

    public String getImageServletUrl() {
        return imageServletUrl;
    }

    public void setImageServletUrl(final String imageServletUrl) {
        this.imageServletUrl = imageServletUrl;
    }

    public void setDataSource(String dataSource) {
        this.dataSource = dataSource;
    }

    public void setFormat(String format) {
        this.format = format;
    }

    public void setDocumentName(String documentName) {
        this.documentName = documentName;
    }

    public void setContentDisposition(String contentDisposition) {
        this.contentDisposition = contentDisposition;
    }

    public void setDelimiter(String delimiter) {
        this.delimiter = delimiter;
    }

    protected void doExecute(String finalLocation, ActionInvocation invocation) throws Exception {
        if (this.format == null) {
            this.format = FORMAT_PDF;
        }

        if (dataSource == null) {
            String message = "No dataSource specified...";
            LOG.error(message);
            throw new RuntimeException(message);
        }

        if (LOG.isDebugEnabled()) {
            LOG.debug("Creating JasperReport for dataSource = " + dataSource + ", format = " + this.format);
        }

        HttpServletRequest request = (HttpServletRequest) invocation.getInvocationContext().get(ServletActionContext.HTTP_REQUEST);
        HttpServletResponse response = (HttpServletResponse) invocation.getInvocationContext().get(ServletActionContext.HTTP_RESPONSE);

        //construct the data source for the report
        OgnlValueStack stack = invocation.getStack();
        OgnlValueStackDataSource stackDataSource = new OgnlValueStackDataSource(stack, dataSource);

        format = conditionalParse(format, invocation);
        dataSource = conditionalParse(dataSource, invocation);

        if (contentDisposition != null) {
            contentDisposition = conditionalParse(contentDisposition, invocation);
        }

        if (documentName != null) {
            documentName = conditionalParse(documentName, invocation);
        }

        // (Map) ActionContext.getContext().getSession().get("IMAGES_MAP");
        if (!TextUtils.stringSet(format)) {
            format = FORMAT_PDF;
        }

        if (!"contype".equals(request.getHeader("User-Agent"))) {
            // Determine the directory that the report file is in and set the reportDirectory parameter
            // For WW 2.1.7:
            //  ServletContext servletContext = ((ServletConfig) invocation.getInvocationContext().get(ServletActionContext.SERVLET_CONFIG)).getServletContext();
            ServletContext servletContext = (ServletContext) invocation.getInvocationContext().get(ServletActionContext.SERVLET_CONTEXT);
            String systemId = servletContext.getRealPath(finalLocation);
            Map parameters = new OgnlValueStackShadowMap(stack);
            File directory = new File(systemId.substring(0, systemId.lastIndexOf(File.separator)));
            parameters.put("reportDirectory", directory);
            parameters.put(JRParameter.REPORT_LOCALE, invocation.getInvocationContext().getLocale());

            byte[] output;
            JasperPrint jasperPrint;

            // Fill the report and produce a print object
            try {
                JasperReport jasperReport = (JasperReport) JRLoader.loadObject(systemId);

                jasperPrint =
                        JasperFillManager.fillReport(jasperReport,
                                parameters,
                                stackDataSource);
            } catch (JRException e) {
                LOG.error("Error building report for uri " + systemId, e);
                throw new ServletException(e.getMessage(), e);
            }

            // Export the print object to the desired output format
            try {
                if (contentDisposition != null || documentName != null) {
                    final StringBuffer tmp = new StringBuffer();
                    tmp.append((contentDisposition == null) ? "inline" : contentDisposition);

                    if (documentName != null) {
                        tmp.append("; filename=");
                        tmp.append(documentName);
                        tmp.append(".");
                        tmp.append(format.toLowerCase());
                    }

                    response.setHeader("Content-disposition", tmp.toString());
                }

                if (format.equals(FORMAT_PDF)) {
                    response.setContentType("application/pdf");

                    // response.setHeader("Content-disposition", "inline; filename=report.pdf");
                    output = JasperExportManager.exportReportToPdf(jasperPrint);
                } else {
                    JRExporter exporter;

                    if (format.equals(FORMAT_CSV)) {
                        response.setContentType("text/plain");
                        exporter = new JRCsvExporter();
                    } else if (format.equals(FORMAT_HTML)) {
                        response.setContentType("text/html");

                        // IMAGES_MAPS seems to be only supported as "backward compatible" from JasperReports 1.1.0
                
                        Map imagesMap = new HashMap();

                        request.getSession(true).setAttribute("IMAGES_MAP", imagesMap);
                        exporter = new JRHtmlExporter();
                        exporter.setParameter(JRHtmlExporterParameter.IMAGES_MAP, imagesMap);
                        exporter.setParameter(JRHtmlExporterParameter.IMAGES_URI, request.getContextPath() + imageServletUrl);
                        // Needed to support chart images:
                        exporter.setParameter(JRExporterParameter.JASPER_PRINT, jasperPrint);
                        request.getSession().setAttribute("net.sf.jasperreports.j2ee.jasper_print", jasperPrint);

                    } else if (format.equals(FORMAT_XLS)) {
                        response.setContentType("application/vnd.ms-excel");
                        exporter = new JRXlsExporter();
                    } else if (format.equals(FORMAT_XML)) {
                        response.setContentType("text/xml");
                        exporter = new JRXmlExporter();
                    } else {
                        throw new ServletException("Unknown report format: " + format);
                    }

                    output = exportReportToBytes(jasperPrint, exporter);
                }
            } catch (JRException e) {
                String message = "Error producing " + format + " report for uri " + systemId;
                LOG.error(message, e);
                throw new ServletException(e.getMessage(), e);
            }

            response.setContentLength(output.length);

            ServletOutputStream ouputStream;

            try {
                ouputStream = response.getOutputStream();
                ouputStream.write(output);
                ouputStream.flush();
                ouputStream.close();
            } catch (IOException e) {
                LOG.error("Error writing report output", e);
                throw new ServletException(e.getMessage(), e);
            }
        } else {
            // Code to handle "contype" request from IE
            try {
                ServletOutputStream outputStream;
                response.setContentType("application/pdf");
                response.setContentLength(0);
                outputStream = response.getOutputStream();
                outputStream.close();
            } catch (IOException e) {
                LOG.error("Error writing report output", e);
                throw new ServletException(e.getMessage(), e);
            }
        }
    }

    /**
     * Run a Jasper report to CSV format and put the results in a byte array
     *
     * @param jasperPrint The Print object to render as CSV
     * @param exporter    The exporter to use to export the report
     * @return A CSV formatted report
     * @throws net.sf.jasperreports.engine.JRException
     *          If there is a problem running the report
     */
    private byte[] exportReportToBytes(JasperPrint jasperPrint, JRExporter exporter) throws JRException {
        byte[] output;
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        exporter.setParameter(JRExporterParameter.JASPER_PRINT, jasperPrint);
        exporter.setParameter(JRExporterParameter.OUTPUT_STREAM, baos);
        if (delimiter != null) {
            exporter.setParameter(JRCsvExporterParameter.FIELD_DELIMITER, delimiter);
        }

        exporter.exportReport();

        output = baos.toByteArray();

        return output;
    }
}
"
extras/src/main/java/org/apache/struts2/views/jasperreports/OgnlValueStackDataSource.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jasperreports;

import org.apache.struts2.util.MakeIterator;
import com.opensymphony.xwork2.util.OgnlValueStack;
import net.sf.jasperreports.engine.JRDataSource;
import net.sf.jasperreports.engine.JRException;
import net.sf.jasperreports.engine.JRField;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.util.Iterator;

/**
 * Ported to Struts.
 *
 */
public class OgnlValueStackDataSource implements JRDataSource {

    /**
     * Logger for this class
     */
    private static Log log = LogFactory.getLog(OgnlValueStackDataSource.class);


    Iterator iterator;
    OgnlValueStack valueStack;
    boolean firstTimeThrough = true;


    /**
     * Create a value stack data source on the given iterable property
     *
     * @param valueStack The value stack to base the data source on
     * @param dataSource The property to iterate over for the report
     */
    public OgnlValueStackDataSource(OgnlValueStack valueStack, String dataSource) {
        this.valueStack = valueStack;

        Object dataSourceValue = valueStack.findValue(dataSource);

        if (dataSourceValue != null) {
            if (MakeIterator.isIterable(dataSourceValue)) {
                iterator = MakeIterator.convert(dataSourceValue);
            } else {
                Object[] array = new Object[1];
                array[0] = dataSourceValue;
                iterator = MakeIterator.convert(array);
            }
        } else {
            log.warn("Data source value for data source " + dataSource + " was null");
        }
    }


    /**
     * Get the value of a given field
     *
     * @param field The field to get the value for. The expression language to get the value
     *              of the field is either taken from the description property or from the name of the field
     *              if the description is <code>null</code>.
     * @return an <code>Object</code> containing the field value or a new
     *         <code>OgnlValueStackDataSource</code> object if the field value evaluates to
     *         an object that can be iterated over.
     * @throws JRException if there is a problem obtaining the value
     */
    public Object getFieldValue(JRField field) throws JRException {
        //TODO: move the code to return a OgnlValueStackDataSource to a seperate
        //      method when and if the JRDataSource interface is updated to support
        //      this.
        String expression = field.getDescription();

        if (expression == null) {
            //Description is optional so use the field name as a default
            expression = field.getName();
        }

        Object value = valueStack.findValue(expression);

        if (log.isDebugEnabled()) {
            log.debug("field: " + field.getName() + "/" + value);
        }

        if (MakeIterator.isIterable(value)) {
            //                return new OgnlValueStackDataSource(this.valueStack, field.getName());
            return new OgnlValueStackDataSource(this.valueStack, expression);
        } else {
            return value;
        }
    }

    /**
     * Is there any more data
     *
     * @return <code>true</code> if there are more elements to iterate over and
     *         <code>false</code> otherwise
     * @throws JRException if there is a problem determining whether there
     *                     is more data
     */
    public boolean next() throws JRException {
        if (firstTimeThrough) {
            firstTimeThrough = false;
        } else {
            valueStack.pop();
        }

        if ((iterator != null) && (iterator.hasNext())) {
            valueStack.push(iterator.next());
            log.debug("Pushed next value: " + valueStack.findValue("."));

            return true;
        } else {
            log.debug("No more values");

            return false;
        }
    }
}
"
extras/src/main/java/org/apache/struts2/views/jasperreports/OgnlValueStackShadowMap.java,false,"/*
 * $Id$
 *
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.struts2.views.jasperreports;

import com.opensymphony.xwork2.util.OgnlValueStack;

import java.util.HashMap;
import java.util.Set;


/**
 * Ported to Struts:
 *
 */
public class OgnlValueStackShadowMap extends HashMap {

	private static final long serialVersionUID = -167109778490907240L;

	/**
     * valueStack reference
     */
    OgnlValueStack valueStack;

    /**
     * entries reference
     */
    Set entries;


    /**
     * Constructs an instance of OgnlValueStackShadowMap.
     *
     * @param valueStack - the underlying valuestack
     */
    public OgnlValueStackShadowMap(OgnlValueStack valueStack) {
        this.valueStack = valueStack;
    }


    /**
     * Implementation of containsKey(), overriding HashMap implementation.
     *
     * @param key - The key to check in HashMap and if not found to check on valueStack.
     * @return <tt>true</tt>, if conatins key, <tt>false</tt> otherwise.
     * @see java.util.HashMap#containsKey
     */
    public boolean containsKey(Object key) {
        boolean hasKey = super.containsKey(key);

        if (!hasKey) {
            if (valueStack.findValue((String) key) != null) {
                hasKey = true;
            }
        }

        return hasKey;
    }

    /**
     * Implementation of get(), overriding HashMap implementation.
     *
     * @param key - The key to get in HashMap and if not found there from the valueStack.
     * @return value - The object from HashMap or if null, from the valueStack.
     * @see java.util.HashMap#get
     */
    public Object get(Object key) {
        Object value = super.get(key);

        if ((value == null) && key instanceof String) {
            value = valueStack.findValue((String) key);
        }

        return value;
    }
}
"
